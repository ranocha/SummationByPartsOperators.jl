var documenterSearchIndex = {"docs":
[{"location":"tutorials/variable_linear_advection/#Linear-advection-equation-with-variable-coefficients","page":"Linear advection equation with variable coefficients","title":"Linear advection equation with variable coefficients","text":"","category":"section"},{"location":"tutorials/variable_linear_advection/","page":"Linear advection equation with variable coefficients","title":"Linear advection equation with variable coefficients","text":"This tutorial is concerned with the linear advection equation","category":"page"},{"location":"tutorials/variable_linear_advection/","page":"Linear advection equation with variable coefficients","title":"Linear advection equation with variable coefficients","text":"beginaligned\n    partial_t u(tx) + partial_x (a(x) u(tx)) = 0  t in (0T) x in (x_min x_max) \n    u(0x) = u_0(x)  x in (x_min x_max) \n    textboundary conditions  x in partial (x_min x_max)\nendaligned","category":"page"},{"location":"tutorials/variable_linear_advection/","page":"Linear advection equation with variable coefficients","title":"Linear advection equation with variable coefficients","text":"with variable coefficient a.","category":"page"},{"location":"tutorials/variable_linear_advection/","page":"Linear advection equation with variable coefficients","title":"Linear advection equation with variable coefficients","text":"The boundary conditions depend on the sign of the transport velocity a at the boundary. In particular, specifying a Dirichlet type boundary condition is only allowed for inflow boundaries, e.g. a(x_min)  0 at x = x_min.","category":"page"},{"location":"tutorials/variable_linear_advection/","page":"Linear advection equation with variable coefficients","title":"Linear advection equation with variable coefficients","text":"SummationByPartsOperators.jl includes a pre-built semidiscretization of this equation: VariableLinearAdvectionNonperiodicSemidiscretisation. Have a look at the source code if you want to dig deeper. Below is an example demonstrating how to use this semidiscretization.","category":"page"},{"location":"tutorials/variable_linear_advection/","page":"Linear advection equation with variable coefficients","title":"Linear advection equation with variable coefficients","text":"using SummationByPartsOperators, OrdinaryDiffEq\nusing LaTeXStrings; using Plots: Plots, plot, plot!, savefig\n\n# general parameters\nxmin = -1.\nxmax = +1.\ntspan = (0., 8.0)\nafunc(x) = one(x)\nu0func(x) = sinpi(x)\n# Dirichlet type boundary conditions; they are used only at inflow boundaries\nleft_bc(t) = t >= 3 ? sinpi(t) : zero(t)\nright_bc(t) = zero(t)\n\n# discretization parameters\ninterior_order = 4\nN = 101\n# whether a split form should be applied or not\nsplit_form = Val(false)\n\n# setup spatial semidiscretization\nD = derivative_operator(MattssonSvärdShoeybi2008(), 1, interior_order, xmin, xmax, N)\n# whether or not artificial dissipation should be applied: nothing, dissipation_operator(D)\nDi = nothing\nsemidisc = VariableLinearAdvectionNonperiodicSemidiscretisation(D, Di, afunc, split_form, left_bc, right_bc)\node = semidiscretize(u0func, semidisc, tspan)\n\n# solve ODE\nsol = solve(ode, SSPRK104(), dt=D.Δx, adaptive=false,\n            save_everystep=false)\n\n# visualise the result\nplot(xguide=L\"x\", yguide=L\"u\")\nplot!(evaluate_coefficients(sol[1], semidisc), label=L\"u_0\")\nplot!(evaluate_coefficients(sol[end], semidisc), label=L\"u_\\mathrm{numerical}\")\nsavefig(\"example_linear_advection.png\");","category":"page"},{"location":"tutorials/variable_linear_advection/","page":"Linear advection equation with variable coefficients","title":"Linear advection equation with variable coefficients","text":"(Image: )","category":"page"},{"location":"applications/#Applications","page":"Applications","title":"Applications","text":"","category":"section"},{"location":"applications/","page":"Applications","title":"Applications","text":"Here is a (non-exhaustive) list of research using SummationByPartsOperators.jl.","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"Hendrik Ranocha, Manuel Quezada de Luna, and David I Ketcheson (2021). On the Rate of Error Growth in Time for Numerical Solutions of Nonlinear Dispersive Wave Equations. arXiv: 2102.07376 [math.NA] A reproducibility repository containing source code for all numerical experiments is available at DOI: 10.5281/zenodo.4540467\nHendrik Ranocha, Dimitrios Mitsotakis, and David I Ketcheson (2021). A Broad Class of Conservative Numerical Methods for Dispersive Wave Equations. DOI: 10.4208/cicp.OA-2020-0119 A reproducibility repository containing source code for all numerical experiments is available at DOI: 10.5281/zenodo.3908803\nPhilippe G LeFloch and Hendrik Ranocha (2021). Kinetic functions for nonclassical shocks, entropy stability, and discrete summation by parts. DOI: 10.1007/s10915-021-01463-6\nJan Nordström and Hendrik Ranocha (2021). A New Class of A Stable Summation by Parts Time Integration Schemes with Strong Initial Conditions. DOI: 10.1007/s10915-021-01454-7 A reproducibility repository containing source code for all numerical experiments is available at DOI: 10.5281/zenodo.3699173\nHendrik Ranocha (2021). On Strong Stability of Explicit Runge-Kutta Methods for Nonlinear Semibounded Operators. DOI: 10.1093/imanum/drz070\nHendrik Ranocha and David I Ketcheson (2020). Energy Stability of Explicit Runge-Kutta Methods for Nonautonomous or Nonlinear Problems. DOI: 10.1137/19M1290346 A reproducibility repository containing source code for all numerical experiments is available at DOI: 10.5281/zenodo.3464243\nHendrik Ranocha, Katharina Ostaszewski, and Philip Heinisch (2020). Discrete Vector Calculus and Helmholtz Hodge Decomposition for Classical Finite Difference Summation by Parts Operators. DOI: 10.1007/s42967-019-00057-2 A reproducibility repository containing source code for all numerical experiments is available at DOI: 10.5281/zenodo.3375170\nHendrik Ranocha and Gregor J Gassner (2020). Preventing pressure oscillations does not fix local linear stability issues of entropy-based split-form high-order schemes. arXiv: 2009.13139 [math.NA] A reproducibility repository containing source code for all numerical experiments is available at DOI: 10.5281/zenodo.4054366\nPhilipp Öffner and Hendrik Ranocha (2019). Error Boundedness of Discontinuous Galerkin Methods with Variable Coefficients. DOI: 10.1007/s10915-018-00902-1","category":"page"},{"location":"applications/","page":"Applications","title":"Applications","text":"If you use this package for your own research, please cite it as described in the documentation and make a PR to add your work to the list above.","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"ContributingSummationByPartsOperators.jl is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as pull requests) any time. For planned larger contributions, it is often beneficial to get in contact first, for example via issues.SummationByPartsOperators.jl and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.Developer Certificate of Origin (Version 1.1)The following text was taken from https://developercertificate.org:Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"tutorials/constant_linear_advection/#Linear-advection-equation-with-constant-coefficients","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"","category":"section"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"This tutorial is concerned with the basic linear advection equation","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"beginaligned\n    partial_t u(tx) + partial_x u(tx) = 0  t in (0T) x in (x_min x_max) \n    u(0x) = u_0(x)  x in (x_min x_max) \n    u(tx_min) = u_L(t)\nendaligned","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"Note that the advection velocity is positive (unity). Thus, a boundary condition needs to be specified exactly at the left boundary. Otherwise, the problem will not be well-posed (under-specified or over-specified).","category":"page"},{"location":"tutorials/constant_linear_advection/#Basic-example-using-finite-difference-SBP-operators","page":"Linear advection equation with constant coefficients","title":"Basic example using finite difference SBP operators","text":"","category":"section"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"Let's create an appropriate discretization of this equation step by step. At first, we load packages that we will use in this example.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"using SummationByPartsOperators, OrdinaryDiffEq\nusing LaTeXStrings; using Plots: Plots, plot, plot!, savefig","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"Next, we specify the initial and boundary data as Julia functions as well as the spatial domain and the time span.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"xmin, xmax = -1.0, 1.0\nu0_func(x) = sinpi(x)\nuL_func(t) = t >= 3 ? sinpi(t) : zero(t)\ntspan = (0., 8.0)","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"This choice of the domain and boundary condition ensures that the initial profile is transported out of the domain before non-homogeneous boundary data influences the solution.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"Next, we implement the semidiscretization using the interface of OrdinaryDiffEq.jl which is part of DifferentialEquations.jl.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"function rhs!(du, u, D, t)\n  # Set `du = - D * u` using in-place multiplication avoiding allocations\n  # for efficiency\n  mul!(du, D, u, -one(eltype(D)))\n\n  # Next, we impose the boundary conditions weakly using an SAT at the left\n  # boundary. Since we use the strong form of the equation, we do not need to\n  # do anything at the right boundary.\n  # Assuming that boundary nodes are included in the grid, adding this SAT\n  # can be achieved by\n  du[begin] += (uL_func(t) - u[begin]) / left_boundary_weight(D)\n\n  return nothing\nend","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"Here, we have used a simultaneous approximation term (SAT) to impose the boundary condition weakly. In general, this approach is related to the weak imposition of boundary conditions using numerical fluxes in finite volume and discontinuous Galerkin methods; they are even equivalent for the linear advection equation considered here.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"Next, we choose an SBP operator D, evaluate the initial data on the grid, and set up the semidiscretization as an ODE problem.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"D = derivative_operator(MattssonNordström2004(), derivative_order=1, accuracy_order=4,\n                        xmin=xmin, xmax=xmax, N=101)\nu0 = compute_coefficients(u0_func, D)\node = ODEProblem(rhs!, u0, tspan, D);","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"Finally, we can solve the ODE using an explicit Runge-Kutta method with adaptive time stepping.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"sol = solve(ode, Tsit5(), saveat=range(first(tspan), stop=last(tspan), length=200));\n\nplot(xguide=L\"x\", yguide=L\"u\")\nplot!(evaluate_coefficients(sol[1], D), label=L\"u_0\")\nplot!(evaluate_coefficients(sol[end], D), label=L\"u_\\mathrm{numerical}\")\nsavefig(\"example_linear_advection.png\");","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"(Image: )","category":"page"},{"location":"tutorials/constant_linear_advection/#Advanced-visualization","page":"Linear advection equation with constant coefficients","title":"Advanced visualization","text":"","category":"section"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"Let's create an animation of the numerical solution.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"using Printf; using Plots: Animation, frame, gif\n\nlet anim = Animation()\n    idx = 1\n    x, u = evaluate_coefficients(sol[idx], D)\n    fig = plot(x, u, xguide=L\"x\", yguide=L\"u\", xlim=extrema(x), ylim=(-1.05, 1.05),\n              label=\"\", title=@sprintf(\"\\$t = %6.2f \\$\", sol.t[idx]))\n    for idx in 1:length(sol.t)\n        fig[1] = x, sol.u[idx]\n        plot!(title=@sprintf(\"\\$t = %6.2f \\$\", sol.t[idx]))\n        frame(anim)\n    end\n    gif(anim, \"example_linear_advection.gif\")\nend","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"(Image: example_linear_advection_animation)","category":"page"},{"location":"tutorials/constant_linear_advection/#Continuous-and-discontinuous-Galerkin-methods","page":"Linear advection equation with constant coefficients","title":"Continuous and discontinuous Galerkin methods","text":"","category":"section"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"You can use a CG or DG method by swapping out the derivative operator D.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"plot(xguide=L\"x\", yguide=L\"u\")\nplot!(evaluate_coefficients(sol[1], D), label=L\"u_0\")\nplot!(evaluate_coefficients(sol[end], D), label=L\"u_\\mathrm{FD}\")\n\n# CGSEM using polynomials of degree 3, i.e. 4 nodes per element, and 30 elements\nD_CGSEM = couple_continuously(\n            legendre_derivative_operator(xmin=-1.0, xmax=1.0, N=4),\n            UniformMesh1D(xmin=xmin, xmax=xmax, Nx=30))\node_CGSEM = ODEProblem(rhs!, compute_coefficients(u0_func, D_CGSEM), tspan, D_CGSEM)\nsol_CGSEM = solve(ode_CGSEM, Tsit5(), save_everystep=false)\nplot!(evaluate_coefficients(sol_CGSEM[end], D_CGSEM), label=L\"u_\\mathrm{CG}\")\n\n# DGSEM using polynomials of degree 3, i.e. 4 nodes per element, and 30 elements\n# which are coupled using upwind fluxes\nD_DGSEM = couple_discontinuously(\n            legendre_derivative_operator(xmin=-1.0, xmax=1.0, N=4),\n            UniformMesh1D(xmin=xmin, xmax=xmax, Nx=30),\n            Val(:minus))\node_DGSEM = ODEProblem(rhs!, compute_coefficients(u0_func, D_DGSEM), tspan, D_DGSEM)\nsol_DGSEM = solve(ode_DGSEM, Tsit5(), save_everystep=false)\nplot!(evaluate_coefficients(sol_DGSEM[end], D_DGSEM), label=L\"u_\\mathrm{DG}\")\n\nsavefig(\"example_linear_advection_Galerkin.png\");","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"(Image: )","category":"page"},{"location":"tutorials/advection_diffusion/#Linear-advection-diffusion-equation-with-periodic-boundary-conditions","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"","category":"section"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"Let's consider the linear advection diffusion equation","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"beginaligned\n    partial_t u(tx) + a partial_x u(tx) = varepsilon partial_x^2 u(tx)  t in (0T) x in (x_min x_max) \n    u(0x) = u_0(x)  x in (x_min x_max) \nendaligned","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"with periodic boundary conditions. Here, a is the constant advection velocity and ε > 0 is the constant diffusion coefficient.","category":"page"},{"location":"tutorials/advection_diffusion/#Basic-example-using-finite-difference-SBP-operators","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Basic example using finite difference SBP operators","text":"","category":"section"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"Let's create an appropriate discretization of this equation step by step. At first, we load packages that we will use in this example.","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"using SummationByPartsOperators, OrdinaryDiffEq\nusing LaTeXStrings; using Plots: Plots, plot, plot!, savefig","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"Next, we specify the initial data as Julia function as well as the spatial domain and the time span.","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"xmin, xmax = -1.0, 1.0\nu0_func(x) = sinpi(x)\ntspan = (0., 10.0)","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"Next, we implement the semidiscretization using the interface of OrdinaryDiffEq.jl which is part of DifferentialEquations.jl.","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"function advection_diffusion!(du, u, params, t)\n    # In-place version of du = -a * D1 * u\n    mul!(du, params.D1, u, -params.a)\n    # In-place version of du = du + ε * D2 * u\n    mul!(du, params.D2, u, params.ε, true)\nend","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"Next, we choose first- and second-derivative SBP operators D1, D2, evaluate the initial data on the grid, and set up the semidiscretization as an ODE problem.","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"N = 101 # number of grid points\nD1 = periodic_derivative_operator(derivative_order=1, accuracy_order=4,\n                                  xmin=xmin, xmax=xmax, N=N)\nD2 = periodic_derivative_operator(derivative_order=2, accuracy_order=4,\n                                  xmin=xmin, xmax=xmax, N=N)\nu0 = u0_func.(grid(D1))\nparams = (D1=D1, D2=D2, a=1.0, ε=0.03)\node = ODEProblem(advection_diffusion!, u0, tspan, params);","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"Finally, we can solve the ODE using an explicit Runge-Kutta method with adaptive time stepping.","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"sol = solve(ode, Tsit5(), saveat=range(first(tspan), stop=last(tspan), length=200));\n\nplot(xguide=L\"x\", yguide=L\"u\")\nplot!(evaluate_coefficients(sol[1], D1), label=L\"u_0\")\nplot!(evaluate_coefficients(sol[end], D1), label=L\"u_\\mathrm{numerical}\")\nsavefig(\"example_advection_diffusion.png\");","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"(Image: )","category":"page"},{"location":"tutorials/advection_diffusion/#Advanced-visualization","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Advanced visualization","text":"","category":"section"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"Let's create an animation of the numerical solution.","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"using Printf; using Plots: Animation, frame, gif\n\nlet anim = Animation()\n    idx = 1\n    x, u = evaluate_coefficients(sol[idx], D1)\n    fig = plot(x, u, xguide=L\"x\", yguide=L\"u\", xlim=extrema(x), ylim=(-1.05, 1.05),\n              label=\"\", title=@sprintf(\"\\$t = %6.2f \\$\", sol.t[idx]))\n    for idx in 1:length(sol.t)\n        fig[1] = x, sol.u[idx]\n        plot!(title=@sprintf(\"\\$t = %6.2f \\$\", sol.t[idx]))\n        frame(anim)\n    end\n    gif(anim, \"example_advection_diffusion.gif\")\nend","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"(Image: example_advection_diffusion_animation)","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Here are some simple benchmarks. Take them with a grain of salt since they run on virtual machines in the cloud to generate the documentation automatically.","category":"page"},{"location":"benchmarks/#First-derivative-operators","page":"Benchmarks","title":"First-derivative operators","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BenchmarkTools\nusing SummationByPartsOperators\nusing BandedMatrices, LinearAlgebra, Random, SparseArrays\n\nBLAS.set_num_threads(1) # make sure that BLAS is serial to be fair\n\nT = Float64\nxmin, xmax = T(0), T(1)\nN = 10^3\nder_order = 1 # first-derivative operators\nacc_order = 6 # the (interior) order of accuracy is six\nsource = MattssonSvärdShoeybi2008()\n\nD_periodic_serial  = periodic_derivative_operator(der_order, acc_order, xmin, xmax, N+1, Val{:serial}())\nD_nonperiodic_serial  = derivative_operator(source, der_order, acc_order, xmin, xmax, N, Val{:serial}())\nD_nonperiodic_sparse  = sparse(D_nonperiodic_serial)\nD_nonperiodic_banded  = BandedMatrix(D_nonperiodic_serial)\n\nRandom.seed!(12345)\nu = randn(T, N)\ndest = similar(u)\n\nfunction doit(D, text, dest, u)\n  println(text)\n  sleep(0.1)\n  show(stdout, MIME\"text/plain\"(), @benchmark mul!($dest, $D, $u))\n  println()\nend\n\ndoit(D_periodic_serial, \"D_periodic_serial:\", dest, u)\ndoit(D_nonperiodic_serial, \"D_nonperiodic_serial:\", dest, u)\ndoit(D_nonperiodic_sparse, \"D_nonperiodic_sparse:\", dest, u)\ndoit(D_nonperiodic_banded, \"D_nonperiodic_banded:\", dest, u)","category":"page"},{"location":"benchmarks/#Dissipation-operators","page":"Benchmarks","title":"Dissipation operators","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BenchmarkTools\nusing SummationByPartsOperators\nusing BandedMatrices, LinearAlgebra, Random, SparseArrays\n\nBLAS.set_num_threads(1) # make sure that BLAS is serial to be fair\n\nT = Float64\nxmin, xmax = T(0), T(1)\nN = 10^3\nacc_order = 8\nsource_D = MattssonSvärdShoeybi2008()\nsource_Di = MattssonSvärdNordström2004()\n\nD_serial  = derivative_operator(source_D, 1, acc_order, xmin, xmax, N, Val{:serial}())\n\nDi_serial  = dissipation_operator(source_Di, D_serial)\nDi_sparse  = sparse(Di_serial)\nDi_full    = Matrix(Di_serial)\n\nRandom.seed!(12345)\nu = randn(T, N)\ndest = similar(u)\n\nfunction doit(D, text, dest, u)\n  println(text)\n  sleep(0.1)\n  show(stdout, MIME\"text/plain\"(), @benchmark mul!($dest, $D, $u))\n  println()\nend\n\ndoit(D_serial, \"D_serial:\", dest, u)\ndoit(Di_serial, \"Di_serial:\", dest, u)\ndoit(Di_sparse, \"Di_sparse:\", dest, u)\ndoit(Di_full, \"Di_full:\", dest, u)","category":"page"},{"location":"api_reference/#SummationByPartsOperators.jl-API","page":"API reference","title":"SummationByPartsOperators.jl API","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"CurrentModule = SummationByPartsOperators","category":"page"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"Modules = [SummationByPartsOperators]","category":"page"},{"location":"api_reference/#SummationByPartsOperators.SummationByPartsOperators","page":"API reference","title":"SummationByPartsOperators.SummationByPartsOperators","text":"SummationByPartsOperators.jl is a Julia library of summation-by-parts (SBP) operators, which are discrete derivative operators developed to get provably stable semidiscretizations, paying special attention to boundary conditions. Discretizations included in this framework are finite difference, Fourier pseudospectral, continuous Galerkin, and discontinuous Galerkin methods. The main aim of SummationByPartsOperators.jl is to be useful for researchers and students to learn the basic concepts by providing a unified framework of all of these seemingly different discretizations. At the same time, the implementation is optimized to achieve good performance without sacrificing flexibility.\n\nCheck out the documentation for further information. Some noticable functions to start with are derivative_operator, legendre_derivative_operator, periodic_derivative_operator, fourier_derivative_operator, dissipation_operator, and grid.\n\nIf you use this package for your research, please cite it using\n\n@misc{ranocha2021sbp,\n  title={{SummationByPartsOperators.jl}: {A} {J}ulia library of provably stable\n         semidiscretization techniques with mimetic properties},\n  author={Ranocha, Hendrik},\n  year={2021},\n  howpublished={\\url{https://github.com/ranocha/SummationByPartsOperators.jl},\n  doi={10.5281/zenodo.4773575}\n}\n\n\n\n\n\n","category":"module"},{"location":"api_reference/#SummationByPartsOperators.BeljaddLeFlochMishraParés2017","page":"API reference","title":"SummationByPartsOperators.BeljaddLeFlochMishraParés2017","text":"BeljaddLeFlochMishraParés2017()\n\nCoefficients of the periodic operators given in   Beljadid, LeFloch, Mishra, Parés (2017)   Schemes with Well-Controlled Dissipation. Hyperbolic Systems in     Nonconservative Form.   Communications in Computational Physics 21.4, pp. 913-946.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.BurgersNonperiodicSemidiscretisation","page":"API reference","title":"SummationByPartsOperators.BurgersNonperiodicSemidiscretisation","text":"BurgersNonperiodicSemidiscretisation(D, Di, split_form, left_bc, right_bc)\n\nA semidiscretisation of Burgers' equation     partial_t u(tx) + partial_x fracu(tx)^22 = 0 with boundary conditions left_bc(t), right_bc(t).\n\nD is a first-derivative SBP operator, Di an associated dissipation operator or nothing, and split_form::Union{Val(true), Val(false)} determines whether the canonical split form or the conservative form is used.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.BurgersPeriodicSemidiscretisation","page":"API reference","title":"SummationByPartsOperators.BurgersPeriodicSemidiscretisation","text":"BurgersPeriodicSemidiscretisation(D, Di, split_form)\n\nA semidiscretisation of Burgers' equation     partial_t u(tx) + partial_x fracu(tx)^22 = 0 with periodic boundary conditions.\n\nD is a first-derivative SBP operator, Di an associated dissipation operator or nothing, and split_form::Union{Val(true), Val(false)} determines whether the canonical split form or the conservative form is used.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.ConstantFilter","page":"API reference","title":"SummationByPartsOperators.ConstantFilter","text":"ConstantFilter\n\nRepresents the action of a modal filter on values in a nodal basis with fixed strength.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.ConstantFilter-Union{Tuple{T}, Tuple{FourierDerivativeOperator{T, Grid, RFFT, BRFFT} where {Grid, RFFT, BRFFT}, Any}} where T","page":"API reference","title":"SummationByPartsOperators.ConstantFilter","text":"ConstantFilter(D::FourierDerivativeOperator, filter)\n\nCreate a modal filter with constant parameters adapted to the Fourier derivative operator D with parameters given by the filter function filter.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.ConstantFilter-Union{Tuple{T}, Tuple{LegendreDerivativeOperator{T}, Any}, Tuple{LegendreDerivativeOperator{T}, Any, Any}} where T","page":"API reference","title":"SummationByPartsOperators.ConstantFilter","text":"ConstantFilter(D::LegendreDerivativeOperator, filter, TmpEltype=T)\n\nCreate a modal filter with constant parameters adapted to the Legendre derivative operator D with parameters given by the filter function filter.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.CubicNonperiodicSemidiscretisation","page":"API reference","title":"SummationByPartsOperators.CubicNonperiodicSemidiscretisation","text":"CubicNonperiodicSemidiscretisation(D, Di, split_form, left_bc, right_bc)\n\nA semidiscretisation of the cubic conservation law     partial_t u(tx) + partial_x u(tx)^3 = 0 with nonperiodic boundary conditions left_bc(t), right_bc(t).\n\nD is a first-derivative SBP operator, Di an associated dissipation operator or nothing, and split_form::Union{Val(true), Val(false)} determines whether the canonical split form or the conservative form is used.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.CubicPeriodicSemidiscretisation","page":"API reference","title":"SummationByPartsOperators.CubicPeriodicSemidiscretisation","text":"CubicPeriodicSemidiscretisation(D, Di, split_form)\n\nA semidiscretisation of the cubic conservation law     partial_t u(tx) + partial_x u(tx)^3 = 0 with periodic boundary conditions.\n\nD is a first-derivative SBP operator, Di an associated dissipation operator or nothing, and split_form::Union{Val(true), Val(false)} determines whether the canonical split form or the conservative form is used.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.DerivativeCoefficientRow","page":"API reference","title":"SummationByPartsOperators.DerivativeCoefficientRow","text":"DerivativeCoefficientRow{T,Start,Length}\n\nA struct representing a row in the boundary block of an SBP derivative operator with scalar type T.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.DerivativeCoefficients","page":"API reference","title":"SummationByPartsOperators.DerivativeCoefficients","text":"DerivativeCoefficients\n\nThe coefficients of a derivative operator on a nonperiodic grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.DerivativeOperator","page":"API reference","title":"SummationByPartsOperators.DerivativeOperator","text":"DerivativeOperator\n\nA derivative operator on a nonperiodic finite difference grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.DissipationOperator","page":"API reference","title":"SummationByPartsOperators.DissipationOperator","text":"DissipationOperator\n\nA dissipation operator on a nonperiodic finite difference grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.ExponentialFilter","page":"API reference","title":"SummationByPartsOperators.ExponentialFilter","text":"ExponentialFilter\n\nRepresents the exponential filter function σ(η) = exp(-α*η^p).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.FactorisationWrapper","page":"API reference","title":"SummationByPartsOperators.FactorisationWrapper","text":"FactorisationWrapper\n\nA small wrapper around a a factorisation fact, allowing to represent multiplication by the inverse of fact.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.Fornberg1998","page":"API reference","title":"SummationByPartsOperators.Fornberg1998","text":"Fornberg1998()\n\nCoefficients of the periodic operators given in   Fornberg (1998)   Calculation of Weights in Finite Difference Formulas.   SIAM Rev. 40.3, pp. 685-691.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.FourierConstantViscosity","page":"API reference","title":"SummationByPartsOperators.FourierConstantViscosity","text":"FourierConstantViscosity\n\nFourier viscosity operator with constant coefficients for the periodic 1st derivative Fourier operator.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.FourierDerivativeOperator","page":"API reference","title":"SummationByPartsOperators.FourierDerivativeOperator","text":"FourierDerivativeOperator{T}\n\nA derivative operator on a periodic grid with real scalar type T computing the first derivative using a spectral Fourier expansion via real discrete Fourier transforms.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.FourierDerivativeOperator-Union{Tuple{T}, Tuple{T, T, Integer}} where T<:Real","page":"API reference","title":"SummationByPartsOperators.FourierDerivativeOperator","text":"FourierDerivativeOperator(xmin::T, xmax::T, N::Integer) where {T<:Real}\n\nConstruct the FourierDerivativeOperator on a uniform grid between xmin and xmax using N nodes and N÷2+1 complex Fourier modes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.FourierDerivativeOperator2D","page":"API reference","title":"SummationByPartsOperators.FourierDerivativeOperator2D","text":"FourierDerivativeOperator2D{T<:Real}\n\nA derivative operator on a two-dimensional periodic grid with scalar type T computing the first derivatives using a spectral Fourier expansion via real discrete Fourier transforms.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.FourierDerivativeOperator2D-Union{Tuple{T}, Tuple{T, T, Int64, T, T, Int64}} where T<:Real","page":"API reference","title":"SummationByPartsOperators.FourierDerivativeOperator2D","text":"FourierDerivativeOperator2D(xmin, xmax, Nx, ymin, ymax, Ny)\n\nConstruct the FourierDerivativeOperator on a uniform grid between xmin and xmax using Nx nodes and ymin and ymax using Ny nodes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.Holoborodko2008","page":"API reference","title":"SummationByPartsOperators.Holoborodko2008","text":"Holoborodko2008()\n\nCoefficients of the periodic operators given in   Holoborodko (2008)   Smooth Noise Robust Differentiators.   http://www.holoborodko.com/pavel/numerical-methods/numerical-derivative/smooth-low-noise-differentiators/\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.LegendreDerivativeOperator","page":"API reference","title":"SummationByPartsOperators.LegendreDerivativeOperator","text":"LegendreDerivativeOperator{T<:Real}\n\nA derivative operator on a nonperiodic Lobatto-Legendre grid with scalar type T computing the first derivative using a Legendre expansion.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.LegendreDerivativeOperator-Union{Tuple{T}, Tuple{T, T, Int64}} where T<:Real","page":"API reference","title":"SummationByPartsOperators.LegendreDerivativeOperator","text":"LegendreDerivativeOperator(xmin::T, xmax::T, N::Int) where {T<:Real}\n\nConstruct the LegendreDerivativeOperator on a uniform grid between xmin and xmax using N nodes and N-1 Legendre modes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.LegendreSecondDerivativeOperator","page":"API reference","title":"SummationByPartsOperators.LegendreSecondDerivativeOperator","text":"LegendreSecondDerivativeOperator{T<:Real}\n\nA derivative operator on a nonperiodic Lobatto-Legendre grid with scalar type T computing the second derivative using a Legendre expansion.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.MadayTadmor1989","page":"API reference","title":"SummationByPartsOperators.MadayTadmor1989","text":"MadayTadmor1989\n\nCoefficients of the Fourier spectral viscosity given in   Maday, Tadmor (1989)   Analysis of the Spectral Vanishing Viscosity Method for Periodic Conservation     Laws.   SIAM Journal on Numerical Analysis 26.4, pp. 854-870.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.Mattsson2012","page":"API reference","title":"SummationByPartsOperators.Mattsson2012","text":"Mattsson2012()\n\nCoefficients of the SBP operators given in   Mattsson (2012)   Summation by Parts Operators for Finite Difference Approximations of     Second-Derivatives with Variable Coefficients.   Journal of Scientific Computing 51, pp. 650-682.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.Mattsson2014","page":"API reference","title":"SummationByPartsOperators.Mattsson2014","text":"Mattsson2014()\n\nCoefficients of the SBP operators given in   Mattsson (2014)   Diagonal-norm summation by parts operators for fiite difference approximations     of third and fourth derivatives.   Journal of Computational Physics 274, pp. 432-454.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.Mattsson2017","page":"API reference","title":"SummationByPartsOperators.Mattsson2017","text":"Mattsson2017(version::Symbol)\n\nCoefficients of the upwind SBP operators given in   Mattsson (2017)   Diagonal-norm upwind SBP operators.   Journal of Computational Physics 335, pp. 283-310.\n\nYou can choose between the different versions :central, :plus, and :minus.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.MattssonAlmquistCarpenter2014Extended","page":"API reference","title":"SummationByPartsOperators.MattssonAlmquistCarpenter2014Extended","text":"MattssonAlmquistCarpenter2014Extended()\n\nCoefficients of the extended SBP operators given in   Mattsson, Almquist, Carpenter (2014)   Optimal diagonal-norm SBP operators.   Journal of Computational Physics 264, pp. 91-111.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.MattssonAlmquistCarpenter2014Optimal","page":"API reference","title":"SummationByPartsOperators.MattssonAlmquistCarpenter2014Optimal","text":"MattssonAlmquistCarpenter2014Optimal()\n\nCoefficients of the optimal SBP operators with nonuniform grid given in   Mattsson, Almquist, Carpenter (2014)   Optimal diagonal-norm SBP operators.   Journal of Computational Physics 264, pp. 91-111.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.MattssonAlmquistVanDerWeide2018Accurate","page":"API reference","title":"SummationByPartsOperators.MattssonAlmquistVanDerWeide2018Accurate","text":"MattssonAlmquistVanDerWeide2018Accurate()\n\nCoefficients of the optimized SBP operators with nonuniform grid given in   Mattsson, Almquist, van der Weide (2018)   Boundary optimized diagonal-norm SBP operators.   Journal of Computational Physics 374, pp. 1261-1266.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.MattssonAlmquistVanDerWeide2018Minimal","page":"API reference","title":"SummationByPartsOperators.MattssonAlmquistVanDerWeide2018Minimal","text":"MattssonAlmquistVanDerWeide2018Minimal()\n\nCoefficients of the optimized SBP operators with nonuniform grid given in   Mattsson, Almquist, van der Weide (2018)   Boundary optimized diagonal-norm SBP operators.   Journal of Computational Physics 374, pp. 1261-1266.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.MattssonNordström2004","page":"API reference","title":"SummationByPartsOperators.MattssonNordström2004","text":"MattssonNordström2004()\n\nCoefficients of the SBP operators given in   Mattsson, Nordström (2004)   Summation by parts operators for finite difference approximations of second     derivatives.   Journal of Computational Physics 199, pp. 503-540.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.MattssonSvärdNordström2004","page":"API reference","title":"SummationByPartsOperators.MattssonSvärdNordström2004","text":"MattssonSvärdNordström2004()\n\nCoefficients of the SBP operators given in   Mattsson, Svärd, Nordström (2004)   Stable and Accurate Artificial Dissipation.   Journal of Scientific Computing 21.1, pp. 57-79.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.MattssonSvärdShoeybi2008","page":"API reference","title":"SummationByPartsOperators.MattssonSvärdShoeybi2008","text":"MattssonSvärdShoeybi2008()\n\nCoefficients of the SBP operators given in   Mattsson, Svärd, Shoeybi (2008)   Stable and accurate schemes for the compressible Navier-Stokes equations.   Journal of Computational Physics 227, pp. 2293-2316.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.PeriodicDerivativeCoefficients","page":"API reference","title":"SummationByPartsOperators.PeriodicDerivativeCoefficients","text":"PeriodicDerivativeCoefficients\n\nThe coefficients of a derivative operator on a periodic grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.PeriodicDerivativeOperator","page":"API reference","title":"SummationByPartsOperators.PeriodicDerivativeOperator","text":"PeriodicDerivativeOperator\n\nA derivative operator on a uniform periodic grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.PeriodicDissipationOperator","page":"API reference","title":"SummationByPartsOperators.PeriodicDissipationOperator","text":"PeriodicDissipationOperator\n\nA dissipation operator on a periodic finite difference grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.QuarticNonconvexPeriodicSemidiscretisation","page":"API reference","title":"SummationByPartsOperators.QuarticNonconvexPeriodicSemidiscretisation","text":"QuarticNonconvexPeriodicSemidiscretisation(D, Di, split_form)\n\nA semidiscretisation of the quartic nonconvex conservation law     partial_t u(tx) + partial_x ( u(tx)^4 - 10 u(tx)^2 + 3 u(tx) ) = 0 with periodic boundary conditions.\n\nD is a first-derivative SBP operator, Di an associated dissipation operator or nothing, and split_form::Union{Val(true), Val(false)} determines whether the canonical split form or the conservative form is used.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.SourceOfCoefficients","page":"API reference","title":"SummationByPartsOperators.SourceOfCoefficients","text":"SourceOfCoefficients\n\nAll sources of coefficients (articles) are subtypes of this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.SumOfDerivativeOperators","page":"API reference","title":"SummationByPartsOperators.SumOfDerivativeOperators","text":"SumOfDerivativeOperators\n\nSum several derivative operators lazily.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.Tadmor1989","page":"API reference","title":"SummationByPartsOperators.Tadmor1989","text":"Tadmor1989\n\nCoefficients of the Fourier spectral viscosity given in   Tadmor (1989)   Convergence of Spectral Methods for Nonlinear Conservation Laws.   SIAM Journal on Numerical Analysis 26.1, pp. 30-44.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.Tadmor1993","page":"API reference","title":"SummationByPartsOperators.Tadmor1993","text":"Tadmor1993\n\nCoefficients of the Fourier super spectral viscosity given in   Tadmor (1993)   Super Viscosity and Spectral Approximations of Nonlinear Conservation Laws.   Numerical Methods for Fluid Dynamics IV, pp. 69-82.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.TadmorWaagan2012Convergent","page":"API reference","title":"SummationByPartsOperators.TadmorWaagan2012Convergent","text":"TadmorWaagan2012Convergent\n\nCoefficients of the Fourier spectral viscosity given in   Tadmor, Waagan (2012)   Adaptive Spectral Viscosity for Hyperbolic Conservation Laws.   SIAM Journal on Scientific Computing 34.2, pp. A993-A1009. See also   Schochet (1990)   The Rate of Convergence of Spectral-Viscosity Methods for Periodic Scalar     Conservation Laws.   SIAM Journal on Numerical Analysis 27.5, pp. 1142-1159.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.TadmorWaagan2012Standard","page":"API reference","title":"SummationByPartsOperators.TadmorWaagan2012Standard","text":"TadmorWaagan2012Standard\n\nCoefficients of the Fourier spectral viscosity given in   Tadmor, Waagan (2012)   Adaptive Spectral Viscosity for Hyperbolic Conservation Laws.   SIAM Journal on Scientific Computing 34.2, pp. A993-A1009.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.UniformMesh1D","page":"API reference","title":"SummationByPartsOperators.UniformMesh1D","text":"UniformMesh1D(xmin::Real, xmax::Real, Nx::Integer)\nUniformMesh1D(; xmin::Real, xmax::Real, Nx::Integer)\n\nA uniform mesh in one space dimension of Nx cells between xmin and xmax.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.UniformPeriodicMesh1D","page":"API reference","title":"SummationByPartsOperators.UniformPeriodicMesh1D","text":"UniformPeriodicMesh1D(xmin::Real, xmax::Real, Nx::Integer)\nUniformPeriodicMesh1D(; xmin::Real, xmax::Real, Nx::Integer)\n\nA uniform periodic mesh in one space dimension of Nx cells between xmin and xmax.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.VarCoefDerivativeCoefficients","page":"API reference","title":"SummationByPartsOperators.VarCoefDerivativeCoefficients","text":"VarCoefDerivativeCoefficients\n\nThe coefficients of a variable coefficient derivative operator on a nonperiodic grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.VarCoefDerivativeOperator","page":"API reference","title":"SummationByPartsOperators.VarCoefDerivativeOperator","text":"VarCoefDerivativeOperator\n\nA dissipation operator on a nonperiodic finite difference grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.VariableLinearAdvectionNonperiodicSemidiscretisation","page":"API reference","title":"SummationByPartsOperators.VariableLinearAdvectionNonperiodicSemidiscretisation","text":"VariableLinearAdvectionNonperiodicSemidiscretisation(D, Di, a, split_form,\n                                                     left_bc, right_bc)\n\nA semidiscretisation of the linear advection equation     partial_t u(tx) + partial_x ( a(x) u(tx) ) = 0 with boundary conditions left_bc(t), right_bc(t).\n\nD is an SBP derivative operator, Di an associated dissipation operator or nothing, a(x) the variable coefficient, and split_form::Union{Val(false), Val(true)} determines whether the canonical split form or the conservative form should be used.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.WaveEquationNonperiodicSemidiscretisation","page":"API reference","title":"SummationByPartsOperators.WaveEquationNonperiodicSemidiscretisation","text":"WaveEquationNonperiodicSemidiscretisation(D, left_bc, right_bc)\n\nA semidiscretisation of the linear wave equation     partial_t^2 u(tx) = partial_x^2 u(tx).\n\nD is assumed to be a second-derivative SBP operator and the boundary conditions can be Val(:HomogeneousNeumann), Val(:HomogeneousDirichlet), or Val(:NonReflecting).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#LinearAlgebra.mul!-Tuple{AbstractVector{T} where T, DerivativeOperator, AbstractVector{T} where T, Any, Any}","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(dest::AbstractVector, D::DerivativeOperator, u::AbstractVector, α, β)\n\nCompute α*D*u + β*dest and store the result in dest.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#LinearAlgebra.mul!-Tuple{AbstractVector{T} where T, DerivativeOperator, AbstractVector{T} where T, Any}","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(dest::AbstractVector, D::DerivativeOperator, u::AbstractVector, α)\n\nCompute α*D*u and store the result in dest.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#LinearAlgebra.mul!-Tuple{AbstractVector{T} where T, DissipationOperator, AbstractVector{T} where T, Any, Any}","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(dest::AbstractVector, D::DissipationOperator, u::AbstractVector, α, β)\n\nCompute α*D*u + β*dest and store the result in dest.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#LinearAlgebra.mul!-Tuple{AbstractVector{T} where T, DissipationOperator, AbstractVector{T} where T, Any}","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(dest::AbstractVector, D::DissipationOperator, u::AbstractVector, α)\n\nCompute α*D*u and store the result in dest.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#LinearAlgebra.mul!-Tuple{AbstractVector{T} where T, PeriodicDerivativeOperator, AbstractVector{T} where T, Any, Any}","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(dest::AbstractVector, D::PeriodicDerivativeOperator, u::AbstractVector, α, β)\n\nCompute α*D*u + β*dest and store the result in dest.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#LinearAlgebra.mul!-Tuple{AbstractVector{T} where T, PeriodicDerivativeOperator, AbstractVector{T} where T, Any}","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(dest::AbstractVector, D::PeriodicDerivativeOperator, u::AbstractVector, α)\n\nCompute α*D*u and store the result in dest.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#LinearAlgebra.mul!-Tuple{AbstractVector{T} where T, PeriodicDissipationOperator, AbstractVector{T} where T, Any, Any}","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(dest::AbstractVector, D::PeriodicDissipationOperator, u::AbstractVector, α, β)\n\nCompute α*D*u + β*dest and store the result in dest.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#LinearAlgebra.mul!-Tuple{AbstractVector{T} where T, PeriodicDissipationOperator, AbstractVector{T} where T, Any}","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(dest::AbstractVector, D::PeriodicDissipationOperator, u::AbstractVector, α)\n\nCompute α*D*u and store the result in dest.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#LinearAlgebra.mul!-Tuple{AbstractVector{T} where T, SummationByPartsOperators.DerivativeCoefficients, AbstractVector{T} where T, Any, Any}","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(dest::AbstractVector, coefficients::DerivativeCoefficients, u::AbstractVector, α, β)\n\nCompute α*D*u + β*dest and store the result in dest.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#LinearAlgebra.mul!-Tuple{AbstractVector{T} where T, SummationByPartsOperators.DerivativeCoefficients, AbstractVector{T} where T, Any}","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(dest::AbstractVector, coefficients::DerivativeCoefficients, u::AbstractVector, α)\n\nCompute α*D*u and store the result in dest.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#LinearAlgebra.mul!-Tuple{AbstractVector{T} where T, SummationByPartsOperators.VarCoefDerivativeCoefficients, AbstractVector{T} where T, AbstractVector{T} where T, Any, Any}","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(dest::AbstractVector, coefficients::VarCoefDerivativeCoefficients, u::AbstractVector, b::AbstractVector, α, β)\n\nCompute α*D*u + β*dest using the coefficients b and store the result in dest.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#LinearAlgebra.mul!-Tuple{AbstractVector{T} where T, SummationByPartsOperators.VarCoefDerivativeCoefficients, AbstractVector{T} where T, AbstractVector{T} where T, Any}","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(dest::AbstractVector, coefficients::VarCoefDerivativeCoefficients, u::AbstractVector, b::AbstractVector, α)\n\nCompute α*D*u using the coefficients b and store the result in dest.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#LinearAlgebra.mul!-Tuple{AbstractVector{T} where T, VarCoefDerivativeOperator, AbstractVector{T} where T, Any, Any}","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(dest::AbstractVector, D::VarCoefDerivativeOperator, u::AbstractVector, α, β)\n\nCompute α*D*u + β*dest and store the result in dest.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#LinearAlgebra.mul!-Tuple{AbstractVector{T} where T, VarCoefDerivativeOperator, AbstractVector{T} where T, Any}","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(dest::AbstractVector, D::VarCoefDerivativeOperator, u::AbstractVector, α)\n\nCompute α*D*u and store the result in dest.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#LinearAlgebra.mul!-Union{Tuple{UpperOffset}, Tuple{LowerOffset}, Tuple{T}, Tuple{AbstractVector{T} where T, SummationByPartsOperators.PeriodicDerivativeCoefficients{T, LowerOffset, UpperOffset, Parallel, SourceOfCoefficients} where {Parallel, SourceOfCoefficients}, AbstractVector{T} where T, Any, Any}} where {T, LowerOffset, UpperOffset}","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(dest::AbstractVector, coefficients::PeriodicDerivativeCoefficients, u::AbstractVector, α, β)\n\nCompute α*D*u + β*dest and store the result in dest.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#LinearAlgebra.mul!-Union{Tuple{UpperOffset}, Tuple{LowerOffset}, Tuple{T}, Tuple{AbstractVector{T} where T, SummationByPartsOperators.PeriodicDerivativeCoefficients{T, LowerOffset, UpperOffset, Parallel, SourceOfCoefficients} where {Parallel, SourceOfCoefficients}, AbstractVector{T} where T, Any}} where {T, LowerOffset, UpperOffset}","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(dest::AbstractVector, coefficients::PeriodicDerivativeCoefficients, u::AbstractVector, α)\n\nCompute α*D*u and store the result in dest.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#PolynomialBases.compute_coefficients!-Tuple{Any, Any, SummationByPartsOperators.AbstractDerivativeOperator}","page":"API reference","title":"PolynomialBases.compute_coefficients!","text":"compute_coefficients!(uval, u, D::AbstractDerivativeOperator)\n\nCompute the nodal values of the function u at the grid associated to the derivative operator D and stores the result in uval.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#PolynomialBases.compute_coefficients-Tuple{Any, SummationByPartsOperators.AbstractDerivativeOperator}","page":"API reference","title":"PolynomialBases.compute_coefficients","text":"compute_coefficients(u, D::AbstractDerivativeOperator)\n\nCompute the nodal values of the function u at the grid associated to the derivative operator D.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#PolynomialBases.evaluate_coefficients!-Tuple{Any, Any, Any, SummationByPartsOperators.AbstractDerivativeOperator}","page":"API reference","title":"PolynomialBases.evaluate_coefficients!","text":"evaluate_coefficients!(xplot, uplot, u, D::AbstractDerivativeOperator)\n\nEvaluates the nodal coefficients u at a grid associated to the derivative operator D and stores the result in xplot, uplot. Returns xplot, uplot, where xplot contains the nodes and uplot the corresponding values of u.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#PolynomialBases.evaluate_coefficients-Tuple{Any, SummationByPartsOperators.AbstractDerivativeOperator}","page":"API reference","title":"PolynomialBases.evaluate_coefficients","text":"evaluate_coefficients(u, D::AbstractDerivativeOperator)\n\nEvaluates the nodal coefficients u at a grid associated to the derivative operator D. Returns xplot, uplot, where xplot contains the nodes and uplot the corresponding values of u.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#PolynomialBases.integrate-Tuple{Any, AbstractVector{T} where T, DerivativeOperator}","page":"API reference","title":"PolynomialBases.integrate","text":"integrate(func, u, D::DerivativeOperator)\n\nMap the function func to the coefficients u and integrate with respect to the quadrature rule associated with the SBP derivative operator D.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#PolynomialBases.integrate-Tuple{Any, AbstractVector{T} where T, PeriodicDerivativeOperator}","page":"API reference","title":"PolynomialBases.integrate","text":"integrate(func, u, D::PeriodicDerivativeOperator)\n\nMap the function func to the coefficients u and integrate with respect to the quadrature rule associated with the periodic derivative operator D.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#PolynomialBases.integrate-Tuple{Any, AbstractVector{T} where T, SummationByPartsOperators.AbstractPeriodicDerivativeOperator}","page":"API reference","title":"PolynomialBases.integrate","text":"integrate(func, u, D::AbstractPeriodicDerivativeOperator)\n\nMap the function func to the coefficients u and integrate with respect to the quadrature rule associated with the derivative operator D.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.accuracy_order","page":"API reference","title":"SummationByPartsOperators.accuracy_order","text":"accuracy_order(D)\n\nReturn the order of accuracy of a derivative operator D. For SBP finite difference operators, this refers to the interior order of accuracy.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.add_transpose_derivative_left!-Union{Tuple{N}, Tuple{AbstractVector{T} where T, DerivativeOperator, Val{N}, Any}} where N","page":"API reference","title":"SummationByPartsOperators.add_transpose_derivative_left!","text":"add_transpose_derivative_left!(u, D::DerivativeOperator, der_order::Val{N}, α)\n\nAdd α times the transposed N-th derivative functional to the grid function u at the left boundary of the grid.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.add_transpose_derivative_right!-Union{Tuple{N}, Tuple{AbstractVector{T} where T, DerivativeOperator, Val{N}, Any}} where N","page":"API reference","title":"SummationByPartsOperators.add_transpose_derivative_right!","text":"add_transpose_derivative_right!(u, D::DerivativeOperator, der_order::Val{N}, α)\n\nAdd α times the transposed N-th derivative functional to the grid function u at the right boundary of the grid.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.derivative_left-Tuple{SummationByPartsOperators.AbstractNonperiodicDerivativeOperator, Any}","page":"API reference","title":"SummationByPartsOperators.derivative_left","text":"derivative_left(D::AbstractNonperiodicDerivativeOperator, der_order)\n\nGet a representation of the linear functional evaluation the Nth derivative at the left boundary node as (dense) vector.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.derivative_left-Union{Tuple{N}, Tuple{DerivativeOperator, Any, Val{N}}} where N","page":"API reference","title":"SummationByPartsOperators.derivative_left","text":"derivative_left(D::DerivativeOperator, u, der_order::Val{N})\n\nCompute the N-th derivative of the function given by the coefficients u at the left boundary of the grid.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.derivative_operator","page":"API reference","title":"SummationByPartsOperators.derivative_operator","text":"derivative_operator(source_of_coefficients,\n                    derivative_order, accuracy_order,\n                    xmin, xmax, N, parallel=Val{:serial}())\nderivative_operator(source_of_coefficients;\n                    derivative_order, accuracy_order,\n                    xmin, xmax, N, parallel=Val{:serial}())\n\nCreate a DerivativeOperator approximating the derivative_order-th derivative on a grid between xmin and xmax with N grid points up to order of accuracy accuracy_order. with coefficients given by source_of_coefficients. The evaluation of the derivative can be parallised using threads by chosing parallel=Val{:threads}()).\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.derivative_order","page":"API reference","title":"SummationByPartsOperators.derivative_order","text":"derivative_order(D)\n\nReturn the order of the derivative associated to the derivative operator D. For example, it will return 1 for a first-derivative SBP operator.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.derivative_right-Tuple{SummationByPartsOperators.AbstractNonperiodicDerivativeOperator, Any}","page":"API reference","title":"SummationByPartsOperators.derivative_right","text":"derivative_right(D::AbstractNonperiodicDerivativeOperator, der_order)\n\nGet a representation of the linear functional evaluation the Nth derivative at the right boundary node as (dense) vector.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.derivative_right-Union{Tuple{N}, Tuple{DerivativeOperator, Any, Val{N}}} where N","page":"API reference","title":"SummationByPartsOperators.derivative_right","text":"derivative_right(D::DerivativeOperator, u, der_order::Val{N})\n\nCompute the N-th derivative of the function given by the coefficients u at the right boundary of the grid.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.dissipation_operator","page":"API reference","title":"SummationByPartsOperators.dissipation_operator","text":"dissipation_operator(source_of_coefficients, order, xmin, xmax, N,\n                     left_weights, right_weights, parallel=Val{:serial}())\n\nCreate a negative semidefinite DissipationOperator using undivided differences approximating a weighted order-th derivative on a grid between xmin and xmax with N grid points up to order of accuracy 2 with coefficients given by source_of_coefficients. The norm matrix is given by left_weights and right_weights. The evaluation of the derivative can be parallised using threads by chosing parallel=Val{:threads}()).\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.dissipation_operator-Tuple{DerivativeOperator}","page":"API reference","title":"SummationByPartsOperators.dissipation_operator","text":"dissipation_operator(D::DerivativeOperator; kwargs...)\n\nCreate a negative semidefinite DissipationOperator using undivided differences approximating a weighted order-th derivative adapted to the derivative operator D. The evaluation of the derivative can be parallised using threads by chosing parallel=Val{:threads}()).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.dissipation_operator-Tuple{PeriodicDerivativeOperator}","page":"API reference","title":"SummationByPartsOperators.dissipation_operator","text":"dissipation_operator(D::PeriodicDerivativeOperator;\n                     strength=one(eltype(D)),\n                     order=accuracy_order(D),\n                     parallel=D.coefficients.parallel)\n\nCreate a negative semidefinite DissipationOperator using undivided differences approximating a order-th derivative with strength strength adapted to the derivative operator D. The evaluation of the derivative can be parallised using threads by chosing parallel=Val{:threads}()).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.dissipation_operator-Union{Tuple{T}, Tuple{Any, DerivativeOperator{T, LeftBoundary, RightBoundary, LeftBoundaryDerivatives, RightBoundaryDerivatives, LowerOffset, UpperOffset, LeftWidth, RightWidth, Parallel, SourceOfCoefficients, Grid} where {LeftBoundary, RightBoundary, LeftBoundaryDerivatives, RightBoundaryDerivatives, LowerOffset, UpperOffset, LeftWidth, RightWidth, Parallel, SourceOfCoefficients, Grid}}} where T","page":"API reference","title":"SummationByPartsOperators.dissipation_operator","text":"dissipation_operator(source_of_coefficients, D::DerivativeOperator{T};\n                     strength=one(T),\n                     order::Int=accuracy_order(D),\n                     parallel=D.coefficients.parallel)\n\nCreate a negative semidefinite DissipationOperator using undivided differences approximating a weighted order-th derivative adapted to the derivative operator D with coefficients given in source_of_coefficients. The evaluation of the derivative can be parallised using threads by chosing parallel=Val{:threads}()).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.fornberg-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T","page":"API reference","title":"SummationByPartsOperators.fornberg","text":"fornberg(x::Vector{T}, m::Int) where {T}\n\nCalculate the weights of a finite difference approximation of the mth derivative with maximal order of accuracy at 0 using the nodes x, see Fornberg (1998) Calculation of Weights in Finite Difference Formulas SIAM Rev. 40.3, pp. 685-691.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.fourier_derivative_matrix","page":"API reference","title":"SummationByPartsOperators.fourier_derivative_matrix","text":"fourier_derivative_matrix(N, xmin::Real=0.0, xmax::Real=2π)\n\nCompute the Fourier derivative matrix with respect to the corresponding nodal basis using N nodes, see Kopriva (2009) Implementing Spectral Methods for PDEs, Algorithm 18.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.fourier_derivative_operator-Tuple{Real, Real, Integer}","page":"API reference","title":"SummationByPartsOperators.fourier_derivative_operator","text":"fourier_derivative_operator(xmin::Real, xmax::Real, N::Integer)\nfourier_derivative_operator(; xmin::Real, xmax::Real, N::Integer)\n\nConstruct the FourierDerivativeOperator on a uniform grid between xmin and xmax using N nodes and N÷2+1 complex Fourier modes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.grid","page":"API reference","title":"SummationByPartsOperators.grid","text":"grid(D)\n\nReturn the grid associated to a derivative operator D.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.left_boundary_weight","page":"API reference","title":"SummationByPartsOperators.left_boundary_weight","text":"left_boundary_weight(D)\n\nReturn the left-boundary weight of the (diagonal) mass matrix M associated to the derivative operator D.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.legendre_derivative_operator-Tuple{Real, Real, Integer}","page":"API reference","title":"SummationByPartsOperators.legendre_derivative_operator","text":"legendre_derivative_operator(xmin::Real, xmax::Real, N::Integer)\nlegendre_derivative_operator(; xmin::Real, xmax::Real, N::Integer)\n\nConstruct the LegendreDerivativeOperator on a uniform grid between xmin and xmax using N nodes and N-1 Legendre modes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.legendre_second_derivative_operator-Tuple{Real, Real, Integer}","page":"API reference","title":"SummationByPartsOperators.legendre_second_derivative_operator","text":"legendre_second_derivative_operator(xmin::Real, xmax::Real, N::Integer)\nlegendre_second_derivative_operator(; xmin::Real, xmax::Real, N::Integer)\n\nConstruct the LegendreDerivativeOperator on a uniform grid between xmin and xmax using N nodes and N-1 Legendre modes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.mass_matrix-Tuple{Union{DerivativeOperator, VarCoefDerivativeOperator}}","page":"API reference","title":"SummationByPartsOperators.mass_matrix","text":"mass_matrix(D::Union{DerivativeOperator,VarCoefDerivativeOperator})\n\nCreate the diagonal mass matrix for the SBP derivative operator D.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.periodic_central_derivative_coefficients","page":"API reference","title":"SummationByPartsOperators.periodic_central_derivative_coefficients","text":"periodic_central_derivative_coefficients(derivative_order, accuracy_order, T=Float64, parallel=Val{:serial}())\n\nCreate the PeriodicDerivativeCoefficients approximating the derivative_order-th derivative with an order of accuracy accuracy_order and scalar type T. The evaluation of the derivative can be parallised using threads by chosing parallel=Val{:threads}()).\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.periodic_central_derivative_operator","page":"API reference","title":"SummationByPartsOperators.periodic_central_derivative_operator","text":"periodic_central_derivative_operator(derivative_order, accuracy_order,\n                                     grid, parallel=Val{:serial}())\n\nCreate a PeriodicDerivativeOperator approximating the derivative_order-th derivative on the uniform grid up to order of accuracy accuracy_order. The evaluation of the derivative can be parallised using threads by chosing parallel=Val{:threads}()).\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.periodic_central_derivative_operator-2","page":"API reference","title":"SummationByPartsOperators.periodic_central_derivative_operator","text":"periodic_central_derivative_operator(derivative_order, accuracy_order,\n                                     xmin, xmax, N, parallel=Val{:serial}())\n\nCreate a PeriodicDerivativeOperator approximating the derivative_order-th derivative on a uniform grid between xmin and xmax with N grid points up to order of accuracy accuracy_order. The evaluation of the derivative can be parallised using threads by chosing parallel=Val{:threads}()).\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.periodic_derivative_coefficients","page":"API reference","title":"SummationByPartsOperators.periodic_derivative_coefficients","text":"periodic_derivative_coefficients(derivative_order, accuracy_order, left_offset=-(accuracy_order+1)÷2, T=Float64, parallel=Val{:serial}())\n\nCreate the PeriodicDerivativeCoefficients approximating the derivative_order-th derivative with an order of accuracy accuracy_order and scalar type T where the leftmost grid point used is determined by left_offset. The evaluation of the derivative can be parallised using threads by chosing parallel=Val{:threads}())`.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.periodic_derivative_coefficients-Tuple{Holoborodko2008, Any, Any}","page":"API reference","title":"SummationByPartsOperators.periodic_derivative_coefficients","text":"periodic_derivative_coefficients(source::Holoborodko2008, derivative_order, accuracy_order;\n                                 T=Float64, parallel=Val{:serial}(),\n                                 stencil_width=accuracy_order+3)\n\nCreate the PeriodicDerivativeCoefficients approximating the derivative_order-th derivative with an order of accuracy accuracy_order and scalar type T given by Holoborodko2008. The evaluation of the derivative can be parallised using threads by chosing parallel=Val{:threads}())`.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.periodic_derivative_operator","page":"API reference","title":"SummationByPartsOperators.periodic_derivative_operator","text":"periodic_derivative_operator(derivative_order, accuracy_order,\n                             xmin, xmax, N,\n                             left_offset=-(accuracy_order+1)÷2,\n                             parallel=Val{:serial}())\nperiodic_derivative_operator(; derivative_order, accuracy_order,\n                             xmin, xmax, N,\n                             left_offset=-(accuracy_order+1)÷2,\n                             parallel=Val{:serial}())\n\nCreate a PeriodicDerivativeOperator approximating the derivative_order-th derivative on a uniform grid between xmin and xmax with N grid points up to order of accuracy accuracy_order where the leftmost grid point used is determined by left_offset. The evaluation of the derivative can be parallised using threads by chosing parallel=Val{:threads}()).\n\nExamples\n\njulia> periodic_derivative_operator(derivative_order=1, accuracy_order=2,\n                                    xmin=0.0, xmax=1.0, N=11)\nPeriodic 1st derivative operator of order 2 {T=Float64, Parallel=Val{:serial}}\non a grid in [0.0, 1.0] using 11 nodes,\nstencils with 1 nodes to the left, 1 nodes to the right, and coefficients from\n  Fornberg (1998)\n  Calculation of Weights in Finite Difference Formulas.\n  SIAM Rev. 40.3, pp. 685-691.\n\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.periodic_derivative_operator-2","page":"API reference","title":"SummationByPartsOperators.periodic_derivative_operator","text":"periodic_derivative_operator(derivative_order, accuracy_order, grid,\n                             left_offset=-(accuracy_order+1)÷2, parallel=Val{:serial}())\n\nCreate a PeriodicDerivativeOperator approximating the derivative_order-th derivative on thr uniform grid up to order of accuracy accuracy_order where the leftmost grid point used is determined by left_offset. The evaluation of the derivative can be parallised using threads by chosing parallel=Val{:threads}()).\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.periodic_derivative_operator-Tuple{Holoborodko2008, Any, Any, Any, Any, Any}","page":"API reference","title":"SummationByPartsOperators.periodic_derivative_operator","text":"periodic_derivative_operator(source::Holoborodko2008,\n                             derivative_order, accuracy_order,\n                             xmin, xmax, N; parallel=Val{:serial}(), kwargs...)\nperiodic_derivative_operator(source::Holoborodko2008;\n                             derivative_order, accuracy_order,\n                             xmin, xmax, N, parallel=Val{:serial}(), kwargs...)\n\nCreate a PeriodicDerivativeOperator approximating the derivative_order-th derivative on a uniform grid between xmin and xmax with N grid points up to order of accuracy accuracy_order where the leftmost grid point used is determined by left_offset. The evaluation of the derivative can be parallised using threads by chosing parallel=Val{:threads}()).\n\nExamples\n\njulia> periodic_derivative_operator(Holoborodko2008(), derivative_order=1, accuracy_order=2,\n                                    xmin=0.0, xmax=1.0, N=11)\nPeriodic 1st derivative operator of order 2 {T=Float64, Parallel=Val{:serial}}\non a grid in [0.0, 1.0] using 11 nodes,\nstencils with 2 nodes to the left, 2 nodes to the right, and coefficients from\n  Holoborodko (2008)\n  Smooth Noise Robust Differentiators.\n  http://www.holoborodko.com/pavel/numerical-methods/numerical-derivative/smooth-low-noise-differentiators/\n\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.right_boundary_weight","page":"API reference","title":"SummationByPartsOperators.right_boundary_weight","text":"right_boundary_weight(D)\n\nReturn the left-boundary weight of the (diagonal) mass matrix M associated to the derivative operator D.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.semidiscretize-Tuple{Any, SummationByPartsOperators.AbstractSemidiscretisation, Any}","page":"API reference","title":"SummationByPartsOperators.semidiscretize","text":"semidiscretize(u0func, semidisc::AbstractSemidiscretisation, tspan)\n\nApply the semidiscretisation semidisc to the initial data given by u0func and return an ODEProblem with time span tspan.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.source_of_coefficients-Tuple{Any}","page":"API reference","title":"SummationByPartsOperators.source_of_coefficients","text":"source_of_coefficients(D)\n\nReturn the source of coefficients of the derivative operator D. If you use the operator D for your research, please cite this source in addition to SummationByPartsOperators.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.var_coef_derivative_operator","page":"API reference","title":"SummationByPartsOperators.var_coef_derivative_operator","text":"var_coef_derivative_operator(source_of_coefficients, derivative_order, accuracy_order, xmin, xmax, N, left_weights, right_weights, bfunc, parallel=Val{:serial}())\n\nCreate a VarCoefDerivativeOperator approximating a derivative_order-th derivative with variable coefficients bfunc on a grid between xmin and xmax with N grid points up to order of accuracy accuracy_order with coefficients given by source_of_coefficients. The evaluation of the derivative can be parallised using threads by chosing parallel=Val{:threads}()).\n\n\n\n\n\n","category":"function"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2017-present Hendrik Ranocha <mail@ranocha.de>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"tutorials/wave_equation/#Wave-equation","page":"Wave equation","title":"Wave equation","text":"","category":"section"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"Consider the linear wave equation","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"beginaligned\n    partial_t^2 u(tx) = partial_x^2 u(tx)  t in (0T) x in (x_min x_max) \n    u(0x) = u_0(x)  x in (x_min x_max) \n    partial_t u(0x) = v_0(x)  x in (x_min x_max) \n    textboundary conditions  x in partial (x_min x_max)\nendaligned","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"SummationByPartsOperators.jl includes a pre-built semidiscretization of this equation: WaveEquationNonperiodicSemidiscretisation. Have a look at the source code if you want to dig deeper. In particular, you can find applications of derivative_left, derivative_right add_transpose_derivative_left!, and add_transpose_derivative_right!. Below is an example demonstrating how to use this semidiscretization.","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"using SummationByPartsOperators, OrdinaryDiffEq\nusing LaTeXStrings; using Plots: Plots, plot, plot!, savefig\n\n# general parameters\nxmin = -1.\nxmax = +1.\ntspan = (0., 8.0)\nu0_func(x) = exp(-20x^2)\nv0_func(x) = zero(x)\n# HomogeneousNeumann, HomogeneousDirichlet, and NonReflecting BCs are available\nleft_bc  = Val(:HomogeneousNeumann)\nright_bc = Val(:HomogeneousDirichlet)\n\n# setup spatial semidiscretization\nD2 = derivative_operator(MattssonSvärdShoeybi2008(), derivative_order=2,\n                         accuracy_order=4, xmin=xmin, xmax=xmax, N=101)\nsemi = WaveEquationNonperiodicSemidiscretisation(D2, left_bc, right_bc)\node = semidiscretize(v0_func, u0_func, semi, tspan)\n\n# solve second-order ODE using a Runge-Kutta-Nyström method\nsol = solve(ode, DPRKN6(), saveat=range(first(tspan), stop=last(tspan), length=200))\n\n# visualize the result\nplot(xguide=L\"x\")\nplot!(evaluate_coefficients(sol[end].x[2], semi), label=L\"u\")\nplot!(evaluate_coefficients(sol[end].x[1], semi), label=L\"\\partial_t u\")\nsavefig(\"example_wave_equation.png\");","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"(Image: )","category":"page"},{"location":"tutorials/wave_equation/#Advanced-visualization-of-different-boundary-conditions","page":"Wave equation","title":"Advanced visualization of different boundary conditions","text":"","category":"section"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"Let's create animations of the numerical solutions for different boundary conditions.","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"using Printf; using Plots: Animation, frame, gif\n\nfunction create_gif(left_bc::Val{LEFT_BC}, right_bc::Val{RIGHT_BC}) where {LEFT_BC, RIGHT_BC}\n    xmin = -1.\n    xmax = +1.\n    tspan = (0., 8.0)\n    u0_func(x) = exp(-20x^2)\n    v0_func(x) = zero(x)\n\n    D2 = derivative_operator(MattssonSvärdShoeybi2008(), derivative_order=2,\n                            accuracy_order=4, xmin=xmin, xmax=xmax, N=101)\n    semi = WaveEquationNonperiodicSemidiscretisation(D2, left_bc, right_bc)\n    ode = semidiscretize(v0_func, u0_func, semi, tspan)\n\n    sol = solve(ode, DPRKN6(), saveat=range(first(tspan), stop=last(tspan), length=200))\n\n    anim = Animation()\n    idx = 1\n    x, u = evaluate_coefficients(sol[idx].x[2], D2)\n    fig = plot(x, u, xguide=L\"x\", yguide=L\"u\", xlim=extrema(x), ylim=(-1.05, 1.05),\n              label=\"\", title=@sprintf(\"\\$t = %6.2f \\$\", sol.t[idx]))\n    for idx in 1:length(sol.t)\n        fig[1] = x, sol.u[idx].x[2]\n        plot!(title=@sprintf(\"\\$t = %6.2f \\$\", sol.t[idx]))\n        frame(anim)\n    end\n    gif(anim, \"wave_equation_$(LEFT_BC)_$(RIGHT_BC).gif\")\nend\n\ncreate_gif(Val(:HomogeneousNeumann), Val(:HomogeneousNeumann))","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"(Image: wave_equation_HomogeneousNeumann_HomogeneousNeumann)","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"create_gif(Val(:HomogeneousNeumann), Val(:HomogeneousDirichlet))","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"(Image: wave_equation_HomogeneousNeumann_HomogeneousDirichlet)","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"create_gif(Val(:HomogeneousNeumann), Val(:NonReflecting))","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"(Image: wave_equation_HomogeneousNeumann_NonReflecting)","category":"page"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Summation-by-parts (SBP) operators are discrete derivative operators designed to enable (semi-) discrete stability proofs mimicking the energy method from the continuous level. To do so, SBP operators mimic integration-by-parts discretely. Here, we will briefly explain the basic concepts. If you want to learn more about this subject, the classical review articles of [SvärdNordström2014] and [FernándezHickenZingg2014] are good starting points. More recent references and applications of SBP operators from many classes implemented in SummationByPartsOperators.jl are given by [RanochaMitsotakisKetcheson2021].","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Since SBP operators are designed to mimic integration-by-parts, they need a notion of derivatives and integrals. Here, derivatives are interpreted as linear operators D (derivative matrices) and integrals are interpreted as discrete inner products, represented by the associated mass/norm matrices M. Thus, the discrete derivative of a grid function u is D * u and the discrete inner product of two grid functions u and v is dot(u, M, v), where M = mass_matrix(D). Here, we have already introduced some basic interfaces provided by SummationByPartsOperators.jl:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Derivative operators act as linear operators implementing * (and mul! for more efficient in-place updates avoiding allocations).\nThe mass matrix associated to an SBP derivative operator can be retrieved via mass_matrix.","category":"page"},{"location":"introduction/#Periodic-domains","page":"Introduction","title":"Periodic domains","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Periodic (central) SBP operators mimic the properties of differential operators on periodic domains. Hence, they are","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"skew-symmetric if they approximate odd derivatives\nsymmetric and semi-definite if they approximate even derivatives; second-derivative operators are negative semi-definite, fourth-derivative operators are positive semi-definite etc.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Classical central finite difference operators on periodic domains are periodic SBP operators. They can be constructed via periodic_derivative_operator. Similarly, Fourier collocation methods can be interpreted as periodic SBP operators, which can be constructed via fourier_derivative_operator.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> using SummationByPartsOperators, LinearAlgebra\n\njulia> D = periodic_derivative_operator(derivative_order=1, accuracy_order=2,\n                                        xmin=0.0, xmax=2.0, N=21)\nPeriodic 1st derivative operator of order 2 {T=Float64, Parallel=Val{:serial}}\non a grid in [0.0, 2.0] using 21 nodes,\nstencils with 1 nodes to the left, 1 nodes to the right, and coefficients from\n  Fornberg (1998)\n  Calculation of Weights in Finite Difference Formulas.\n  SIAM Rev. 40.3, pp. 685-691.\n\n\njulia> M = mass_matrix(D)\nUniformScaling{Float64}\n0.1*I\n\njulia> M * Matrix(D) + Matrix(D)' * M |> norm\n0.0\n\njulia> D = fourier_derivative_operator(xmin=0.0, xmax=2.0, N=20)\nPeriodic 1st derivative Fourier operator {T=Float64}\non a grid in [0.0, 2.0] using 20 nodes and 11 modes.\n\n\njulia> M = mass_matrix(D)\nUniformScaling{Float64}\n0.1*I\n\njulia> norm(M * Matrix(D) + Matrix(D)' * M) < 10 * eps(eltype(D))\ntrue","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"As you have seen above, conversion methods to other common types such as Matrix, sparse from the standard library SparseArrays, and BandedMatrix from BandedMatrices.jl are available.","category":"page"},{"location":"introduction/#Non-periodic-domains","page":"Introduction","title":"Non-periodic domains","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"On non-periodic domains, additional boundary terms appear. Thus, the basic symmetry properties of SBP operators are the same as the ones of periodic SBP operators modulo boundary terms. Note that the correct handling of boundary terms is the basic reason of the success of SBP operators. In particular for hyperbolic problems, other boundary treatments that might appear senseful can result in catastrophic failure.","category":"page"},{"location":"introduction/#First-derivative-operators","page":"Introduction","title":"First-derivative operators","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"First-derivative SBP operators need to mimic","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"  int_x_mathrmmin^x_mathrmmax u(x) bigl( partial_x v(x) bigr) mathrmdx\n+ int_x_mathrmmin^x_mathrmmax bigl( partial_x u(x) bigr) v(x) mathrmdx\n= u(x_mathrmmax) v(x_mathrmmax) - u(x_mathrmmin) v(x_mathrmmin)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Thus, a discrete evaluation at the boundary of the domain is necessary. For SBP operators with a grid including the boundary nodes, this can be achieved by simply picking the first/last nodal coefficient of a grid function u. If boundary nodes are not included, some interpolation is necessary in general. Nevertheless, getting a boundary value is a linear functional that is often represented in the literature using (transposed) vectors tL, tR. Then, an SBP operator has to satisfy M * D + D' * M == tR * tR' - tL * tL'. The boundary operators are represented matrix-free via derivative_left and derivative_right for zeroth-order derivatives.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> using SummationByPartsOperators, LinearAlgebra\n\njulia> D = derivative_operator(MattssonNordström2004(), derivative_order=1, accuracy_order=2,\n                               xmin=0//1, xmax=1//1, N=9)\nSBP 1st derivative operator of order 2 {T=Rational{Int64}, Parallel=Val{:serial}}\non a grid in [0//1, 1//1] using 9 nodes\nand coefficients given in\n  Mattsson, Nordström (2004)\n  Summation by parts operators for finite difference approximations of second\n    derivatives.\n  Journal of Computational Physics 199, pp. 503-540.\n\n\njulia> tL = zeros(eltype(D), size(D, 1)); tL[1] = 1; tL'\n1×9 adjoint(::Vector{Rational{Int64}}) with eltype Rational{Int64}:\n 1//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1\n\njulia> tR = zeros(eltype(D), size(D, 1)); tR[end] = 1; tR'\n1×9 adjoint(::Vector{Rational{Int64}}) with eltype Rational{Int64}:\n 0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  1//1\n\njulia> M = mass_matrix(D)\n9×9 Diagonal{Rational{Int64}, Vector{Rational{Int64}}}:\n 1//16   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅\n  ⋅     1//8   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅\n  ⋅      ⋅    1//8   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅\n  ⋅      ⋅     ⋅    1//8   ⋅     ⋅     ⋅     ⋅     ⋅\n  ⋅      ⋅     ⋅     ⋅    1//8   ⋅     ⋅     ⋅     ⋅\n  ⋅      ⋅     ⋅     ⋅     ⋅    1//8   ⋅     ⋅     ⋅\n  ⋅      ⋅     ⋅     ⋅     ⋅     ⋅    1//8   ⋅     ⋅\n  ⋅      ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    1//8   ⋅\n  ⋅      ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    1//16\n\njulia> M * Matrix(D) + Matrix(D)' * M == tR * tR' - tL * tL'\ntrue\n\njulia> u = randn(size(grid(D))); derivative_left(D, u, Val(0)) == u[begin]\ntrue\n\njulia> u = randn(size(grid(D))); derivative_right(D, u, Val(0)) == u[end]\ntrue","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Here, we have introduced some additional features. Firstly, exact rational coefficients are provided, based on the type of xmin and xmax (if available). Secondly, a source_of_coefficients has to be provided when constructing the SBP operator. You can list them using","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"using InteractiveUtils, SummationByPartsOperators\nsubtypes(SourceOfCoefficients)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Here and in the following, the order of accuracy of (finite difference) SBP operators refers to the local order of accuracy in the interior, cf. accuracy_order.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"A special case of first-derivative SBP operators are polynomial derivative operators on Lobatto-Legendre nodes, implemented in legendre_derivative_operator.","category":"page"},{"location":"introduction/#Second-derivative-operators","page":"Introduction","title":"Second-derivative operators","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"To mimic integration-by-parts of second derivatives,","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"  int_x_mathrmmin^x_mathrmmax u(x) bigl( partial_x^2 v(x) bigr) mathrmdx\n= - int_x_mathrmmin^x_mathrmmax bigl( partial_x u(x) bigr) bigl( partial_x v(x) bigr) mathrmdx\n  + u(x_mathrmmax) bigl( partial_x v(x_mathrmmax) bigr)\n  - bigl( partial_x u(x_mathrmmin)) v(x_mathrmmin)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"the evaluation of the first derivative at the boundaries is necessary. These linear functionals are available as derivative_left and derivative_right. In the literature, they are often called dL and dR. Then, a second-derivative SBP operator has to be of the form M * D == -A + tR * dR' - tL * dL', where A is symmetric and positive semidefinite.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> using SummationByPartsOperators, LinearAlgebra\n\njulia> D = derivative_operator(MattssonNordström2004(), derivative_order=2, accuracy_order=2,\n                               xmin=0//1, xmax=1//1, N=9)\nSBP 2nd derivative operator of order 2 {T=Rational{Int64}, Parallel=Val{:serial}}\non a grid in [0//1, 1//1] using 9 nodes\nand coefficients given in\n  Mattsson, Nordström (2004)\n  Summation by parts operators for finite difference approximations of second\n    derivatives.\n  Journal of Computational Physics 199, pp. 503-540.\n\n\njulia> M = mass_matrix(D)\n9×9 Diagonal{Rational{Int64}, Vector{Rational{Int64}}}:\n 1//16   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅\n  ⋅     1//8   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅\n  ⋅      ⋅    1//8   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅\n  ⋅      ⋅     ⋅    1//8   ⋅     ⋅     ⋅     ⋅     ⋅\n  ⋅      ⋅     ⋅     ⋅    1//8   ⋅     ⋅     ⋅     ⋅\n  ⋅      ⋅     ⋅     ⋅     ⋅    1//8   ⋅     ⋅     ⋅\n  ⋅      ⋅     ⋅     ⋅     ⋅     ⋅    1//8   ⋅     ⋅\n  ⋅      ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    1//8   ⋅\n  ⋅      ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    1//16\n\njulia> tL = derivative_left(D, Val(0)); tL'\n1×9 adjoint(::Vector{Bool}) with eltype Bool:\n 1  0  0  0  0  0  0  0  0\n\njulia> tR = derivative_right(D, Val(0)); tR'\n1×9 adjoint(::Vector{Bool}) with eltype Bool:\n 0  0  0  0  0  0  0  0  1\n\njulia> dL = derivative_left(D, Val(1)); dL'\n1×9 adjoint(::Vector{Rational{Int64}}) with eltype Rational{Int64}:\n -12//1  16//1  -4//1  0//1  0//1  0//1  0//1  0//1  0//1\n\njulia> dR = derivative_right(D, Val(1)); dR'\n1×9 adjoint(::Vector{Rational{Int64}}) with eltype Rational{Int64}:\n 0//1  0//1  0//1  0//1  0//1  0//1  4//1  -16//1  12//1\n\njulia> A = -M * Matrix(D) + tR * dR' - tL * dL'\n9×9 Matrix{Rational{Int64}}:\n  8//1  -8//1   0//1   0//1   0//1   0//1   0//1   0//1   0//1\n -8//1  16//1  -8//1   0//1   0//1   0//1   0//1   0//1   0//1\n  0//1  -8//1  16//1  -8//1   0//1   0//1   0//1   0//1   0//1\n  0//1   0//1  -8//1  16//1  -8//1   0//1   0//1   0//1   0//1\n  0//1   0//1   0//1  -8//1  16//1  -8//1   0//1   0//1   0//1\n  0//1   0//1   0//1   0//1  -8//1  16//1  -8//1   0//1   0//1\n  0//1   0//1   0//1   0//1   0//1  -8//1  16//1  -8//1   0//1\n  0//1   0//1   0//1   0//1   0//1   0//1  -8//1  16//1  -8//1\n  0//1   0//1   0//1   0//1   0//1   0//1   0//1  -8//1   8//1\n\njulia> isposdef(A)\ntrue","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Usually, there is no need to form dL, dR explicitly. Instead, you can use the matrix-free variants derivative_left and derivative_right. Some procedures imposing boundary conditions weakly require adding the transposed boundary derivatives to a grid function, which can be achieved by add_transpose_derivative_left! and add_transpose_derivative_right!. You can find applications of these operators in the source code of WaveEquationNonperiodicSemidiscretisation.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"A special case of second-derivative SBP operators are polynomial derivative operators on Lobatto-Legendre nodes, implemented in legendre_second_derivative_operator.","category":"page"},{"location":"introduction/#Upwind-operators","page":"Introduction","title":"Upwind operators","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Upwind SBP operators were introduced by Mattsson2017. They combine two derivative operators Dp (:plus) and Dm (:minus) such that M * Dp + Dm' * M == tR * tR' - tL * tL' and M * (Dp - Dm) is negative semidefinite.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> using SummationByPartsOperators, LinearAlgebra\n\njulia> Dp = derivative_operator(Mattsson2017(:plus), derivative_order=1, accuracy_order=2,\n                                xmin=0//1, xmax=1//1, N=9)\nSBP 1st derivative operator of order 2 {T=Rational{Int64}, Parallel=Val{:serial}}\non a grid in [0//1, 1//1] using 9 nodes\nand coefficients given in\n  Upwind coefficients (plus) of\n  Mattsson (2017)\n  Diagonal-norm upwind SBP operators.\n  Journal of Computational Physics 335, pp. 283-310.\n\n\njulia> Dm = derivative_operator(Mattsson2017(:minus), derivative_order=1, accuracy_order=2,\n                                xmin=0//1, xmax=1//1, N=9)\nSBP 1st derivative operator of order 2 {T=Rational{Int64}, Parallel=Val{:serial}}\non a grid in [0//1, 1//1] using 9 nodes\nand coefficients given in\n  Upwind coefficients (minus) of\n  Mattsson (2017)\n  Diagonal-norm upwind SBP operators.\n  Journal of Computational Physics 335, pp. 283-310.\n\n\njulia> M = mass_matrix(Dp)\n9×9 Diagonal{Rational{Int64}, Vector{Rational{Int64}}}:\n 1//32   ⋅      ⋅     ⋅     ⋅     ⋅     ⋅     ⋅      ⋅\n  ⋅     5//32   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅      ⋅\n  ⋅      ⋅     1//8   ⋅     ⋅     ⋅     ⋅     ⋅      ⋅\n  ⋅      ⋅      ⋅    1//8   ⋅     ⋅     ⋅     ⋅      ⋅\n  ⋅      ⋅      ⋅     ⋅    1//8   ⋅     ⋅     ⋅      ⋅\n  ⋅      ⋅      ⋅     ⋅     ⋅    1//8   ⋅     ⋅      ⋅\n  ⋅      ⋅      ⋅     ⋅     ⋅     ⋅    1//8   ⋅      ⋅\n  ⋅      ⋅      ⋅     ⋅     ⋅     ⋅     ⋅    5//32   ⋅\n  ⋅      ⋅      ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     1//32\n\njulia> M * Matrix(Dp) + Matrix(Dm)' * M\n9×9 Matrix{Rational{Int64}}:\n -1//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1\n  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1\n  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1\n  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1\n  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1\n  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1\n  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1\n  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1\n  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  1//1\n\njulia> minimum(eigvals(-M * (Matrix(Dp) - Matrix(Dm)))) > -100 * eps() # tolerance for zero eigenvalues\ntrue","category":"page"},{"location":"introduction/#Continuous-and-discontinuous-Galerkin-methods","page":"Introduction","title":"Continuous and discontinuous Galerkin methods","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"SBP operators can be coupled to obtain (nodal) continuous Galerkin (CG) methods. If the underlying SBP operators are LegendreDerivativeOperators, these are CG spectral element methods (CGSEM). However, a continuous coupling of arbitrary SBP operators is supported.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> using SummationByPartsOperators, LinearAlgebra\n\njulia> D = couple_continuously(\n               legendre_derivative_operator(xmin=-1.0, xmax=1.0, N=3),\n               UniformMesh1D(xmin=0.0, xmax=1.0, Nx=3))\nFirst derivative operator {T=Float64}\non the Lobatto Legendre nodes in [-1.0, 1.0] using 3 nodes\ncoupled continuously on the mesh\nUniformMesh1D{Float64} with 3 cells in (0.0, 1.0)\n\n\njulia> Matrix(D)\n7×7 Matrix{Float64}:\n -9.0  12.0  -3.0   0.0   0.0    0.0   0.0\n -3.0   0.0   3.0   0.0   0.0    0.0   0.0\n  1.5  -6.0   0.0   6.0  -1.5    0.0   0.0\n  0.0   0.0  -3.0   0.0   3.0    0.0   0.0\n  0.0   0.0   1.5  -6.0   0.0    6.0  -1.5\n  0.0   0.0   0.0   0.0  -3.0    0.0   3.0\n  0.0   0.0   0.0   0.0   3.0  -12.0   9.0\n\njulia> mass_matrix(D)\n7×7 Diagonal{Float64, Vector{Float64}}:\n 0.0555556   ⋅         ⋅         ⋅         ⋅         ⋅         ⋅\n  ⋅         0.222222   ⋅         ⋅         ⋅         ⋅         ⋅\n  ⋅          ⋅        0.111111   ⋅         ⋅         ⋅         ⋅\n  ⋅          ⋅         ⋅        0.222222   ⋅         ⋅         ⋅\n  ⋅          ⋅         ⋅         ⋅        0.111111   ⋅         ⋅\n  ⋅          ⋅         ⋅         ⋅         ⋅        0.222222   ⋅\n  ⋅          ⋅         ⋅         ⋅         ⋅         ⋅        0.0555556","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"SBP operators can also be coupled as in discontinuous Galerkin (DG) methods. Using a central numerical flux results in central SBP operators; upwind fluxes yield upwind SBP operators. If LegendreDerivativeOperators are used, the discontinuous coupling yields DG spectral element methods (DGSEM).","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> using SummationByPartsOperators, LinearAlgebra\n\njulia> D = couple_discontinuously(\n               legendre_derivative_operator(xmin=-1.0, xmax=1.0, N=3),\n               UniformPeriodicMesh1D(xmin=0.0, xmax=1.0, Nx=3),\n               Val(:central))\nFirst derivative operator {T=Float64}\non the Lobatto Legendre nodes in [-1.0, 1.0] using 3 nodes\ncoupled discontinuously (upwind: Val{:central}()) on the mesh\nUniformPeriodicMesh1D{Float64} with 3 cells in (0.0, 1.0)\n\n\njulia> M = mass_matrix(D);\n\njulia> M * Matrix(D) + Matrix(D)' * M |> iszero\ntrue","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Right now, only uniform meshes UniformMesh1D and UniformPeriodicMesh1D are implemented.","category":"page"},{"location":"introduction/#Basic-interfaces-and-additional-features","page":"Introduction","title":"Basic interfaces and additional features","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"To actually compute and plot the discrete grid functions, a few additional ingredients are necessary.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The discrete coefficients of a function on the grid of an SBP operator can usually be computed as x = grid(D); u = u_function.(x), at least for nodal bases. In general, compute_coefficients (or the in-place version compute_coefficients!) can also be used for this task.\nTo get a grid and discrete values suitable for plotting, you can use evaluate_coefficients (or the in-place version evaluate_coefficients!). The plot nodes returned from evaluate_coefficients can be different from the nodes of the grid associated to an SBP operator.\nTo implement boundary procedures, the weights of the mass matrix at the boundary are often needed. These can be obtained without forming M = mass_matrix(D) explicitly via left_boundary_weight and right_boundary_weight.\nInstead of forming a mass matrix explicitly, discrete integrals can be evaluated efficiently using integrate.\nDissipation operators based on the same discrete inner product as SBP derivative operators can be obtained via dissipation_operator.","category":"page"},{"location":"introduction/#Next-steps","page":"Introduction","title":"Next steps","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"If you are familiar with SBP operators in general, this introduction might already be enough for you to apply SummationByPartsOperators.jl to your problems. Otherwise, you might want to have a look at the references, the tutorials coming next, or some ready-to-use semidiscretizations of the following partial differential equations (PDEs). These are shipped with this package and you are encouraged to look at their source code to learn more about it.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Linear scalar advection with variable coefficient: VariableLinearAdvectionNonperiodicSemidiscretisation\nBurgers' equation (inviscid): BurgersPeriodicSemidiscretisation, BurgersNonperiodicSemidiscretisation\nScalar conservation law with cubic flux: CubicPeriodicSemidiscretisation, CubicNonperiodicSemidiscretisation\nA scalar conservation law with quartic, non-convex flux: QuarticNonconvexPeriodicSemidiscretisation\nThe second-order wave equation: WaveEquationNonperiodicSemidiscretisation","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Some additional examples are included as Jupyter notebooks in the directory notebooks. Even more examples and research articles making use of SummationByPartsOperators.jl are listed in the section Applications. If you want to know even more, you can have a look at the test.","category":"page"},{"location":"introduction/#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"[SvärdNordström2014]: Svärd, Nordström (2014). Review of summation-by-parts schemes for initial–boundary-value problems. DOI: 10.1016/j.jcp.2014.02.031","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"[FernándezHickenZingg2014]: Fernández, Hicken, Zingg (2014). Review of summation-by-parts operators with simultaneous approximation terms for the numerical solution of partial differential equations. DOI: 10.1016/j.compfluid.2014.02.016","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"[RanochaMitsotakisKetcheson2021]: Ranocha, Mitsotakis, Ketcheson (2021). A Broad Class of Conservative Numerical Methods for Dispersive Wave Equations. DOI: 10.4208/cicp.OA-2020-0119","category":"page"},{"location":"#SummationByPartsOperators.jl","page":"Home","title":"SummationByPartsOperators.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SummationByPartsOperators.jl is a Julia library of summation-by-parts (SBP) operators, which are discrete derivative operators developed to get provably stable semidiscretizations, paying special attention to boundary conditions. Discretizations included in this framework are finite difference, Fourier pseudospectral, continuous Galerkin, and discontinuous Galerkin methods. The main aim of SummationByPartsOperators.jl is to be useful for researchers and students to learn the basic concepts by providing a unified framework of all of these seemingly different discretizations. At the same time, the implementation is optimized to achieve good performance without sacrificing flexibility.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SummationByPartsOperators.jl is a registered Julia package. Thus, you can install it from the Julia REPL via","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"SummationByPartsOperators\")","category":"page"},{"location":"#Basic-examples","page":"Home","title":"Basic examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Compute the derivative on a periodic domain using a central finite difference operator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SummationByPartsOperators\n\njulia> using Plots: plot, plot!\n\njulia> D = periodic_derivative_operator(derivative_order=1, accuracy_order=2,\n                                        xmin=0.0, xmax=2.0, N=21)\nPeriodic 1st derivative operator of order 2 {T=Float64, Parallel=Val{:serial}}\non a grid in [0.0, 2.0] using 21 nodes,\nstencils with 1 nodes to the left, 1 nodes to the right, and coefficients from\n  Fornberg (1998)\n  Calculation of Weights in Finite Difference Formulas.\n  SIAM Rev. 40.3, pp. 685-691.\n\n\njulia> x = grid(D); u = sinpi.(x);\n\njulia> plot(x, D * u, label=\"numerical\")\n\njulia> plot!(x, π .* cospi.(x), label=\"analytical\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"You should see a plot like the following.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Compute the derivative on a bounded domain using an SBP finite difference operator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SummationByPartsOperators\n\njulia> using Plots: plot, plot!\n\njulia> D = derivative_operator(MattssonNordström2004(), derivative_order=1, accuracy_order=2,\n                               xmin=0.0, xmax=1.0, N=21)\nSBP 1st derivative operator of order 2 {T=Float64, Parallel=Val{:serial}}\non a grid in [0.0, 1.0] using 21 nodes\nand coefficients given in\n  Mattsson, Nordström (2004)\n  Summation by parts operators for finite difference approximations of second\n    derivatives.\n  Journal of Computational Physics 199, pp. 503-540.\n\n\njulia> x = grid(D); u = exp.(x);\n\njulia> plot(x, D * u, label=\"numerical\")\n\njulia> plot!(x, exp.(x), label=\"analytical\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"You should see a plot like the following.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Referencing","page":"Home","title":"Referencing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use SummationByPartsOperators.jl for your research, please cite it using the bibtex entry","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{ranocha2021sbp,\n  title={{SummationByPartsOperators.jl}: {A} {J}ulia library of provably stable\n         semidiscretization techniques with mimetic properties},\n  author={Ranocha, Hendrik},\n  year={2021},\n  howpublished={\\url{https://github.com/ranocha/SummationByPartsOperators.jl},\n  doi={10.5281/zenodo.4773575}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please also cite the appropriate references for specific SBP operators you use, which can be obtained via source_of_coefficients.","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is licensed under the MIT license (see License). Since it is an open-source project, we are very happy to accept contributions from the community. Please refer to the section Contributing for more details.","category":"page"}]
}
