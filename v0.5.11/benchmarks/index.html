<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Benchmarks Â· SummationByPartsOperators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/benchmarks/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SummationByPartsOperators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/constant_linear_advection/">Linear advection equation with constant coefficients</a></li><li><a class="tocitem" href="../tutorials/advection_diffusion/">Linear advection diffusion equation with periodic boundary conditions</a></li><li><a class="tocitem" href="../tutorials/variable_linear_advection/">Linear advection equation with variable coefficients</a></li><li><a class="tocitem" href="../tutorials/wave_equation/">Wave equation</a></li></ul></li><li><a class="tocitem" href="../applications/">Applications &amp; references</a></li><li class="is-active"><a class="tocitem" href>Benchmarks</a><ul class="internal"><li><a class="tocitem" href="#First-derivative-operators"><span>First-derivative operators</span></a></li><li><a class="tocitem" href="#Dissipation-operators"><span>Dissipation operators</span></a></li><li><a class="tocitem" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)"><span>Structure-of-Arrays (SoA) and Array-of-Structures (AoS)</span></a></li></ul></li><li><a class="tocitem" href="../api_reference/">API reference</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Benchmarks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Benchmarks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ranocha/SummationByPartsOperators.jl/blob/master/docs/src/benchmarks.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Benchmarks"><a class="docs-heading-anchor" href="#Benchmarks">Benchmarks</a><a id="Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarks" title="Permalink"></a></h1><p>Here are some simple benchmarks. Take them with a grain of salt since they run on virtual machines in the cloud to generate the documentation automatically.</p><h2 id="First-derivative-operators"><a class="docs-heading-anchor" href="#First-derivative-operators">First-derivative operators</a><a id="First-derivative-operators-1"></a><a class="docs-heading-anchor-permalink" href="#First-derivative-operators" title="Permalink"></a></h2><h4 id="Periodic-domains"><a class="docs-heading-anchor" href="#Periodic-domains">Periodic domains</a><a id="Periodic-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-domains" title="Permalink"></a></h4><p>Let&#39;s set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, DiffEqOperators

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = periodic_derivative_operator(derivative_order=1, accuracy_order=2,
                                     xmin=xmin, xmax=xmax, N=100)
x = grid(D_SBP)
D_DEO = CenteredDifference(derivative_order(D_SBP), accuracy_order(D_SBP),
                           step(x), length(x)) * PeriodicBC(eltype(D_SBP))

D_sparse = sparse(D_SBP)

u = randn(eltype(D_SBP), length(x)); du = similar(u);
@show D_SBP * u â‰ˆ D_DEO * u â‰ˆ D_sparse * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>First, we benchmark the implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 989 evaluations.
 Range (min â€¦ max):  45.905 ns â€¦  1.045 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     53.994 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   55.893 ns Â± 23.190 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–„   â–ƒâ– â–„ â–…â–ˆ                                                 â–
  â–ˆâ–â–â–â–ˆâ–ˆâ–„â–ˆâ–„â–ˆâ–ˆâ–†â–…â–‡â–†â–†â–…â–†â–†â–‡â–‡â–‡â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–ˆâ–ˆâ–‡â–…â–‡â–‡â–‡â–†â–†â–…â–…â–ƒâ–â–„â–„â–…â–„â–…â–†â–†â–…â–†â–…â–…â–…â–…â–„â–… â–ˆ
  45.9 ns      Histogram: log(frequency) by time      92.7 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we compare this to the runtime obtained using a sparse matrix representation of the derivative operator. Depending on the hardware etc., this can be an order of magnitude slower than the optimized implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_sparse, &quot;D_sparse:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_sparse:
BenchmarkTools.Trial: 10000 samples with 301 evaluations.
 Range (min â€¦ max):  275.748 ns â€¦   7.597 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     322.591 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   354.765 ns Â± 133.490 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆ    â–
  â–ˆâ–ƒâ–…â–‚â–ˆâ–ˆâ–„â–†â–â–…â–„â–ƒâ–ƒâ–ƒâ–ƒâ–ƒâ–‚â–„â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â– â–‚
  276 ns           Histogram: frequency by time          657 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, we benchmark the implementation of the same derivative operator in DiffEqOperators.jl.</p><pre><code class="language-julia hljs">doit(D_DEO, &quot;D_DEO:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_DEO:
â”Œ Warning: #= /home/runner/.julia/packages/DiffEqOperators/NwER0/src/derivative_operators/convolutions.jl:375 =#:
â”‚ `LoopVectorization.check_args` on your inputs failed; running fallback `@inbounds @fastmath` loop instead.
â”‚ Use `warn_check_args=false`, e.g. `@turbo warn_check_args=false ...`, to disable this warning.
â”” @ DiffEqOperators ~/.julia/packages/LoopVectorization/kVenK/src/condense_loopset.jl:825
â”Œ Warning: #= /home/runner/.julia/packages/DiffEqOperators/NwER0/src/derivative_operators/convolutions.jl:419 =#:
â”‚ `LoopVectorization.check_args` on your inputs failed; running fallback `@inbounds @fastmath` loop instead.
â”‚ Use `warn_check_args=false`, e.g. `@turbo warn_check_args=false ...`, to disable this warning.
â”” @ DiffEqOperators ~/.julia/packages/LoopVectorization/kVenK/src/condense_loopset.jl:825
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min â€¦ max):  1.140 Î¼s â€¦ 134.530 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     1.380 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   1.585 Î¼s Â±   1.677 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–…â–ƒâ–„â–…â–ˆâ–ˆâ–†â–…â–…â–ƒâ–ƒâ–„â–„â–ƒâ–‚â–‚â–‚â–                                          â–‚
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–‡â–‡â–ˆâ–ˆâ–‡â–ˆâ–‡â–ˆâ–ˆâ–‡â–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–‡â–‡â–‡â–‡â–‡â–†â–‡â–‡â–ˆâ–ˆâ–‡â–†â–†â–…â–…â–„â–ƒâ–„â–„â–„â–… â–ˆ
  1.14 Î¼s      Histogram: log(frequency) by time      3.64 Î¼s &lt;

 Memory estimate: 416 bytes, allocs estimate: 6.</code></pre><h4 id="Bounded-domains"><a class="docs-heading-anchor" href="#Bounded-domains">Bounded domains</a><a id="Bounded-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Bounded-domains" title="Permalink"></a></h4><p>We start again by setting up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,
                            accuracy_order=6, xmin=xmin, xmax=xmax, N=10^3)
D_sparse = sparse(D_SBP)
D_banded = BandedMatrix(D_SBP)

u = randn(eltype(D_SBP), size(D_SBP, 1)); du = similar(u);
@show D_SBP * u â‰ˆ D_sparse * u â‰ˆ D_banded * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>First, we benchmark the implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 85 evaluations.
 Range (min â€¦ max):  771.765 ns â€¦  50.079 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     903.529 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   941.701 ns Â± 721.907 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–…   â–„â– â–… â–ˆâ–‡ â–â–  â–‚â– â–â–‚â–â– â–â–                                    â–‚
  â–ˆâ–â–…â–„â–ˆâ–ˆâ–ˆâ–ˆâ–„â–ˆâ–ˆâ–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–‡â–†â–†â–†â–†â–†â–†â–†â–†â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–†â–†â–†â–…â–„â–ƒâ–…â–„â–…â–…â–„â–„â–…â–ƒâ–…â–„â–ƒ â–ˆ
  772 ns        Histogram: log(frequency) by time       1.59 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Again, we compare this to a representation of the derivative operator as a sparse matrix. No surprise - it is again much slower, as in periodic domains.</p><pre><code class="language-julia hljs">doit(D_sparse, &quot;D_sparse:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_sparse:
BenchmarkTools.Trial: 10000 samples with 6 evaluations.
 Range (min â€¦ max):  5.450 Î¼s â€¦ 197.484 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     6.583 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   7.635 Î¼s Â±   5.041 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–„â–…â–†â–ˆâ–ˆâ–ˆâ–†â–†â–…â–†    â–ƒâ–ƒâ–ƒâ–„â–„â–ƒâ–ƒâ–‚â–‚â–   â–â–â–â–â–â–â–â–                         â–ƒ
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–‡â–†â–‡â–†â–‡â–‡â–†â–‡â–†â–†â–†â–†â–…â–†â–„â–…â–…â–â–…â–…â–ƒâ–… â–ˆ
  5.45 Î¼s      Histogram: log(frequency) by time      18.6 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>FInally, we compare it to a representation as banded matrix. Disappointingly, this is still much slower than the optimized implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_banded, &quot;D_banded:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_banded:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  11.200 Î¼s â€¦ 758.201 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     12.700 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   14.645 Î¼s Â±  11.905 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–„â–†â–‡â–ˆâ–ˆâ–†â–…â–‚â–„                              â–â–‚â–‚â–‚â–â–                â–‚
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–…â–…â–ƒâ–ƒâ–ƒâ–ƒâ–„â–„â–ƒâ–„â–„â–„â–ƒâ–ƒâ–â–â–â–ƒâ–ƒâ–„â–„â–„â–„â–â–„â–ƒâ–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–†â–‡â–‡â–ˆâ–†â–†â–†â–‡â–†â–†â–†â–… â–ˆ
  11.2 Î¼s       Histogram: log(frequency) by time      37.9 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><h2 id="Dissipation-operators"><a class="docs-heading-anchor" href="#Dissipation-operators">Dissipation operators</a><a id="Dissipation-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Dissipation-operators" title="Permalink"></a></h2><p>We follow the same structure as before. At first, we set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,
                            accuracy_order=6, xmin=xmin, xmax=xmax, N=10^3)
Di_SBP  = dissipation_operator(MattssonSvÃ¤rdNordstrÃ¶m2004(), D_SBP)
Di_sparse = sparse(Di_SBP)
Di_banded = BandedMatrix(Di_SBP)
Di_full   = Matrix(Di_SBP)

u = randn(eltype(D_SBP), size(D_SBP, 1)); du = similar(u);
@show Di_SBP * u â‰ˆ Di_sparse * u â‰ˆ Di_banded * u â‰ˆ Di_full * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>At first, let us benchmark the derivative and dissipation operators implemented in SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)
doit(Di_SBP, &quot;Di_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 66 evaluations.
 Range (min â€¦ max):  786.364 ns â€¦  54.208 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     927.273 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   973.084 ns Â± 696.966 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–…  â–„ â–„ â–ˆâ–‚     â–â–â–â–â–â–  â–                                       â–
  â–ˆâ–ƒâ–â–ˆâ–…â–ˆâ–†â–ˆâ–ˆâ–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–ˆâ–†â–†â–…â–†â–†â–†â–†â–‡â–†â–‡â–†â–†â–†â–†â–†â–…â–…â–…â–…â–…â–…â–„â–ƒâ–„â–„â–…â–…â–…â–„â–„â–…â–„â–â–„ â–ˆ
  786 ns        Histogram: log(frequency) by time       1.88 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
Di_SBP:
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min â€¦ max):  1.840 Î¼s â€¦ 86.330 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     2.160 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   2.227 Î¼s Â±  1.351 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–„  â–„ â–„ â–ˆâ–‚                                                  â–
  â–ˆâ–…â–…â–ˆâ–‡â–ˆâ–‡â–ˆâ–ˆâ–ˆâ–†â–…â–â–†â–…â–…â–…â–…â–„â–„â–„â–ƒâ–„â–…â–…â–…â–†â–…â–…â–…â–…â–†â–†â–…â–†â–†â–‡â–†â–„â–†â–„â–†â–…â–‡â–†â–†â–…â–‡â–†â–…â–…â–„â–„â–…â–…â–…â–†â–† â–ˆ
  1.84 Î¼s      Histogram: log(frequency) by time     4.32 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we compare the results to sparse matrix representations. It will not come as a surprise that these are again much (around an order of magnitude) slower.</p><pre><code class="language-julia hljs">doit(Di_sparse, &quot;Di_sparse:&quot;, du, u)
doit(Di_banded, &quot;Di_banded:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Di_sparse:
BenchmarkTools.Trial: 10000 samples with 5 evaluations.
 Range (min â€¦ max):  6.120 Î¼s â€¦ 215.280 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     6.960 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   8.002 Î¼s Â±   4.205 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆâ–†â–ˆâ–ˆâ–ˆâ–ˆâ–‡â–„ â–  â–„     â–ƒâ–„â–„â–ƒâ–ƒâ–ƒâ–‚â–‚â–‚â–â–       â–â–â–                     â–ƒ
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–…â–ƒâ–…â–…â–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–†â–‡â–‡â–…â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–‡â–†â–†â–…â–†â–„â–‡â–‡â–†â–…â–†â–†â–† â–ˆ
  6.12 Î¼s      Histogram: log(frequency) by time        18 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
Di_banded:
BenchmarkTools.Trial: 10000 samples with 3 evaluations.
 Range (min â€¦ max):   8.700 Î¼s â€¦ 278.767 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):      9.567 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   11.044 Î¼s Â±   5.435 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆâ–†â–‡â–†â–…â–„â–…â–ƒ   â–ƒ        â–‚â–ƒâ–ƒâ–‚â–‚â–â–â– â–â–          â–â–                  â–‚
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–…â–…â–ˆâ–†â–…â–„â–ƒâ–‚â–„â–‚â–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–†â–…â–„â–ƒâ–‚â–„â–†â–‡â–ˆâ–ˆâ–ˆâ–‡â–‡â–†â–†â–†â–‡â–†â–†â–…â–†â–…â–…â–„â–„â–„â–… â–ˆ
  8.7 Î¼s        Histogram: log(frequency) by time      26.5 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, let&#39;s benchmark the same computation if a full (dense) matrix is used to represent the derivative operator. This is obviously a bad idea but ğŸ¤·</p><pre><code class="language-julia hljs">doit(Di_full, &quot;Di_full:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Di_full:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  245.200 Î¼s â€¦   8.487 ms  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     287.001 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   299.537 Î¼s Â± 116.906 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–  â–‚   â–‚â–‚â–â–„â–ˆâ–„â–ˆâ–…â–…â–…â–…â–„â–„â–„â–ƒâ–ƒâ–ƒâ–‚â–‚â–‚â–â–â–                                â–‚
  â–ˆâ–ƒâ–‚â–ˆâ–ˆâ–ˆâ–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–…â–‡â–†â–…â–†â–†â–…â–†â–†â–†â–†â–†â–…â–†â–†â–…â–…â–„â–…â–†â–„â–…â–‚â–„â–… â–ˆ
  245 Î¼s        Histogram: log(frequency) by time        432 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><h2 id="Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)"><a class="docs-heading-anchor" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)">Structure-of-Arrays (SoA) and Array-of-Structures (AoS)</a><a id="Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)" title="Permalink"></a></h2><p><a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a> tries to provide efficient support of</p><ul><li><code>StaticVector</code>s from <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a></li><li><a href="https://github.com/JuliaArrays/StructArrays.jl">StructArrays.jl</a></li></ul><p>To demonstrate this, let us set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using StaticArrays, StructArrays
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

struct Vec5{T} &lt;: FieldVector{5,T}
  x1::T
  x2::T
  x3::T
  x4::T
  x5::T
end

# Apply `mul!` to each component of a plain array of structures one after another
function mul_aos!(du, D, u, args...)
  for i in 1:size(du, 1)
    mul!(view(du, i, :), D, view(u, i, :), args...)
  end
end

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,
                            accuracy_order=4, xmin=xmin, xmax=xmax, N=101)
D_sparse = sparse(D_SBP)
D_full   = Matrix(D_SBP)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">101Ã—101 Matrix{Float64}:
 -141.176    173.529   -23.5294   â€¦    0.0         0.0       0.0
  -50.0        0.0      50.0           0.0         0.0       0.0
    9.30233  -68.6047    0.0           0.0         0.0       0.0
    3.06122    0.0     -60.2041        0.0         0.0       0.0
    0.0        0.0       8.33333       0.0         0.0       0.0
    0.0        0.0       0.0      â€¦    0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    â‹®                             â‹±                          â‹®
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0      â€¦    0.0         0.0       0.0
    0.0        0.0       0.0          -8.33333     0.0       0.0
    0.0        0.0       0.0          60.2041      0.0      -3.06122
    0.0        0.0       0.0           0.0        68.6047   -9.30233
    0.0        0.0       0.0         -50.0         0.0      50.0
    0.0        0.0       0.0      â€¦   23.5294   -173.529   141.176</code></pre><p>At first, we benchmark the application of the operators implemented in SummationByPartsOperators.jl and their representations as sparse and dense matrices in the scalar case. As before, the sparse matrix representation is around an order of magnitude slower and the dense matrix representation is far off.</p><pre><code class="language-julia hljs">println(&quot;Scalar case&quot;)
u = randn(T, size(D_SBP, 1)); du = similar(u)
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_SBP, $u))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_sparse, $u))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_full, $u))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Scalar case
D_SBP
BenchmarkTools.Trial: 10000 samples with 973 evaluations.
 Range (min â€¦ max):  72.662 ns â€¦  3.711 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     84.892 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   87.747 ns Â± 43.690 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–…   â–„  â–„  â–ˆ     â–â–â–â–â–â–â– â–                                   â–
  â–ˆâ–â–…â–„â–ˆâ–†â–…â–ˆâ–„â–„â–ˆâ–‡â–ˆâ–ˆâ–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–‡â–‡â–…â–†â–‡â–†â–‡â–‡â–‡â–‡â–‡â–‡â–‡â–†â–…â–…â–…â–…â–ƒâ–…â–…â–…â–…â–„â–…â–…â–…â–…â–† â–ˆ
  72.7 ns      Histogram: log(frequency) by time       143 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 200 evaluations.
 Range (min â€¦ max):  409.000 ns â€¦   6.876 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     471.000 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   524.625 ns Â± 178.290 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆ
  â–ˆâ–…â–†â–‡â–‡â–…â–‡â–…â–„â–ƒâ–ƒâ–ƒâ–ƒâ–ƒâ–ƒâ–ƒâ–ƒâ–ƒâ–ƒâ–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â– â–‚
  409 ns           Histogram: frequency by time          983 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 9 evaluations.
 Range (min â€¦ max):  2.011 Î¼s â€¦ 86.167 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     2.378 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   2.465 Î¼s Â±  1.300 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ƒ  â–â–„â–‚â–„â–„â–ˆ                                                  â–
  â–ˆâ–ˆâ–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–†â–†â–‡â–…â–…â–‡â–†â–†â–†â–†â–†â–†â–†â–†â–…â–†â–†â–†â–‡â–‡â–†â–†â–†â–†â–…â–†â–‡â–‡â–‡â–‡â–…â–…â–…â–…â–…â–…â–ƒâ–†â–†â–†â–†â–†â–…â–…â–ƒâ–â–… â–ˆ
  2.01 Î¼s      Histogram: log(frequency) by time     4.58 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we use a plain array of structures (AoS) in the form of a two-dimensional array and our custom <code>mul_aos!</code> implementation that loops over each component, using <code>mul!</code> on <code>view</code>s. Here, the differences between the timings are less pronounced.</p><pre><code class="language-julia hljs">println(&quot;Plain Array of Structures&quot;)
u_aos_plain = randn(T, 5, size(D_SBP, 1)); du_aos_plain = similar(u_aos_plain)
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_SBP, $u_aos_plain))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_sparse, $u_aos_plain))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_full, $u_aos_plain))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Plain Array of Structures
D_SBP
BenchmarkTools.Trial: 10000 samples with 9 evaluations.
 Range (min â€¦ max):  2.322 Î¼s â€¦ 135.715 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     2.722 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   2.801 Î¼s Â±   1.777 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–…  â–‚â–‚â–ƒâ–„â–â–ˆ                                                   â–
  â–ˆâ–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–…â–ƒâ–â–â–…â–…â–„â–„â–„â–â–â–â–â–„â–„â–†â–†â–…â–…â–…â–†â–…â–†â–…â–†â–†â–‡â–‡â–†â–…â–†â–†â–…â–†â–†â–…â–…â–†â–†â–†â–ƒâ–…â–…â–…â–„â–…â–…â–…â–…â–† â–ˆ
  2.32 Î¼s      Histogram: log(frequency) by time      5.26 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 9 evaluations.
 Range (min â€¦ max):  2.689 Î¼s â€¦ 108.147 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     2.967 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   3.432 Î¼s Â±   1.624 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆâ–‡â–‡â–‡â–†â–†â–…â–‚   â–„          â–‚â–„â–„â–ƒâ–ƒâ–‚â–â–â–â–â–â–â–         â–â–              â–‚
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–…â–†â–ˆâ–‡â–…â–â–…â–…â–…â–…â–…â–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–…â–„â–ƒâ–…â–ƒâ–…â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–…â–†â–‡â–†â–‡â–†â–†â–… â–ˆ
  2.69 Î¼s      Histogram: log(frequency) by time      8.01 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  10.600 Î¼s â€¦ 309.010 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     12.501 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   13.057 Î¼s Â±   4.984 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–„ â–‚â–„â–…â–„â–ˆ                                                      â–
  â–ˆâ–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–†â–†â–†â–…â–…â–†â–…â–†â–…â–†â–†â–…â–†â–†â–â–…â–„â–…â–…â–†â–…â–…â–…â–†â–†â–†â–†â–†â–†â–…â–…â–†â–†â–…â–†â–‡â–†â–‡â–†â–…â–…â–„â–ƒâ–„â–„â–â–ƒâ–…â–…â–…â–† â–ˆ
  10.6 Î¼s       Histogram: log(frequency) by time      29.5 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Now, we use an array of structures (AoS) based on <code>reinterpret</code> and standard <code>mul!</code>. This is much more efficient for the implementation in SummationByPartsOperators.jl. In Julia v1.6, this is also more efficient for sparse matrices but less efficient for dense matrices (compared to the plain AoS approach with <code>mul_aos!</code> above).</p><pre><code class="language-julia hljs">println(&quot;Array of Structures (reinterpreted array)&quot;)
u_aos_r = reinterpret(reshape, Vec5{T}, u_aos_plain); du_aos_r = similar(u_aos_r)
@show D_SBP * u_aos_r â‰ˆ D_sparse * u_aos_r â‰ˆ D_full * u_aos_r
mul!(du_aos_r, D_SBP, u_aos_r)
@show reinterpret(reshape, T, du_aos_r) â‰ˆ du_aos_plain
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_SBP, $u_aos_r))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_sparse, $u_aos_r))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_full, $u_aos_r))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Array of Structures (reinterpreted array)
D_SBP * u_aos_r â‰ˆ D_sparse * u_aos_r â‰ˆ D_full * u_aos_r = true
reinterpret(reshape, T, du_aos_r) â‰ˆ du_aos_plain = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 216 evaluations.
 Range (min â€¦ max):  343.986 ns â€¦   5.720 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     405.565 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   420.196 ns Â± 135.232 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ƒ   â–ƒ â–‚â–‚ â–ˆâ–â–  â– â–â–â–                                           â–
  â–ˆâ–„â–ƒâ–â–ˆâ–„â–ˆâ–ˆâ–‡â–ˆâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–‡â–‡â–‡â–†â–‡â–‡â–‡â–‡â–†â–†â–†â–‡â–†â–†â–„â–…â–…â–„â–…â–…â–…â–…â–†â–…â–„â–…â–…â–„â–ƒâ–„â–…â–…â–…â–â–„â–ƒ â–ˆ
  344 ns        Histogram: log(frequency) by time        738 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 48 evaluations.
 Range (min â€¦ max):  891.667 ns â€¦  22.294 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):       1.042 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):     1.080 Î¼s Â± 434.363 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–„   â–ƒ â–…  â–ˆ              â–â–                                    â–
  â–ˆâ–â–â–„â–ˆâ–â–ˆâ–„â–…â–ˆâ–‡â–…â–…â–‡â–‡â–…â–†â–‡â–ˆâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–†â–‡â–‡â–†â–†â–†â–…â–†â–…â–„â–…â–…â–…â–†â–†â–…â–…â–…â–†â–†â–…â–†â–…â–„â–…â–…â–… â–ˆ
  892 ns        Histogram: log(frequency) by time       1.87 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  12.600 Î¼s â€¦ 883.902 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     14.800 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   15.324 Î¼s Â±  10.342 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–… â–„â–â–ƒâ–ˆ                                                       â–
  â–ˆâ–‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–†â–„â–…â–…â–…â–…â–…â–…â–…â–„â–…â–„â–„â–‚â–„â–ƒâ–…â–…â–„â–…â–„â–…â–„â–…â–„â–†â–†â–…â–†â–†â–†â–„â–…â–ƒâ–ƒâ–ƒâ–„â–„â–…â–†â–…â–†â–…â–„â–„â–‚â–ƒâ–‚â–ƒâ–‚â–„â–… â–ˆ
  12.6 Î¼s       Histogram: log(frequency) by time      35.8 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we still use an array of structures (AoS), but copy the data into a plain <code>Array</code> instead of using the <code>reinterpret</code>ed versions. There is no significant difference to the previous version in this case.</p><pre><code class="language-julia hljs">println(&quot;Array of Structures&quot;)
u_aos = Array(u_aos_r); du_aos = similar(u_aos)
@show D_SBP * u_aos â‰ˆ D_sparse * u_aos â‰ˆ D_full * u_aos
mul!(du_aos, D_SBP, u_aos)
@show du_aos â‰ˆ du_aos_r
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_SBP, $u_aos))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_sparse, $u_aos))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_full, $u_aos))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Array of Structures
D_SBP * u_aos â‰ˆ D_sparse * u_aos â‰ˆ D_full * u_aos = true
du_aos â‰ˆ du_aos_r = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 223 evaluations.
 Range (min â€¦ max):  332.735 ns â€¦  18.805 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     390.135 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   401.942 ns Â± 218.062 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–„    â–ƒ  â–„  â–ˆâ–‚    â–â–  â–â–â–  â–                                   â–
  â–ˆâ–â–„â–„â–â–ˆâ–â–„â–ˆâ–…â–…â–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–‡â–‡â–†â–‡â–…â–†â–†â–‡â–‡â–†â–†â–†â–‡â–†â–†â–†â–…â–…â–…â–ƒâ–„â–„â–…â–ƒâ–…â–„â–…â–…â–…â–…â–… â–ˆ
  333 ns        Histogram: log(frequency) by time        638 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 11 evaluations.
 Range (min â€¦ max):  945.455 ns â€¦ 107.646 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):       1.109 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):     1.186 Î¼s Â±   1.722 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

    â–ƒâ–â–„â–ˆâ–‚                                                       â–
  â–ˆâ–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„â–ƒâ–ƒâ–„â–â–„â–„â–„â–„â–ƒâ–ƒâ–â–„â–„â–â–ƒâ–ƒâ–„â–ƒâ–â–„â–ƒâ–ƒâ–„â–„â–„â–„â–„â–ƒâ–„â–ƒâ–ƒâ–â–ƒâ–„â–ƒâ–„â–„â–…â–„â–†â–†â–†â–†â–„â–â–ƒâ–â–„â–„â–ƒâ–ƒâ–„â–† â–ˆ
  945 ns        Histogram: log(frequency) by time       2.64 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  13.700 Î¼s â€¦  1.124 ms  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     16.100 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   16.717 Î¼s Â± 12.565 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–  â–‚ â–ƒ â–ˆâ–„                                                   â–
  â–ˆâ–â–â–ˆâ–„â–ˆâ–„â–ˆâ–ˆâ–ˆâ–‡â–†â–†â–…â–„â–…â–†â–…â–„â–†â–…â–„â–…â–†â–…â–„â–…â–…â–„â–†â–†â–…â–†â–†â–†â–…â–…â–†â–…â–ƒâ–…â–…â–…â–…â–„â–…â–…â–†â–†â–„â–…â–„â–„â–ƒâ–ƒâ–â–ƒâ–ƒâ–„ â–ˆ
  13.7 Î¼s      Histogram: log(frequency) by time      31.8 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, let&#39;s look at a structure of arrays (SoA). Interestingly, this is slower than the array of structures we used above. On Julia v1.6, the sparse matrix representation performs particularly bad in this case.</p><pre><code class="language-julia hljs">println(&quot;Structure of Arrays&quot;)
u_soa = StructArray(u_aos); du_soa = similar(u_soa)
@show D_SBP * u_soa â‰ˆ D_sparse * u_soa â‰ˆ D_full * u_soa
mul!(du_soa, D_SBP, u_soa)
@show du_soa â‰ˆ du_aos
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_SBP, $u_soa))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_sparse, $u_soa))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_full, $u_soa))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Structure of Arrays
â”Œ Warning: #= /home/runner/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl/src/SBP_operators.jl:388 =#:
â”‚ `LoopVectorization.check_args` on your inputs failed; running fallback `@inbounds @fastmath` loop instead.
â”‚ Use `warn_check_args=false`, e.g. `@turbo warn_check_args=false ...`, to disable this warning.
â”” @ SummationByPartsOperators ~/.julia/packages/LoopVectorization/kVenK/src/condense_loopset.jl:825
D_SBP * u_soa â‰ˆ D_sparse * u_soa â‰ˆ D_full * u_soa = true
du_soa â‰ˆ du_aos = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 200 evaluations.
 Range (min â€¦ max):  399.500 ns â€¦  16.692 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     469.500 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   486.893 ns Â± 224.985 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–„   â–ƒâ– â–„ â–ˆâ–‡ â– â–â–‚â–â–â–‚â– â–                                        â–‚
  â–ˆâ–â–„â–ƒâ–ˆâ–ˆâ–‡â–ˆâ–…â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–‡â–†â–†â–…â–‡â–ˆâ–†â–‡â–‡â–‡â–‡â–†â–†â–„â–ƒâ–…â–…â–†â–†â–†â–…â–…â–…â–…â–â–„â–ƒâ–„â–…â–â–ƒâ–„â–â–„â–„ â–ˆ
  400 ns        Histogram: log(frequency) by time        829 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 9939 samples with 1 evaluation.
 Range (min â€¦ max):  266.000 Î¼s â€¦ 19.759 ms  â”Š GC (min â€¦ max):  0.00% â€¦ 91.23%
 Time  (median):     413.001 Î¼s              â”Š GC (median):     0.00%
 Time  (mean Â± Ïƒ):   497.516 Î¼s Â±  1.018 ms  â”Š GC (mean Â± Ïƒ):  11.80% Â±  5.67%

       â–„â–‡â–†â–‡â–ˆâ–†â–„â–‚â–‚â– â–   â–â–‚â–â–â–â–
  â–…â–ƒâ–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–†â–‡â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–†â–†â–…â–„â–„â–ƒâ–ƒâ–ƒâ–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â– â–„
  266 Î¼s          Histogram: frequency by time          862 Î¼s &lt;

 Memory estimate: 328.25 KiB, allocs estimate: 10504.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  181.300 Î¼s â€¦ 20.041 ms  â”Š GC (min â€¦ max):  0.00% â€¦ 97.85%
 Time  (median):     303.901 Î¼s              â”Š GC (median):     0.00%
 Time  (mean Â± Ïƒ):   392.896 Î¼s Â±  1.029 ms  â”Š GC (mean Â± Ïƒ):  15.15% Â±  5.70%

     â–‚â–†â–ƒâ–‡â–ˆâ–‡â–‡â–†â–„â–ƒâ–ƒâ–â–          â–â–â–
  â–„â–ƒâ–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–…â–„â–‡â–…â–†â–‡â–ˆâ–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–†â–…â–†â–„â–…â–ƒâ–ƒâ–ƒâ–ƒâ–ƒâ–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–â–â–â–â– â–„
  181 Î¼s          Histogram: frequency by time          646 Î¼s &lt;

 Memory estimate: 328.25 KiB, allocs estimate: 10504.</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../applications/">Â« Applications &amp; references</a><a class="docs-footer-nextpage" href="../api_reference/">API reference Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 13 December 2021 13:06">Monday 13 December 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
