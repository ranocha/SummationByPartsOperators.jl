<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Benchmarks · SummationByPartsOperators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/benchmarks/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SummationByPartsOperators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/constant_linear_advection/">Linear advection equation with constant coefficients</a></li><li><a class="tocitem" href="../tutorials/advection_diffusion/">Linear advection diffusion equation with periodic boundary conditions</a></li><li><a class="tocitem" href="../tutorials/variable_linear_advection/">Linear advection equation with variable coefficients</a></li><li><a class="tocitem" href="../tutorials/wave_equation/">Wave equation</a></li></ul></li><li><a class="tocitem" href="../applications/">Applications &amp; references</a></li><li class="is-active"><a class="tocitem" href>Benchmarks</a><ul class="internal"><li><a class="tocitem" href="#First-derivative-operators"><span>First-derivative operators</span></a></li><li><a class="tocitem" href="#Dissipation-operators"><span>Dissipation operators</span></a></li><li><a class="tocitem" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)"><span>Structure-of-Arrays (SoA) and Array-of-Structures (AoS)</span></a></li></ul></li><li><a class="tocitem" href="../api_reference/">API reference</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Benchmarks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Benchmarks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ranocha/SummationByPartsOperators.jl/blob/master/docs/src/benchmarks.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Benchmarks"><a class="docs-heading-anchor" href="#Benchmarks">Benchmarks</a><a id="Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarks" title="Permalink"></a></h1><p>Here are some simple benchmarks. Take them with a grain of salt since they run on virtual machines in the cloud to generate the documentation automatically.</p><h2 id="First-derivative-operators"><a class="docs-heading-anchor" href="#First-derivative-operators">First-derivative operators</a><a id="First-derivative-operators-1"></a><a class="docs-heading-anchor-permalink" href="#First-derivative-operators" title="Permalink"></a></h2><h4 id="Periodic-domains"><a class="docs-heading-anchor" href="#Periodic-domains">Periodic domains</a><a id="Periodic-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-domains" title="Permalink"></a></h4><p>Let&#39;s set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, DiffEqOperators

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = periodic_derivative_operator(derivative_order=1, accuracy_order=2,
                                     xmin=xmin, xmax=xmax, N=100)
x = grid(D_SBP)
D_DEO = CenteredDifference(derivative_order(D_SBP), accuracy_order(D_SBP),
                           step(x), length(x)) * PeriodicBC(eltype(D_SBP))

D_sparse = sparse(D_SBP)

u = randn(eltype(D_SBP), length(x)); du = similar(u);
@show D_SBP * u ≈ D_DEO * u ≈ D_sparse * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>First, we benchmark the implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 989 evaluations.
 Range (min … max):  45.905 ns …  1.045 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     53.994 ns              ┊ GC (median):    0.00%
 Time  (mean ± σ):   55.893 ns ± 23.190 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▄   ▃▁ ▄ ▅█                                                 ▁
  █▁▁▁██▄█▄██▆▅▇▆▆▅▆▆▇▇▇▇██████▇▇██▇▅▇▇▇▆▆▅▅▃▁▄▄▅▄▅▆▆▅▆▅▅▅▅▄▅ █
  45.9 ns      Histogram: log(frequency) by time      92.7 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we compare this to the runtime obtained using a sparse matrix representation of the derivative operator. Depending on the hardware etc., this can be an order of magnitude slower than the optimized implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_sparse, &quot;D_sparse:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_sparse:
BenchmarkTools.Trial: 10000 samples with 301 evaluations.
 Range (min … max):  275.748 ns …   7.597 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     322.591 ns               ┊ GC (median):    0.00%
 Time  (mean ± σ):   354.765 ns ± 133.490 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  █    ▁
  █▃▅▂██▄▆▁▅▄▃▃▃▃▃▂▄▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  276 ns           Histogram: frequency by time          657 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, we benchmark the implementation of the same derivative operator in DiffEqOperators.jl.</p><pre><code class="language-julia hljs">doit(D_DEO, &quot;D_DEO:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_DEO:
┌ Warning: #= /home/runner/.julia/packages/DiffEqOperators/NwER0/src/derivative_operators/convolutions.jl:375 =#:
│ `LoopVectorization.check_args` on your inputs failed; running fallback `@inbounds @fastmath` loop instead.
│ Use `warn_check_args=false`, e.g. `@turbo warn_check_args=false ...`, to disable this warning.
└ @ DiffEqOperators ~/.julia/packages/LoopVectorization/kVenK/src/condense_loopset.jl:825
┌ Warning: #= /home/runner/.julia/packages/DiffEqOperators/NwER0/src/derivative_operators/convolutions.jl:419 =#:
│ `LoopVectorization.check_args` on your inputs failed; running fallback `@inbounds @fastmath` loop instead.
│ Use `warn_check_args=false`, e.g. `@turbo warn_check_args=false ...`, to disable this warning.
└ @ DiffEqOperators ~/.julia/packages/LoopVectorization/kVenK/src/condense_loopset.jl:825
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min … max):  1.140 μs … 134.530 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     1.380 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   1.585 μs ±   1.677 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▅▃▄▅██▆▅▅▃▃▄▄▃▂▂▂▁                                          ▂
  ███████████████████▇██▇▇██▇█▇██▇████▇█▇▇▇▇▇▆▇▇██▇▆▆▅▅▄▃▄▄▄▅ █
  1.14 μs      Histogram: log(frequency) by time      3.64 μs &lt;

 Memory estimate: 416 bytes, allocs estimate: 6.</code></pre><h4 id="Bounded-domains"><a class="docs-heading-anchor" href="#Bounded-domains">Bounded domains</a><a id="Bounded-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Bounded-domains" title="Permalink"></a></h4><p>We start again by setting up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordström2004(), derivative_order=1,
                            accuracy_order=6, xmin=xmin, xmax=xmax, N=10^3)
D_sparse = sparse(D_SBP)
D_banded = BandedMatrix(D_SBP)

u = randn(eltype(D_SBP), size(D_SBP, 1)); du = similar(u);
@show D_SBP * u ≈ D_sparse * u ≈ D_banded * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>First, we benchmark the implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 85 evaluations.
 Range (min … max):  771.765 ns …  50.079 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     903.529 ns               ┊ GC (median):    0.00%
 Time  (mean ± σ):   941.701 ns ± 721.907 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▅   ▄▁ ▅ █▇ ▁▁  ▂▁ ▁▂▁▁ ▁▁                                    ▂
  █▁▅▄████▄██▆██████████████▇▇▇▆▆▆▆▆▆▆▆▇▇▇▇▇▇▇▆▆▆▅▄▃▅▄▅▅▄▄▅▃▅▄▃ █
  772 ns        Histogram: log(frequency) by time       1.59 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Again, we compare this to a representation of the derivative operator as a sparse matrix. No surprise - it is again much slower, as in periodic domains.</p><pre><code class="language-julia hljs">doit(D_sparse, &quot;D_sparse:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_sparse:
BenchmarkTools.Trial: 10000 samples with 6 evaluations.
 Range (min … max):  5.450 μs … 197.484 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     6.583 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   7.635 μs ±   5.041 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▄▅▆███▆▆▅▆    ▃▃▃▄▄▃▃▂▂▁   ▁▁▁▁▁▁▁▁                         ▃
  ███████████▆▆████████████▇█████████▇█▇▆▇▆▇▇▆▇▆▆▆▆▅▆▄▅▅▁▅▅▃▅ █
  5.45 μs      Histogram: log(frequency) by time      18.6 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>FInally, we compare it to a representation as banded matrix. Disappointingly, this is still much slower than the optimized implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_banded, &quot;D_banded:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_banded:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  11.200 μs … 758.201 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     12.700 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   14.645 μs ±  11.905 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▄▆▇██▆▅▂▄                              ▁▂▂▂▁▁                ▂
  █████████▇▇▅▅▃▃▃▃▄▄▃▄▄▄▃▃▁▁▁▃▃▄▄▄▄▁▄▃▆█████████▇▆▇▇█▆▆▆▇▆▆▆▅ █
  11.2 μs       Histogram: log(frequency) by time      37.9 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><h2 id="Dissipation-operators"><a class="docs-heading-anchor" href="#Dissipation-operators">Dissipation operators</a><a id="Dissipation-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Dissipation-operators" title="Permalink"></a></h2><p>We follow the same structure as before. At first, we set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordström2004(), derivative_order=1,
                            accuracy_order=6, xmin=xmin, xmax=xmax, N=10^3)
Di_SBP  = dissipation_operator(MattssonSvärdNordström2004(), D_SBP)
Di_sparse = sparse(Di_SBP)
Di_banded = BandedMatrix(Di_SBP)
Di_full   = Matrix(Di_SBP)

u = randn(eltype(D_SBP), size(D_SBP, 1)); du = similar(u);
@show Di_SBP * u ≈ Di_sparse * u ≈ Di_banded * u ≈ Di_full * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>At first, let us benchmark the derivative and dissipation operators implemented in SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)
doit(Di_SBP, &quot;Di_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 66 evaluations.
 Range (min … max):  786.364 ns …  54.208 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     927.273 ns               ┊ GC (median):    0.00%
 Time  (mean ± σ):   973.084 ns ± 696.966 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▅  ▄ ▄ █▂     ▁▁▁▁▁▁  ▁                                       ▁
  █▃▁█▅█▆██▆██████████████▇▇█▆▆▅▆▆▆▆▇▆▇▆▆▆▆▆▅▅▅▅▅▅▄▃▄▄▅▅▅▄▄▅▄▁▄ █
  786 ns        Histogram: log(frequency) by time       1.88 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
Di_SBP:
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min … max):  1.840 μs … 86.330 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     2.160 μs              ┊ GC (median):    0.00%
 Time  (mean ± σ):   2.227 μs ±  1.351 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▄  ▄ ▄ █▂                                                  ▁
  █▅▅█▇█▇███▆▅▁▆▅▅▅▅▄▄▄▃▄▅▅▅▆▅▅▅▅▆▆▅▆▆▇▆▄▆▄▆▅▇▆▆▅▇▆▅▅▄▄▅▅▅▆▆ █
  1.84 μs      Histogram: log(frequency) by time     4.32 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we compare the results to sparse matrix representations. It will not come as a surprise that these are again much (around an order of magnitude) slower.</p><pre><code class="language-julia hljs">doit(Di_sparse, &quot;Di_sparse:&quot;, du, u)
doit(Di_banded, &quot;Di_banded:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Di_sparse:
BenchmarkTools.Trial: 10000 samples with 5 evaluations.
 Range (min … max):  6.120 μs … 215.280 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     6.960 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   8.002 μs ±   4.205 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  █▆████▇▄ ▁  ▄     ▃▄▄▃▃▃▂▂▂▁▁       ▁▁▁                     ▃
  ██████████▇██▅▃▅▅▆███████████▇▆▇▇▅▇█████████▇█▇▆▆▅▆▄▇▇▆▅▆▆▆ █
  6.12 μs      Histogram: log(frequency) by time        18 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
Di_banded:
BenchmarkTools.Trial: 10000 samples with 3 evaluations.
 Range (min … max):   8.700 μs … 278.767 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):      9.567 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   11.044 μs ±   5.435 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  █▆▇▆▅▄▅▃   ▃        ▂▃▃▂▂▁▁▁ ▁▁          ▁▁                  ▂
  ████████▆▅▅█▆▅▄▃▂▄▂▆████████████▇▆▅▄▃▂▄▆▇███▇▇▆▆▆▇▆▆▅▆▅▅▄▄▄▅ █
  8.7 μs        Histogram: log(frequency) by time      26.5 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, let&#39;s benchmark the same computation if a full (dense) matrix is used to represent the derivative operator. This is obviously a bad idea but 🤷</p><pre><code class="language-julia hljs">doit(Di_full, &quot;Di_full:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Di_full:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  245.200 μs …   8.487 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     287.001 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   299.537 μs ± 116.906 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▁  ▂   ▂▂▁▄█▄█▅▅▅▅▄▄▄▃▃▃▂▂▂▁▁▁                                ▂
  █▃▂███▆███████████████████████████▇▇▅▇▆▅▆▆▅▆▆▆▆▆▅▆▆▅▅▄▅▆▄▅▂▄▅ █
  245 μs        Histogram: log(frequency) by time        432 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><h2 id="Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)"><a class="docs-heading-anchor" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)">Structure-of-Arrays (SoA) and Array-of-Structures (AoS)</a><a id="Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)" title="Permalink"></a></h2><p><a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a> tries to provide efficient support of</p><ul><li><code>StaticVector</code>s from <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a></li><li><a href="https://github.com/JuliaArrays/StructArrays.jl">StructArrays.jl</a></li></ul><p>To demonstrate this, let us set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using StaticArrays, StructArrays
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

struct Vec5{T} &lt;: FieldVector{5,T}
  x1::T
  x2::T
  x3::T
  x4::T
  x5::T
end

# Apply `mul!` to each component of a plain array of structures one after another
function mul_aos!(du, D, u, args...)
  for i in 1:size(du, 1)
    mul!(view(du, i, :), D, view(u, i, :), args...)
  end
end

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordström2004(), derivative_order=1,
                            accuracy_order=4, xmin=xmin, xmax=xmax, N=101)
D_sparse = sparse(D_SBP)
D_full   = Matrix(D_SBP)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">101×101 Matrix{Float64}:
 -141.176    173.529   -23.5294   …    0.0         0.0       0.0
  -50.0        0.0      50.0           0.0         0.0       0.0
    9.30233  -68.6047    0.0           0.0         0.0       0.0
    3.06122    0.0     -60.2041        0.0         0.0       0.0
    0.0        0.0       8.33333       0.0         0.0       0.0
    0.0        0.0       0.0      …    0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    ⋮                             ⋱                          ⋮
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0      …    0.0         0.0       0.0
    0.0        0.0       0.0          -8.33333     0.0       0.0
    0.0        0.0       0.0          60.2041      0.0      -3.06122
    0.0        0.0       0.0           0.0        68.6047   -9.30233
    0.0        0.0       0.0         -50.0         0.0      50.0
    0.0        0.0       0.0      …   23.5294   -173.529   141.176</code></pre><p>At first, we benchmark the application of the operators implemented in SummationByPartsOperators.jl and their representations as sparse and dense matrices in the scalar case. As before, the sparse matrix representation is around an order of magnitude slower and the dense matrix representation is far off.</p><pre><code class="language-julia hljs">println(&quot;Scalar case&quot;)
u = randn(T, size(D_SBP, 1)); du = similar(u)
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_SBP, $u))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_sparse, $u))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_full, $u))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Scalar case
D_SBP
BenchmarkTools.Trial: 10000 samples with 973 evaluations.
 Range (min … max):  72.662 ns …  3.711 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     84.892 ns              ┊ GC (median):    0.00%
 Time  (mean ± σ):   87.747 ns ± 43.690 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▅   ▄  ▄  █     ▁▁▁▁▁▁▁ ▁                                   ▁
  █▁▅▄█▆▅█▄▄█▇██▇█████████████▇▇▇▇▅▆▇▆▇▇▇▇▇▇▇▆▅▅▅▅▃▅▅▅▅▄▅▅▅▅▆ █
  72.7 ns      Histogram: log(frequency) by time       143 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 200 evaluations.
 Range (min … max):  409.000 ns …   6.876 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     471.000 ns               ┊ GC (median):    0.00%
 Time  (mean ± σ):   524.625 ns ± 178.290 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  █
  █▅▆▇▇▅▇▅▄▃▃▃▃▃▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  409 ns           Histogram: frequency by time          983 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 9 evaluations.
 Range (min … max):  2.011 μs … 86.167 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     2.378 μs              ┊ GC (median):    0.00%
 Time  (mean ± σ):   2.465 μs ±  1.300 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▃  ▁▄▂▄▄█                                                  ▁
  ██▁███████▆▆▆▇▅▅▇▆▆▆▆▆▆▆▆▅▆▆▆▇▇▆▆▆▆▅▆▇▇▇▇▅▅▅▅▅▅▃▆▆▆▆▆▅▅▃▁▅ █
  2.01 μs      Histogram: log(frequency) by time     4.58 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we use a plain array of structures (AoS) in the form of a two-dimensional array and our custom <code>mul_aos!</code> implementation that loops over each component, using <code>mul!</code> on <code>view</code>s. Here, the differences between the timings are less pronounced.</p><pre><code class="language-julia hljs">println(&quot;Plain Array of Structures&quot;)
u_aos_plain = randn(T, 5, size(D_SBP, 1)); du_aos_plain = similar(u_aos_plain)
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_SBP, $u_aos_plain))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_sparse, $u_aos_plain))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_full, $u_aos_plain))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Plain Array of Structures
D_SBP
BenchmarkTools.Trial: 10000 samples with 9 evaluations.
 Range (min … max):  2.322 μs … 135.715 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     2.722 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   2.801 μs ±   1.777 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▅  ▂▂▃▄▁█                                                   ▁
  █▁▁██████▅▃▁▁▅▅▄▄▄▁▁▁▁▄▄▆▆▅▅▅▆▅▆▅▆▆▇▇▆▅▆▆▅▆▆▅▅▆▆▆▃▅▅▅▄▅▅▅▅▆ █
  2.32 μs      Histogram: log(frequency) by time      5.26 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 9 evaluations.
 Range (min … max):  2.689 μs … 108.147 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     2.967 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   3.432 μs ±   1.624 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  █▇▇▇▆▆▅▂   ▄          ▂▄▄▃▃▂▁▁▁▁▁▁▁         ▁▁              ▂
  █████████▅▆█▇▅▁▅▅▅▅▅▆███████████████▆▅▄▃▅▃▅███████▇▅▆▇▆▇▆▆▅ █
  2.69 μs      Histogram: log(frequency) by time      8.01 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  10.600 μs … 309.010 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     12.501 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   13.057 μs ±   4.984 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▄ ▂▄▅▄█                                                      ▁
  █▁██████▇▆▆▆▅▅▆▅▆▅▆▆▅▆▆▁▅▄▅▅▆▅▅▅▆▆▆▆▆▆▅▅▆▆▅▆▇▆▇▆▅▅▄▃▄▄▁▃▅▅▅▆ █
  10.6 μs       Histogram: log(frequency) by time      29.5 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Now, we use an array of structures (AoS) based on <code>reinterpret</code> and standard <code>mul!</code>. This is much more efficient for the implementation in SummationByPartsOperators.jl. In Julia v1.6, this is also more efficient for sparse matrices but less efficient for dense matrices (compared to the plain AoS approach with <code>mul_aos!</code> above).</p><pre><code class="language-julia hljs">println(&quot;Array of Structures (reinterpreted array)&quot;)
u_aos_r = reinterpret(reshape, Vec5{T}, u_aos_plain); du_aos_r = similar(u_aos_r)
@show D_SBP * u_aos_r ≈ D_sparse * u_aos_r ≈ D_full * u_aos_r
mul!(du_aos_r, D_SBP, u_aos_r)
@show reinterpret(reshape, T, du_aos_r) ≈ du_aos_plain
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_SBP, $u_aos_r))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_sparse, $u_aos_r))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_full, $u_aos_r))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Array of Structures (reinterpreted array)
D_SBP * u_aos_r ≈ D_sparse * u_aos_r ≈ D_full * u_aos_r = true
reinterpret(reshape, T, du_aos_r) ≈ du_aos_plain = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 216 evaluations.
 Range (min … max):  343.986 ns …   5.720 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     405.565 ns               ┊ GC (median):    0.00%
 Time  (mean ± σ):   420.196 ns ± 135.232 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▃   ▃ ▂▂ █▁▁  ▁ ▁▁▁                                           ▁
  █▄▃▁█▄██▇███▇██████████▇▇▇▇▇▆▇▇▇▇▆▆▆▇▆▆▄▅▅▄▅▅▅▅▆▅▄▅▅▄▃▄▅▅▅▁▄▃ █
  344 ns        Histogram: log(frequency) by time        738 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 48 evaluations.
 Range (min … max):  891.667 ns …  22.294 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):       1.042 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):     1.080 μs ± 434.363 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▄   ▃ ▅  █              ▁▁                                    ▁
  █▁▁▄█▁█▄▅█▇▅▅▇▇▅▆▇███▇█████▇█████▇▆▇▇▆▆▆▅▆▅▄▅▅▅▆▆▅▅▅▆▆▅▆▅▄▅▅▅ █
  892 ns        Histogram: log(frequency) by time       1.87 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  12.600 μs … 883.902 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     14.800 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   15.324 μs ±  10.342 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▅ ▄▁▃█                                                       ▁
  █▂█████▇▆▄▅▅▅▅▅▅▅▄▅▄▄▂▄▃▅▅▄▅▄▅▄▅▄▆▆▅▆▆▆▄▅▃▃▃▄▄▅▆▅▆▅▄▄▂▃▂▃▂▄▅ █
  12.6 μs       Histogram: log(frequency) by time      35.8 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we still use an array of structures (AoS), but copy the data into a plain <code>Array</code> instead of using the <code>reinterpret</code>ed versions. There is no significant difference to the previous version in this case.</p><pre><code class="language-julia hljs">println(&quot;Array of Structures&quot;)
u_aos = Array(u_aos_r); du_aos = similar(u_aos)
@show D_SBP * u_aos ≈ D_sparse * u_aos ≈ D_full * u_aos
mul!(du_aos, D_SBP, u_aos)
@show du_aos ≈ du_aos_r
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_SBP, $u_aos))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_sparse, $u_aos))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_full, $u_aos))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Array of Structures
D_SBP * u_aos ≈ D_sparse * u_aos ≈ D_full * u_aos = true
du_aos ≈ du_aos_r = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 223 evaluations.
 Range (min … max):  332.735 ns …  18.805 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     390.135 ns               ┊ GC (median):    0.00%
 Time  (mean ± σ):   401.942 ns ± 218.062 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▄    ▃  ▄  █▂    ▁▁  ▁▁▁  ▁                                   ▁
  █▁▄▄▁█▁▄█▅▅████▇▇███████████▇▇▇▇▆▇▅▆▆▇▇▆▆▆▇▆▆▆▅▅▅▃▄▄▅▃▅▄▅▅▅▅▅ █
  333 ns        Histogram: log(frequency) by time        638 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 11 evaluations.
 Range (min … max):  945.455 ns … 107.646 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):       1.109 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):     1.186 μs ±   1.722 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

    ▃▁▄█▂                                                       ▁
  █▁█████▄▃▃▄▁▄▄▄▄▃▃▁▄▄▁▃▃▄▃▁▄▃▃▄▄▄▄▄▃▄▃▃▁▃▄▃▄▄▅▄▆▆▆▆▄▁▃▁▄▄▃▃▄▆ █
  945 ns        Histogram: log(frequency) by time       2.64 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  13.700 μs …  1.124 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     16.100 μs              ┊ GC (median):    0.00%
 Time  (mean ± σ):   16.717 μs ± 12.565 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▁  ▂ ▃ █▄                                                   ▁
  █▁▁█▄█▄███▇▆▆▅▄▅▆▅▄▆▅▄▅▆▅▄▅▅▄▆▆▅▆▆▆▅▅▆▅▃▅▅▅▅▄▅▅▆▆▄▅▄▄▃▃▁▃▃▄ █
  13.7 μs      Histogram: log(frequency) by time      31.8 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, let&#39;s look at a structure of arrays (SoA). Interestingly, this is slower than the array of structures we used above. On Julia v1.6, the sparse matrix representation performs particularly bad in this case.</p><pre><code class="language-julia hljs">println(&quot;Structure of Arrays&quot;)
u_soa = StructArray(u_aos); du_soa = similar(u_soa)
@show D_SBP * u_soa ≈ D_sparse * u_soa ≈ D_full * u_soa
mul!(du_soa, D_SBP, u_soa)
@show du_soa ≈ du_aos
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_SBP, $u_soa))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_sparse, $u_soa))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_full, $u_soa))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Structure of Arrays
┌ Warning: #= /home/runner/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl/src/SBP_operators.jl:388 =#:
│ `LoopVectorization.check_args` on your inputs failed; running fallback `@inbounds @fastmath` loop instead.
│ Use `warn_check_args=false`, e.g. `@turbo warn_check_args=false ...`, to disable this warning.
└ @ SummationByPartsOperators ~/.julia/packages/LoopVectorization/kVenK/src/condense_loopset.jl:825
D_SBP * u_soa ≈ D_sparse * u_soa ≈ D_full * u_soa = true
du_soa ≈ du_aos = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 200 evaluations.
 Range (min … max):  399.500 ns …  16.692 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     469.500 ns               ┊ GC (median):    0.00%
 Time  (mean ± σ):   486.893 ns ± 224.985 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▄   ▃▁ ▄ █▇ ▁ ▁▂▁▁▂▁ ▁                                        ▂
  █▁▄▃██▇█▅██████████████▇██▇▆▆▅▇█▆▇▇▇▇▆▆▄▃▅▅▆▆▆▅▅▅▅▁▄▃▄▅▁▃▄▁▄▄ █
  400 ns        Histogram: log(frequency) by time        829 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 9939 samples with 1 evaluation.
 Range (min … max):  266.000 μs … 19.759 ms  ┊ GC (min … max):  0.00% … 91.23%
 Time  (median):     413.001 μs              ┊ GC (median):     0.00%
 Time  (mean ± σ):   497.516 μs ±  1.018 ms  ┊ GC (mean ± σ):  11.80% ±  5.67%

       ▄▇▆▇█▆▄▂▂▁ ▁   ▁▂▁▁▁▁
  ▅▃▇████████████▇█▆▇▇████████▇▆▆▅▄▄▃▃▃▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▄
  266 μs          Histogram: frequency by time          862 μs &lt;

 Memory estimate: 328.25 KiB, allocs estimate: 10504.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  181.300 μs … 20.041 ms  ┊ GC (min … max):  0.00% … 97.85%
 Time  (median):     303.901 μs              ┊ GC (median):     0.00%
 Time  (mean ± σ):   392.896 μs ±  1.029 ms  ┊ GC (mean ± σ):  15.15% ±  5.70%

     ▂▆▃▇█▇▇▆▄▃▃▁▁          ▁▁▁
  ▄▃▄██████████████▆▅▄▇▅▆▇█▇███████▆▆▅▆▄▅▃▃▃▃▃▂▂▂▂▂▂▂▂▂▁▂▁▁▁▁▁ ▄
  181 μs          Histogram: frequency by time          646 μs &lt;

 Memory estimate: 328.25 KiB, allocs estimate: 10504.</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../applications/">« Applications &amp; references</a><a class="docs-footer-nextpage" href="../api_reference/">API reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 13 December 2021 13:06">Monday 13 December 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
