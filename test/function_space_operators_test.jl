using Test
using LinearAlgebra
using SummationByPartsOperators
using Optim: Optim # to enable loading the function space operator optimization code

if VERSION >= v"1.9"
    @testset "Function space operators" begin
        N = 5
        x_min = -1.0
        x_max = 1.0
        nodes = collect(range(x_min, x_max, length = N))
        source = GlaubitzNordströmÖffner2023()
        for compact in (true, false)
            show(IOContext(devnull, :compact => compact), source)
        end
        let basis_functions = [x -> x^i for i in 0:3]
            D = function_space_operator(basis_functions, nodes, source)
            # Only first-derivative operators are implemented yet
            @test_throws ArgumentError function_space_operator(basis_functions,
                                                               nodes,
                                                               source;
                                                               derivative_order = 2,)

            @test grid(D) ≈ nodes
            @test all(isapprox.(D * ones(N), zeros(N); atol = 1e-13))
            @test D * nodes ≈ ones(N)
            @test D * (nodes .^ 2) ≈ 2 * nodes
            @test D * (nodes .^ 3) ≈ 3 * (nodes .^ 2)
            M = mass_matrix(D)
            @test M * D.D + D.D' * M ≈ mass_matrix_boundary(D)
        end

        let basis_functions = [one, identity, exp]
            D = function_space_operator(basis_functions, nodes, source)

            @test grid(D) ≈ nodes
            @test all(isapprox.(D * ones(N), zeros(N); atol = 1e-13))
            @test D * nodes ≈ ones(N)
            @test D * exp.(nodes) ≈ exp.(nodes)
            M = mass_matrix(D)
            @test M * D.D + D.D' * M ≈ mass_matrix_boundary(D)
        end

        # test non-equidistant nodes generated by `nodes = [0.0, rand(8)..., 1.0]`
        nodes = [
            0.0,
            0.01585580467018155,
            0.18010381213204507,
            0.270467434432868,
            0.37699483985320303,
            0.5600831197666554,
            0.5698824835924449,
            0.623949064816263,
            0.8574665549914025,
            1.0
        ]
        N = length(nodes)
        let basis_functions = [one, identity, exp]
            D = function_space_operator(basis_functions, nodes, source)

            @test grid(D) ≈ nodes
            @test all(isapprox.(D * ones(N), zeros(N); atol = 1e-11))
            @test D * nodes ≈ ones(N)
            @test D * exp.(nodes) ≈ exp.(nodes)
            M = mass_matrix(D)
            @test M * D.D + D.D' * M ≈ mass_matrix_boundary(D)
        end
    end
end
