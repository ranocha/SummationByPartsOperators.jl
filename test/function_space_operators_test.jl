using Test
using LinearAlgebra
using SummationByPartsOperators
using Optim: Optim # to enable loading the function space operator optimization code

if VERSION >= v"1.9"
  @testset "Function space operators" begin
    N = 5
    x_min = -1.0
    x_max = 1.0
    nodes = collect(range(x_min, x_max, length=N))
    source = GlaubitzNordströmÖffner2023()
    for compact in (true, false)
      show(IOContext(devnull, :compact=>compact), source)
    end
    let basis_functions = [x -> x^i for i in 0:3]
      D = function_space_operator(basis_functions, nodes, source)
      # Only first-derivative operators are implemented yet
      @test_throws ArgumentError function_space_operator(basis_functions, nodes, source; derivative_order = 2)

      @test grid(D) ≈ nodes
      @test all(isapprox.(D * ones(N), zeros(N); atol = 1e-13))
      @test D * nodes ≈ ones(N)
      @test D * (nodes .^ 2) ≈ 2 * nodes
      @test D * (nodes .^ 3) ≈ 3 * (nodes .^ 2)
      M = mass_matrix(D)
      @test M * D.D + D.D' * M ≈ mass_matrix_boundary(D)
    end

    let basis_functions = [one, identity, exp]
      D = function_space_operator(basis_functions, nodes, source)

      @test grid(D) ≈ nodes
      @test all(isapprox.(D * ones(N), zeros(N); atol = 1e-13))
      @test D * nodes ≈ ones(N)
      @test D * exp.(nodes) ≈ exp.(nodes)
      M = mass_matrix(D)
      @test M * D.D + D.D' * M ≈ mass_matrix_boundary(D)
    end

    # test non-equidistant nodes generated by `nodes = [0.0, rand(8)..., 1.0]`
    nodes = [0.0, 0.01585580467018155, 0.18010381213204507, 0.270467434432868,
             0.37699483985320303, 0.5600831197666554, 0.5698824835924449, 0.623949064816263,
             0.8574665549914025, 1.0]
    N = length(nodes)
    let basis_functions = [one, identity, exp]
      D = function_space_operator(basis_functions, nodes, source)

      @test grid(D) ≈ nodes
      @test all(isapprox.(D * ones(N), zeros(N); atol = 1e-11))
      @test D * nodes ≈ ones(N)
      @test D * exp.(nodes) ≈ exp.(nodes)
      M = mass_matrix(D)
      @test M * D.D + D.D' * M ≈ mass_matrix_boundary(D)
    end
  end
end
