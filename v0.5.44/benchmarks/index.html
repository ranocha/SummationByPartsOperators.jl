<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Benchmarks · SummationByPartsOperators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/benchmarks/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SummationByPartsOperators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/constant_linear_advection/">Linear advection equation with constant coefficients</a></li><li><a class="tocitem" href="../tutorials/advection_diffusion/">Linear advection diffusion equation with periodic boundary conditions</a></li><li><a class="tocitem" href="../tutorials/variable_linear_advection/">Linear advection equation with variable coefficients</a></li><li><a class="tocitem" href="../tutorials/wave_equation/">Wave equation</a></li><li><a class="tocitem" href="../tutorials/kdv/">Korteweg-de Vries equation</a></li></ul></li><li><a class="tocitem" href="../ad/">Automatic differentiation (AD)</a></li><li><a class="tocitem" href="../applications/">Applications &amp; references</a></li><li class="is-active"><a class="tocitem" href>Benchmarks</a><ul class="internal"><li><a class="tocitem" href="#First-derivative-operators"><span>First-derivative operators</span></a></li><li><a class="tocitem" href="#Dissipation-operators"><span>Dissipation operators</span></a></li><li><a class="tocitem" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)"><span>Structure-of-Arrays (SoA) and Array-of-Structures (AoS)</span></a></li></ul></li><li><a class="tocitem" href="../api_reference/">API reference</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Benchmarks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Benchmarks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ranocha/SummationByPartsOperators.jl/blob/main/docs/src/benchmarks.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Benchmarks"><a class="docs-heading-anchor" href="#Benchmarks">Benchmarks</a><a id="Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarks" title="Permalink"></a></h1><p>Here are some simple benchmarks. Take them with a grain of salt since they run on virtual machines in the cloud to generate the documentation automatically.</p><h2 id="First-derivative-operators"><a class="docs-heading-anchor" href="#First-derivative-operators">First-derivative operators</a><a id="First-derivative-operators-1"></a><a class="docs-heading-anchor-permalink" href="#First-derivative-operators" title="Permalink"></a></h2><h4 id="Periodic-domains"><a class="docs-heading-anchor" href="#Periodic-domains">Periodic domains</a><a id="Periodic-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-domains" title="Permalink"></a></h4><p>Let&#39;s set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, DiffEqOperators

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = periodic_derivative_operator(derivative_order=1, accuracy_order=2,
                                     xmin=xmin, xmax=xmax, N=100)
x = grid(D_SBP)
D_DEO = CenteredDifference(derivative_order(D_SBP), accuracy_order(D_SBP),
                           step(x), length(x)) * PeriodicBC(eltype(D_SBP))

D_sparse = sparse(D_SBP)

u = randn(eltype(D_SBP), length(x)); du = similar(u);
@show D_SBP * u ≈ D_DEO * u ≈ D_sparse * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>First, we benchmark the implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 978 evaluations.
 Range (min … max):  65.953 ns …  6.240 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     71.987 ns              ┊ GC (median):    0.00%
 Time  (mean ± σ):   74.806 ns ± 71.065 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▄▃▃  ▆██▇▂      ▁▁▁▂▁▁                                      ▂
  ███▆▇██████▇▅▆█████████▇▅▆▅▅▅▄▄▄▅▆▇▇▅▅▄▄▄▅▁▄▄▆▆▅▃▅▄▅▄▃▁▄▄▅▅ █
  66 ns        Histogram: log(frequency) by time       116 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we compare this to the runtime obtained using a sparse matrix representation of the derivative operator. Depending on the hardware etc., this can be an order of magnitude slower than the optimized implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_sparse, &quot;D_sparse:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_sparse:
BenchmarkTools.Trial: 10000 samples with 219 evaluations.
 Range (min … max):  339.283 ns …  21.104 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     390.429 ns               ┊ GC (median):    0.00%
 Time  (mean ± σ):   414.066 ns ± 240.047 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▂   ▂ ▂  █ ▁   ▁▁▁▂▃       ▁▁▁                                ▁
  █▁▅▁█▃██▄████▅████████▇▇▇██████▆▇▇▆▇▇▇▇▆▇▆▅▅▅▅▅▅▅▆▆▆▅▄▄▅▅▄▆▅▄ █
  339 ns        Histogram: log(frequency) by time        667 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, we benchmark the implementation of the same derivative operator in DiffEqOperators.jl.</p><pre><code class="language-julia hljs">doit(D_DEO, &quot;D_DEO:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_DEO:
┌ Warning: #= /home/runner/.julia/packages/DiffEqOperators/lHq9u/src/derivative_operators/convolutions.jl:412 =#:
│ `LoopVectorization.check_args` on your inputs failed; running fallback `@inbounds @fastmath` loop instead.
│ Use `warn_check_args=false`, e.g. `@turbo warn_check_args=false ...`, to disable this warning.
└ @ DiffEqOperators ~/.julia/packages/LoopVectorization/xHfLl/src/condense_loopset.jl:1148
┌ Warning: #= /home/runner/.julia/packages/DiffEqOperators/lHq9u/src/derivative_operators/convolutions.jl:460 =#:
│ `LoopVectorization.check_args` on your inputs failed; running fallback `@inbounds @fastmath` loop instead.
│ Use `warn_check_args=false`, e.g. `@turbo warn_check_args=false ...`, to disable this warning.
└ @ DiffEqOperators ~/.julia/packages/LoopVectorization/xHfLl/src/condense_loopset.jl:1148
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min … max):  1.140 μs … 73.913 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     1.270 μs              ┊ GC (median):    0.00%
 Time  (mean ± σ):   1.381 μs ±  1.079 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

      ▆█▆▆▅▅▄▄▃▂▂▁▃▄▃▂▃▃▂▂▂▁▁▁ ▁                             ▂
  ▇▇▇▆███████████████████████████▇▇▆▆▆▆▅▄▅▁▄▃▆▃▃▄▃▅▁▃▃▁▅▃▃▁▃ █
  1.14 μs      Histogram: log(frequency) by time     2.27 μs &lt;

 Memory estimate: 416 bytes, allocs estimate: 6.</code></pre><p>These results were obtained using the following versions.</p><pre><code class="language-julia hljs">using InteractiveUtils
versioninfo()

using Pkg
Pkg.status([&quot;SummationByPartsOperators&quot;, &quot;DiffEqOperators&quot;],
           mode=PKGMODE_MANIFEST)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.6.7
Commit 3b76b25b64 (2022-07-19 15:11 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Xeon(R) CPU E5-2673 v3 @ 2.40GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-11.0.1 (ORCJIT, haswell)
Environment:
  JULIA_PKG_SERVER_REGISTRY_PREFERENCE = eager
      Status `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl/docs/Manifest.toml`
  [9fdde737] DiffEqOperators v4.45.0
  [9f78cca6] SummationByPartsOperators v0.5.44 `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl`</code></pre><h4 id="Bounded-domains"><a class="docs-heading-anchor" href="#Bounded-domains">Bounded domains</a><a id="Bounded-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Bounded-domains" title="Permalink"></a></h4><p>We start again by setting up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordström2004(), derivative_order=1,
                            accuracy_order=6, xmin=xmin, xmax=xmax, N=10^3)
D_sparse = sparse(D_SBP)
D_banded = BandedMatrix(D_SBP)

u = randn(eltype(D_SBP), size(D_SBP, 1)); du = similar(u);
@show D_SBP * u ≈ D_sparse * u ≈ D_banded * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>First, we benchmark the implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 131 evaluations.
 Range (min … max):  681.702 ns …  33.301 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     734.382 ns               ┊ GC (median):    0.00%
 Time  (mean ± σ):   769.957 ns ± 455.078 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

       █▂▁  ▄▂                                                  ▁
  ▆▁▁▁▅███▆▆██▇██▇▇▆▅▅▆▆▄▆▆▄▅▄▆▅▆▆▆▅▅▄▅▄▅▅▄▄▅▄▅▅▃▄▄▄▃▅▄▄▃▅▃▄▃▄▅ █
  682 ns        Histogram: log(frequency) by time       1.28 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Again, we compare this to a representation of the derivative operator as a sparse matrix. No surprise - it is again much slower, as in periodic domains.</p><pre><code class="language-julia hljs">doit(D_sparse, &quot;D_sparse:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_sparse:
BenchmarkTools.Trial: 10000 samples with 4 evaluations.
 Range (min … max):  7.175 μs … 196.433 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     7.275 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   7.592 μs ±   3.815 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  █▇     ▃▁                                                   ▁
  ██▇▅▄▁▄██▆▅▄▁▁▃▁▄▅▅▃▁▅▁▁▄▄▃▅▁▃▅▅▃▅▄▃▅▄▄▄▄▁▄▄▃▄▅▃▅▄▃▄▅▅▅▄▄▅▃ █
  7.18 μs      Histogram: log(frequency) by time      14.1 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>FInally, we compare it to a representation as banded matrix. Disappointingly, this is still much slower than the optimized implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_banded, &quot;D_banded:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_banded:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  13.900 μs …  1.814 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     14.901 μs              ┊ GC (median):    0.00%
 Time  (mean ± σ):   15.607 μs ± 19.462 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

     █▇                                                       ▁
  ▅▄▃████▅▆▅▅▃▃▁▃▅▆▄▁▁▁▁▁▁▁▁▁▁▁▁▁▃▁▄▁▁▄▃▁▃▁▄▃▁▁▄▄▃▁▁▁▁▄▁▄▃▃▄▆ █
  13.9 μs      Histogram: log(frequency) by time        30 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>These results were obtained using the following versions.</p><pre><code class="language-julia hljs">using InteractiveUtils
versioninfo()

using Pkg
Pkg.status([&quot;SummationByPartsOperators&quot;, &quot;BandedMatrices&quot;],
           mode=PKGMODE_MANIFEST)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.6.7
Commit 3b76b25b64 (2022-07-19 15:11 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Xeon(R) CPU E5-2673 v3 @ 2.40GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-11.0.1 (ORCJIT, haswell)
Environment:
  JULIA_PKG_SERVER_REGISTRY_PREFERENCE = eager
      Status `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl/docs/Manifest.toml`
  [aae01518] BandedMatrices v0.17.18
  [9f78cca6] SummationByPartsOperators v0.5.44 `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl`</code></pre><h2 id="Dissipation-operators"><a class="docs-heading-anchor" href="#Dissipation-operators">Dissipation operators</a><a id="Dissipation-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Dissipation-operators" title="Permalink"></a></h2><p>We follow the same structure as before. At first, we set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordström2004(), derivative_order=1,
                            accuracy_order=6, xmin=xmin, xmax=xmax, N=10^3)
Di_SBP  = dissipation_operator(MattssonSvärdNordström2004(), D_SBP)
Di_sparse = sparse(Di_SBP)
Di_banded = BandedMatrix(Di_SBP)
Di_full   = Matrix(Di_SBP)

u = randn(eltype(D_SBP), size(D_SBP, 1)); du = similar(u);
@show Di_SBP * u ≈ Di_sparse * u ≈ Di_banded * u ≈ Di_full * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>At first, let us benchmark the derivative and dissipation operators implemented in SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)
doit(Di_SBP, &quot;Di_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 89 evaluations.
 Range (min … max):  805.652 ns … 98.579 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     815.775 ns              ┊ GC (median):    0.00%
 Time  (mean ± σ):   867.935 ns ±  1.432 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▇█▂   ▃▄                                                     ▁
  ███▄█▇███▅▆▆▄▄▄▄▆▅▆▄▆▅▄▄▄▆▄▅▅▅▅▄▄▄▄▄▄▃▄▄▃▄▃▄▃▃▃▂▅▂▄▄▃▄▃▃▃▃▄▃ █
  806 ns        Histogram: log(frequency) by time      1.32 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
Di_SBP:
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min … max):  1.840 μs …  26.981 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     1.980 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   2.040 μs ± 687.137 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

        ▃█▁    ▄▃                                             ▁
  █▃▁▁▁▃███▄█▄▁██▄▆▅▅▄▆▆▅▆▄▄▄▃▄▁▁▃▄▁▁▄▁▁▄▁▃▁▃▁▃▁▁▄▃▃▁▃▃▁▃▃▁▃▃ █
  1.84 μs      Histogram: log(frequency) by time      2.96 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we compare the results to sparse matrix representations. It will not come as a surprise that these are again much (around an order of magnitude) slower.</p><pre><code class="language-julia hljs">doit(Di_sparse, &quot;Di_sparse:&quot;, du, u)
doit(Di_banded, &quot;Di_banded:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Di_sparse:
BenchmarkTools.Trial: 10000 samples with 4 evaluations.
 Range (min … max):  7.700 μs … 131.180 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     8.300 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   8.556 μs ±   2.797 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

    ▁▂ █▆                                                     ▁
  ▇▃██▅██▇▅▄▅▅▄▇▆▆▅▅▅▄▃▅▅▆▅▅▄▃▅▅▆▆▇▇▇▆▅▅▅▅▄▄▁▁▄▄▃▁▃▄▁▃▃▁▃▁▁▃▅ █
  7.7 μs       Histogram: log(frequency) by time      13.9 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
Di_banded:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  10.700 μs … 302.913 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     12.400 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   12.687 μs ±   5.708 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

                     ▂█ █▄                                     ▂
  ▇▆▁▁▁▁▁▁▁▅▇▄▁▁▅█▆▁▁██▁███▁▇▆▆▃▄▆▄▅▁▅▆▇▁███▁▇▆▇▇▁▇▆▆▁▅▅▄▁▁▄▅▃ █
  10.7 μs       Histogram: log(frequency) by time      15.3 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, let&#39;s benchmark the same computation if a full (dense) matrix is used to represent the derivative operator. This is obviously a bad idea but 🤷</p><pre><code class="language-julia hljs">doit(Di_full, &quot;Di_full:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Di_full:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  242.410 μs …  5.526 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     258.511 μs              ┊ GC (median):    0.00%
 Time  (mean ± σ):   267.132 μs ± 64.997 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▅  █▆▅▄▃▂▃▂    ▁                                             ▂
  █▇▄██████████████▇▇▇▇▇▇▇▇▆▆▆▆▆▅▄▆▅▄▅▃▅▃▄▃▄▁▄▄▄▄▃▃▃▁▁▁▁▄▄▃▁▄▄ █
  242 μs        Histogram: log(frequency) by time       490 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>These results were obtained using the following versions.</p><pre><code class="language-julia hljs">using InteractiveUtils
versioninfo()

using Pkg
Pkg.status([&quot;SummationByPartsOperators&quot;, &quot;BandedMatrices&quot;],
           mode=PKGMODE_MANIFEST)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.6.7
Commit 3b76b25b64 (2022-07-19 15:11 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Xeon(R) CPU E5-2673 v3 @ 2.40GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-11.0.1 (ORCJIT, haswell)
Environment:
  JULIA_PKG_SERVER_REGISTRY_PREFERENCE = eager
      Status `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl/docs/Manifest.toml`
  [aae01518] BandedMatrices v0.17.18
  [9f78cca6] SummationByPartsOperators v0.5.44 `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl`</code></pre><h2 id="Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)"><a class="docs-heading-anchor" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)">Structure-of-Arrays (SoA) and Array-of-Structures (AoS)</a><a id="Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)" title="Permalink"></a></h2><p><a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a> tries to provide efficient support of</p><ul><li><code>StaticVector</code>s from <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a></li><li><a href="https://github.com/JuliaArrays/StructArrays.jl">StructArrays.jl</a></li></ul><p>To demonstrate this, let us set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using StaticArrays, StructArrays
using LinearAlgebra, SparseArrays
using SummationByPartsOperators

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

struct Vec5{T} &lt;: FieldVector{5,T}
  x1::T
  x2::T
  x3::T
  x4::T
  x5::T
end

# Apply `mul!` to each component of a plain array of structures one after another
function mul_aos!(du, D, u, args...)
  for i in 1:size(du, 1)
    mul!(view(du, i, :), D, view(u, i, :), args...)
  end
end

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordström2004(), derivative_order=1,
                            accuracy_order=4, xmin=xmin, xmax=xmax, N=101)
D_sparse = sparse(D_SBP)
D_full   = Matrix(D_SBP)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">101×101 Matrix{Float64}:
 -141.176    173.529   -23.5294   …    0.0         0.0       0.0
  -50.0        0.0      50.0           0.0         0.0       0.0
    9.30233  -68.6047    0.0           0.0         0.0       0.0
    3.06122    0.0     -60.2041        0.0         0.0       0.0
    0.0        0.0       8.33333       0.0         0.0       0.0
    0.0        0.0       0.0      …    0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    ⋮                             ⋱                          ⋮
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0      …    0.0         0.0       0.0
    0.0        0.0       0.0          -8.33333     0.0       0.0
    0.0        0.0       0.0          60.2041      0.0      -3.06122
    0.0        0.0       0.0           0.0        68.6047   -9.30233
    0.0        0.0       0.0         -50.0         0.0      50.0
    0.0        0.0       0.0      …   23.5294   -173.529   141.176</code></pre><p>At first, we benchmark the application of the operators implemented in SummationByPartsOperators.jl and their representations as sparse and dense matrices in the scalar case. As before, the sparse matrix representation is around an order of magnitude slower and the dense matrix representation is far off.</p><pre><code class="language-julia hljs">println(&quot;Scalar case&quot;)
u = randn(T, size(D_SBP, 1)); du = similar(u)
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_SBP, $u))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_sparse, $u))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_full, $u))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Scalar case
D_SBP
BenchmarkTools.Trial: 10000 samples with 976 evaluations.
 Range (min … max):  67.830 ns …  5.713 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     72.954 ns              ┊ GC (median):    0.00%
 Time  (mean ± σ):   75.917 ns ± 63.512 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

       █▅                                                     ▁
  ▇▆▃▁▁████▆▄▇▆▇▆▅█▇▇▆▅▅▄▆▄▅▇▆▅▆▄▅▅▄▄▄▄▄▄▄▄▄▅▅▄▄▄▆▄▅▄▄▄▄▅▅▅▃▄ █
  67.8 ns      Histogram: log(frequency) by time       125 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 195 evaluations.
 Range (min … max):  478.990 ns …  15.802 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     550.795 ns               ┊ GC (median):    0.00%
 Time  (mean ± σ):   579.436 ns ± 230.094 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

      ▁ ▁ █▂▁ ▁ ▁▂▁    ▁▁                                       ▁
  █▁▁▄█▁█▆███▆██████▇▇████▇▆▇▇▇█▇▇▆▆▆▆▇▆▅▆▆▅▆▆▆▄▅▅▅▅▅▄▅▅▅▄▄▄▄▅▅ █
  479 ns        Histogram: log(frequency) by time        976 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min … max):  1.850 μs …  40.982 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     2.010 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   2.067 μs ± 885.182 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▃    ▃█▄▄                                                   ▁
  ██▇▁▁████▇▆▄▅▅▄▁▁▄▆▅▅▅▃▁▁▄▁▁▃▁▃▁▄▁▁▃▅▅▃▃▃▃▁▁▁▁▁▁▄▅▅▅▅▇▆▆▆▆▆ █
  1.85 μs      Histogram: log(frequency) by time      3.23 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we use a plain array of structures (AoS) in the form of a two-dimensional array and our custom <code>mul_aos!</code> implementation that loops over each component, using <code>mul!</code> on <code>view</code>s. Here, the differences between the timings are less pronounced.</p><pre><code class="language-julia hljs">println(&quot;Plain Array of Structures&quot;)
u_aos_plain = randn(T, 5, size(D_SBP, 1)); du_aos_plain = similar(u_aos_plain)
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_SBP, $u_aos_plain))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_sparse, $u_aos_plain))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_full, $u_aos_plain))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Plain Array of Structures
D_SBP
BenchmarkTools.Trial: 10000 samples with 9 evaluations.
 Range (min … max):  2.233 μs … 54.402 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     2.400 μs              ┊ GC (median):    0.00%
 Time  (mean ± σ):   2.481 μs ±  1.152 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▃    ▄█                                                    ▁
  █▁▁▁▁██▅▄▃▃▄▁▁▃▃▆▅▄▃▁▁▁▁▁▁▁▁▃▁▃▆▃▃▃▃▃▁▄▁▁▁▁▁▃▄▄▆▅▇▆▆▆▇▆▅▄▃ █
  2.23 μs      Histogram: log(frequency) by time     3.84 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 8 evaluations.
 Range (min … max):  3.238 μs … 92.279 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     3.750 μs              ┊ GC (median):    0.00%
 Time  (mean ± σ):   4.051 μs ±  2.500 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▅ ▃▂▄█▆             ▂▃▂               ▁                    ▁
  █▇█████▄▅█▅▃▁▁▃▇████████▆▅▅▃▅▄▆▁▄▆▆▇▇██▇▆▆▅▅▄▆▅▄▅▄▄▃▄▅▆▅▅▄ █
  3.24 μs      Histogram: log(frequency) by time     8.29 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  10.200 μs … 296.812 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     11.001 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   11.318 μs ±   6.108 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▄  ▄█
  █▃▂██▅▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▁▁▁▁▂▁▁▁▁▁▁▁▂▂▂▂▂▁▂▂▁▁▂▁▁▁▁▁▁▁▁▁▂▂▂▂▂▂▂ ▂
  10.2 μs         Histogram: frequency by time         22.9 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Now, we use an array of structures (AoS) based on <code>reinterpret</code> and standard <code>mul!</code>. This is much more efficient for the implementation in SummationByPartsOperators.jl. In Julia v1.6, this is also more efficient for sparse matrices but less efficient for dense matrices (compared to the plain AoS approach with <code>mul_aos!</code> above).</p><pre><code class="language-julia hljs">println(&quot;Array of Structures (reinterpreted array)&quot;)
u_aos_r = reinterpret(reshape, Vec5{T}, u_aos_plain); du_aos_r = similar(u_aos_r)
@show D_SBP * u_aos_r ≈ D_sparse * u_aos_r ≈ D_full * u_aos_r
mul!(du_aos_r, D_SBP, u_aos_r)
@show reinterpret(reshape, T, du_aos_r) ≈ du_aos_plain
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_SBP, $u_aos_r))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_sparse, $u_aos_r))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_full, $u_aos_r))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Array of Structures (reinterpreted array)
D_SBP * u_aos_r ≈ D_sparse * u_aos_r ≈ D_full * u_aos_r = true
reinterpret(reshape, T, du_aos_r) ≈ du_aos_plain = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 207 evaluations.
 Range (min … max):  363.783 ns …   3.582 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     391.324 ns               ┊ GC (median):    0.00%
 Time  (mean ± σ):   406.761 ns ± 104.210 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▄   █▅▁▁  ▁▁▁▁▂▁                                              ▁
  █▃▄▁████▆▇██████▇▆▆▆▅▆▆▇█▆▆▅▅▆▅▆▄▆▄▆▅▅▅▅▄▅▄▄▄▄▅▄▄▄▄▄▅▅▅▅▄▄▅▄▅ █
  364 ns        Histogram: log(frequency) by time        707 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 41 evaluations.
 Range (min … max):  904.902 ns …  46.063 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     975.659 ns               ┊ GC (median):    0.00%
 Time  (mean ± σ):     1.024 μs ± 629.244 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▃  █▇                                                         ▁
  █▁▁██▃▁█▅▁▃▅▆▅▄▆▇███▅▆▅▄▄▁▅▃▃▁▇▆▆▆▄▅▅▃▅▅▄▅▅▄▄▃▄▄▁▅▁▄▅▅▅▄▅▄▅▃▄ █
  905 ns        Histogram: log(frequency) by time       2.01 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  13.000 μs …  7.032 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     14.001 μs              ┊ GC (median):    0.00%
 Time  (mean ± σ):   15.696 μs ± 72.484 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▅█▅▂                                                        ▁
  ████▆▇▆▆▅▁▄▃▄▃▅▃▃▃▁▁▄▇▇█▇▃▁▃▄▄▃▃▄▃▃▃▁▁▁▃▄▁▁▆▆▆▆▅▄▅▁▃▃▄▃▃▁▄▆ █
  13 μs        Histogram: log(frequency) by time        45 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we still use an array of structures (AoS), but copy the data into a plain <code>Array</code> instead of using the <code>reinterpret</code>ed versions. There is no significant difference to the previous version in this case.</p><pre><code class="language-julia hljs">println(&quot;Array of Structures&quot;)
u_aos = Array(u_aos_r); du_aos = similar(u_aos)
@show D_SBP * u_aos ≈ D_sparse * u_aos ≈ D_full * u_aos
mul!(du_aos, D_SBP, u_aos)
@show du_aos ≈ du_aos_r
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_SBP, $u_aos))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_sparse, $u_aos))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_full, $u_aos))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Array of Structures
D_SBP * u_aos ≈ D_sparse * u_aos ≈ D_full * u_aos = true
du_aos ≈ du_aos_r = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 266 evaluations.
 Range (min … max):  292.492 ns …  15.356 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     315.801 ns               ┊ GC (median):    0.00%
 Time  (mean ± σ):   336.003 ns ± 179.630 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▆  █▅▁ ▁▂▂▃▁                                                  ▁
  █▆▄███▇██████▆▅▅██▇▆▆▆▇▇▆▅▆▆▇▆▆▅▅▇▆▆▄▅▆▇▆▅▄▆▆▅▆▆▅▆▅▆▆▅▄▅▄▅▄▃▄ █
  292 ns        Histogram: log(frequency) by time        666 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min … max):  1.080 μs …  33.521 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     1.090 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   1.131 μs ± 699.094 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

    █
  ▂▁█▁▆▁▂▁▂▁▂▁▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▂▁▁▁▁▁▂▁▂ ▂
  1.08 μs         Histogram: frequency by time        1.36 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  14.800 μs … 445.819 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     14.901 μs               ┊ GC (median):    0.00%
 Time  (mean ± σ):   15.331 μs ±   8.192 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▅ █ ▅ ▁                                                      ▁
  █▁█▁█▁█▁▇▁▇▁▇▁▅▁▅▁▄▁▅▁▁▁▁▁▁▁▁▁▁▁▁▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃▁▄▁▄ █
  14.8 μs       Histogram: log(frequency) by time      17.7 μs &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, let&#39;s look at a structure of arrays (SoA). Interestingly, this is slower than the array of structures we used above. On Julia v1.6, the sparse matrix representation performs particularly bad in this case.</p><pre><code class="language-julia hljs">println(&quot;Structure of Arrays&quot;)
u_soa = StructArray(u_aos); du_soa = similar(u_soa)
@show D_SBP * u_soa ≈ D_sparse * u_soa ≈ D_full * u_soa
mul!(du_soa, D_SBP, u_soa)
@show du_soa ≈ du_aos
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_SBP, $u_soa))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_sparse, $u_soa))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_full, $u_soa))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Structure of Arrays
D_SBP * u_soa ≈ D_sparse * u_soa ≈ D_full * u_soa = true
du_soa ≈ du_aos = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 200 evaluations.
 Range (min … max):  373.015 ns …  17.079 μs  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     402.515 ns               ┊ GC (median):    0.00%
 Time  (mean ± σ):   414.678 ns ± 188.932 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%

       ▄█▅▁                                                     ▁
  ▅▄▁▁▁█████▆▅▇▆▆▆▅▇▇▇▆▅▅▆▆▅▅▆▄▆▅▅▅▅▅▅▅▄▄▅▅▅▄▅▅▅▄▁▄▅▅▃▅▄▃▄▃▄▄▅▄ █
  373 ns        Histogram: log(frequency) by time        660 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 9759 samples with 1 evaluation.
 Range (min … max):  312.013 μs …  20.983 ms  ┊ GC (min … max):  0.00% … 97.26%
 Time  (median):     405.617 μs               ┊ GC (median):     0.00%
 Time  (mean ± σ):   506.387 μs ± 893.390 μs  ┊ GC (mean ± σ):  11.46% ±  6.36%

          █
  ▂▁▂▂▂▃▄██▇▇▆▄▄▃▂▂▂▂▂▁▁▁▁▁▁▅▄▃▃▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  312 μs           Histogram: frequency by time          854 μs &lt;

 Memory estimate: 328.25 KiB, allocs estimate: 10504.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  201.409 μs …  22.644 ms  ┊ GC (min … max):  0.00% … 57.71%
 Time  (median):     270.711 μs               ┊ GC (median):     0.00%
 Time  (mean ± σ):   363.892 μs ± 876.916 μs  ┊ GC (mean ± σ):  15.32% ±  6.35%

      ▅   ▆█▂
  ▄▃▃▄█▇▇▇███▇▆▅▅▄▃▃▃▂▂▃▂▂▃▄▃▃▃▃▃▆▆▄▄▃▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂ ▃
  201 μs           Histogram: frequency by time          620 μs &lt;

 Memory estimate: 328.25 KiB, allocs estimate: 10504.</code></pre><p>These results were obtained using the following versions.</p><pre><code class="language-julia hljs">using InteractiveUtils
versioninfo()

using Pkg
Pkg.status([&quot;SummationByPartsOperators&quot;, &quot;StaticArrays&quot;, &quot;StructArrays&quot;],
           mode=PKGMODE_MANIFEST)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.6.7
Commit 3b76b25b64 (2022-07-19 15:11 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Xeon(R) CPU E5-2673 v3 @ 2.40GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-11.0.1 (ORCJIT, haswell)
Environment:
  JULIA_PKG_SERVER_REGISTRY_PREFERENCE = eager
      Status `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl/docs/Manifest.toml`
  [90137ffa] StaticArrays v1.6.2
  [09ab397b] StructArrays v0.6.15
  [9f78cca6] SummationByPartsOperators v0.5.44 `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl`</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../applications/">« Applications &amp; references</a><a class="docs-footer-nextpage" href="../api_reference/">API reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 11 August 2023 12:50">Friday 11 August 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
