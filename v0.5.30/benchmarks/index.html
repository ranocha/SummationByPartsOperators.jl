<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Benchmarks Â· SummationByPartsOperators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/benchmarks/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SummationByPartsOperators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/constant_linear_advection/">Linear advection equation with constant coefficients</a></li><li><a class="tocitem" href="../tutorials/advection_diffusion/">Linear advection diffusion equation with periodic boundary conditions</a></li><li><a class="tocitem" href="../tutorials/variable_linear_advection/">Linear advection equation with variable coefficients</a></li><li><a class="tocitem" href="../tutorials/wave_equation/">Wave equation</a></li><li><a class="tocitem" href="../tutorials/kdv/">Korteweg-de Vries equation</a></li></ul></li><li><a class="tocitem" href="../applications/">Applications &amp; references</a></li><li class="is-active"><a class="tocitem" href>Benchmarks</a><ul class="internal"><li><a class="tocitem" href="#First-derivative-operators"><span>First-derivative operators</span></a></li><li><a class="tocitem" href="#Dissipation-operators"><span>Dissipation operators</span></a></li><li><a class="tocitem" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)"><span>Structure-of-Arrays (SoA) and Array-of-Structures (AoS)</span></a></li></ul></li><li><a class="tocitem" href="../api_reference/">API reference</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Benchmarks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Benchmarks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ranocha/SummationByPartsOperators.jl/blob/main/docs/src/benchmarks.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Benchmarks"><a class="docs-heading-anchor" href="#Benchmarks">Benchmarks</a><a id="Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarks" title="Permalink"></a></h1><p>Here are some simple benchmarks. Take them with a grain of salt since they run on virtual machines in the cloud to generate the documentation automatically.</p><h2 id="First-derivative-operators"><a class="docs-heading-anchor" href="#First-derivative-operators">First-derivative operators</a><a id="First-derivative-operators-1"></a><a class="docs-heading-anchor-permalink" href="#First-derivative-operators" title="Permalink"></a></h2><h4 id="Periodic-domains"><a class="docs-heading-anchor" href="#Periodic-domains">Periodic domains</a><a id="Periodic-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-domains" title="Permalink"></a></h4><p>Let&#39;s set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, DiffEqOperators

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = periodic_derivative_operator(derivative_order=1, accuracy_order=2,
                                     xmin=xmin, xmax=xmax, N=100)
x = grid(D_SBP)
D_DEO = CenteredDifference(derivative_order(D_SBP), accuracy_order(D_SBP),
                           step(x), length(x)) * PeriodicBC(eltype(D_SBP))

D_sparse = sparse(D_SBP)

u = randn(eltype(D_SBP), length(x)); du = similar(u);
@show D_SBP * u â‰ˆ D_DEO * u â‰ˆ D_sparse * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>First, we benchmark the implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 994 evaluations.
 Range (min â€¦ max):  26.662 ns â€¦ 73.144 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     33.302 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   35.063 ns Â±  3.855 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

           â–    â–â–ˆâ–„    â–‚â–…      â–â–…â–‚                            â–
  â–†â–â–â–â–â–â–â–â–â–ˆâ–‡â–â–â–â–ˆâ–ˆâ–ˆâ–â–„â–†â–†â–ˆâ–ˆâ–…â–â–â–…â–†â–†â–ˆâ–ˆâ–ˆâ–ƒâ–â–…â–„â–„â–…â–…â–…â–ƒâ–ƒâ–„â–â–ƒâ–…â–†â–†â–‡â–‡â–†â–‡â–†â–‡â–†â–†â–‡â–†â–† â–ˆ
  26.7 ns      Histogram: log(frequency) by time      51.5 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we compare this to the runtime obtained using a sparse matrix representation of the derivative operator. Depending on the hardware etc., this can be an order of magnitude slower than the optimized implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_sparse, &quot;D_sparse:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_sparse:
BenchmarkTools.Trial: 10000 samples with 214 evaluations.
 Range (min â€¦ max):  347.687 ns â€¦ 727.621 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     431.804 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   431.857 ns Â±  11.622 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                           â–ƒ              â–‡â–ˆ   â–       â–        â–
  â–‡â–â–â–â–â–â–â–â–â–â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ƒâ–â–â–ƒâ–„â–â–â–â–â–â–„â–ƒâ–â–ƒâ–ˆâ–ˆâ–†â–â–†â–ˆâ–†â–„â–ƒâ–â–„â–ƒâ–ˆâ–ˆâ–ˆâ–‡â–†â–…â–†â–…â–† â–ˆ
  348 ns        Histogram: log(frequency) by time        472 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, we benchmark the implementation of the same derivative operator in DiffEqOperators.jl.</p><pre><code class="language-julia hljs">doit(D_DEO, &quot;D_DEO:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_DEO:
â”Œ Warning: #= /home/runner/.julia/packages/DiffEqOperators/lHq9u/src/derivative_operators/convolutions.jl:412 =#:
â”‚ `LoopVectorization.check_args` on your inputs failed; running fallback `@inbounds @fastmath` loop instead.
â”‚ Use `warn_check_args=false`, e.g. `@turbo warn_check_args=false ...`, to disable this warning.
â”” @ DiffEqOperators ~/.julia/packages/LoopVectorization/E25Ro/src/condense_loopset.jl:1148
â”Œ Warning: #= /home/runner/.julia/packages/DiffEqOperators/lHq9u/src/derivative_operators/convolutions.jl:460 =#:
â”‚ `LoopVectorization.check_args` on your inputs failed; running fallback `@inbounds @fastmath` loop instead.
â”‚ Use `warn_check_args=false`, e.g. `@turbo warn_check_args=false ...`, to disable this warning.
â”” @ DiffEqOperators ~/.julia/packages/LoopVectorization/E25Ro/src/condense_loopset.jl:1148
BenchmarkTools.Trial: 10000 samples with 17 evaluations.
 Range (min â€¦ max):  1.100 Î¼s â€¦ 687.324 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 99.38%
 Time  (median):     1.247 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   1.385 Î¼s Â±   6.862 Î¼s  â”Š GC (mean Â± Ïƒ):  4.93% Â±  0.99%

  â–‚â–‚  â–â–ˆâ–‡â–…â–ƒâ–‚â–ƒâ–…â–ƒâ–…â–…â–„â–ƒâ–„â–„â–ƒâ–ƒâ–‚â–    â–â–                               â–‚
  â–ˆâ–ˆâ–ˆâ–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–†â–ˆâ–ˆâ–ˆâ–ˆâ–‡â–…â–‡â–„â–„â–„â–„â–…â–„â–…â–ƒâ–„â–ƒâ–ƒâ–ƒâ–„â–ƒâ–…â–…â–†â–…â–…â–†â–„â–‚â–…â–„â–„â–† â–ˆ
  1.1 Î¼s       Histogram: log(frequency) by time       2.2 Î¼s &lt;

 Memory estimate: 416 bytes, allocs estimate: 6.</code></pre><p>These results were obtained using the following versions.</p><pre><code class="language-julia hljs">using InteractiveUtils
versioninfo()

using Pkg
Pkg.status([&quot;SummationByPartsOperators&quot;, &quot;DiffEqOperators&quot;],
           mode=PKGMODE_MANIFEST)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.6.7
Commit 3b76b25b64 (2022-07-19 15:11 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Xeon(R) Platinum 8171M CPU @ 2.60GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-11.0.1 (ORCJIT, skylake-avx512)
Environment:
  JULIA_PKG_SERVER_REGISTRY_PREFERENCE = eager
      Status `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl/docs/Manifest.toml`
  [9fdde737] DiffEqOperators v4.45.0
  [9f78cca6] SummationByPartsOperators v0.5.30 `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl`</code></pre><h4 id="Bounded-domains"><a class="docs-heading-anchor" href="#Bounded-domains">Bounded domains</a><a id="Bounded-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Bounded-domains" title="Permalink"></a></h4><p>We start again by setting up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,
                            accuracy_order=6, xmin=xmin, xmax=xmax, N=10^3)
D_sparse = sparse(D_SBP)
D_banded = BandedMatrix(D_SBP)

u = randn(eltype(D_SBP), size(D_SBP, 1)); du = similar(u);
@show D_SBP * u â‰ˆ D_sparse * u â‰ˆ D_banded * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>First, we benchmark the implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 200 evaluations.
 Range (min â€¦ max):  348.025 ns â€¦ 750.550 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     432.530 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   451.160 ns Â±  38.526 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

               â–„       â–ˆâ–†     â–â– â–…â–         â–‚â–…                  â–‚
  â–‡â–â–â–â–â–â–ƒâ–â–â–â–â–â–â–ˆâ–â–…â–â–ƒâ–â–„â–…â–ˆâ–ˆâ–ƒâ–ˆâ–…â–…â–â–ˆâ–ˆâ–‡â–ˆâ–ˆâ–†â–‡â–†â–†â–…â–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–ˆâ–ˆâ–†â–‡â–‡â–‡â–‡â–…â–…â–† â–ˆ
  348 ns        Histogram: log(frequency) by time        583 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Again, we compare this to a representation of the derivative operator as a sparse matrix. No surprise - it is again much slower, as in periodic domains.</p><pre><code class="language-julia hljs">doit(D_sparse, &quot;D_sparse:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_sparse:
BenchmarkTools.Trial: 10000 samples with 5 evaluations.
 Range (min â€¦ max):  6.101 Î¼s â€¦  15.041 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     7.641 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   7.644 Î¼s Â± 377.638 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                 â–â–…â–      â–‚â–ˆâ–ˆ                                 â–‚
  â–†â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–„â–†â–†â–…â–…â–…â–…â–ƒâ–„â–â–â–‡â–‡â–‡â–…â–„â–„â–â–„â–„â–„â–ƒâ–ƒâ–ƒâ–„â–ƒâ–…â–„ â–ˆ
  6.1 Î¼s       Histogram: log(frequency) by time      9.62 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>FInally, we compare it to a representation as banded matrix. Disappointingly, this is still much slower than the optimized implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_banded, &quot;D_banded:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_banded:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  14.801 Î¼s â€¦  55.104 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     16.101 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   16.130 Î¼s Â± 735.515 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

     â–                                       â–‚   â–‡â–ƒ  â–ˆâ–…  â–‡â–„  â– â–‚
  â–ˆâ–â–â–ˆâ–…â–â–â–ˆâ–ƒâ–â–â–â–â–â–â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–†â–â–â–ˆâ–ˆâ–â–â–ˆâ–ˆâ–â–â–ˆâ–ˆâ–â–â–ˆ â–ˆ
  14.8 Î¼s       Histogram: log(frequency) by time      16.3 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>These results were obtained using the following versions.</p><pre><code class="language-julia hljs">using InteractiveUtils
versioninfo()

using Pkg
Pkg.status([&quot;SummationByPartsOperators&quot;, &quot;BandedMatrices&quot;],
           mode=PKGMODE_MANIFEST)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.6.7
Commit 3b76b25b64 (2022-07-19 15:11 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Xeon(R) Platinum 8171M CPU @ 2.60GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-11.0.1 (ORCJIT, skylake-avx512)
Environment:
  JULIA_PKG_SERVER_REGISTRY_PREFERENCE = eager
      Status `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl/docs/Manifest.toml`
  [aae01518] BandedMatrices v0.17.17
  [9f78cca6] SummationByPartsOperators v0.5.30 `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl`</code></pre><h2 id="Dissipation-operators"><a class="docs-heading-anchor" href="#Dissipation-operators">Dissipation operators</a><a id="Dissipation-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Dissipation-operators" title="Permalink"></a></h2><p>We follow the same structure as before. At first, we set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,
                            accuracy_order=6, xmin=xmin, xmax=xmax, N=10^3)
Di_SBP  = dissipation_operator(MattssonSvÃ¤rdNordstrÃ¶m2004(), D_SBP)
Di_sparse = sparse(Di_SBP)
Di_banded = BandedMatrix(Di_SBP)
Di_full   = Matrix(Di_SBP)

u = randn(eltype(D_SBP), size(D_SBP, 1)); du = similar(u);
@show Di_SBP * u â‰ˆ Di_sparse * u â‰ˆ Di_banded * u â‰ˆ Di_full * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>At first, let us benchmark the derivative and dissipation operators implemented in SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)
doit(Di_SBP, &quot;Di_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 201 evaluations.
 Range (min â€¦ max):  346.786 ns â€¦ 864.736 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     430.378 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   452.239 ns Â±  41.305 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

              â–ƒ       â–ˆâ–     â– â–â–…          â–†   â–                â–
  â–…â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–„â–…â–â–â–„â–„â–ˆâ–ˆâ–‡â–ˆâ–â–ƒâ–…â–ˆâ–ˆâ–ˆâ–ˆâ–†â–‡â–†â–†â–†â–…â–ˆâ–ˆâ–‡â–ˆâ–ˆâ–‡â–ˆâ–ˆâ–ˆâ–‡â–‡â–‡â–ˆâ–‡â–†â–‡â–‡â–‡â–†â–†â–‡â–†â–…â–† â–ˆ
  347 ns        Histogram: log(frequency) by time        592 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
Di_SBP:
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min â€¦ max):  1.680 Î¼s â€¦  4.920 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     1.830 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   1.830 Î¼s Â± 89.981 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

     â–ƒ   â–                                       â–  â–‡   â–ˆ  â–… â–
  â–ˆâ–â–â–ˆâ–â–â–â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–â–â–ˆâ–â–â–â–ˆâ–â–â–ˆ â–ˆ
  1.68 Î¼s      Histogram: log(frequency) by time     1.84 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we compare the results to sparse matrix representations. It will not come as a surprise that these are again much (around an order of magnitude) slower.</p><pre><code class="language-julia hljs">doit(Di_sparse, &quot;Di_sparse:&quot;, du, u)
doit(Di_banded, &quot;Di_banded:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Di_sparse:
BenchmarkTools.Trial: 10000 samples with 4 evaluations.
 Range (min â€¦ max):  5.900 Î¼s â€¦  15.276 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     8.501 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   8.512 Î¼s Â± 399.826 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                             â–‚â–…       â–ˆâ–ˆâ–„   â–â–‚                â–‚
  â–…â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–‡â–…â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–‡â–â–â–â–â–â–ƒâ–ˆâ–ˆâ–ˆâ–…â–ƒâ–â–ˆâ–ˆâ–†â–†â–…â–…â–ƒâ–â–ƒâ–„â–â–â–„â–‡â–‡â–†â–… â–ˆ
  5.9 Î¼s       Histogram: log(frequency) by time      10.1 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
Di_banded:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):   8.900 Î¼s â€¦ 48.403 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     12.901 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   12.923 Î¼s Â±  1.130 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                                                      â–‡â–‡â–ƒ â–ˆ
  â–‚â–‚â–‚â–â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–‚â–‚â–â–‚â–‚â–‚â–â–‚â–â–â–â–â–â–â–â–â–â–â–â–‚â–‚â–ƒâ–â–„â–ƒâ–ƒâ–â–ƒâ–‚â–‚â–â–‚â–„â–†â–â–ˆâ–ˆâ–ˆâ–â–ˆâ–ˆâ–‚ â–ƒ
  8.9 Î¼s          Histogram: frequency by time        13.3 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, let&#39;s benchmark the same computation if a full (dense) matrix is used to represent the derivative operator. This is obviously a bad idea but ğŸ¤·</p><pre><code class="language-julia hljs">doit(Di_full, &quot;Di_full:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Di_full:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  322.522 Î¼s â€¦ 705.849 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     352.024 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   362.841 Î¼s Â±  17.615 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                  â–„ â–†â–ˆâ–ƒâ–ƒâ–â–ƒâ–…â–ƒâ–‚â–â–‚â–ƒâ–‚â–‚â–‚â–â–‚â–â–â– â–â–…â–ƒâ–â–‚â–â–â–‚â–‚â–â–â–â–â–         â–‚
  â–„â–„â–†â–ƒâ–â–â–â–â–ƒâ–â–â–ƒâ–â–â–„â–…â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–‡â–‡â–† â–ˆ
  323 Î¼s        Histogram: log(frequency) by time        414 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>These results were obtained using the following versions.</p><pre><code class="language-julia hljs">using InteractiveUtils
versioninfo()

using Pkg
Pkg.status([&quot;SummationByPartsOperators&quot;, &quot;BandedMatrices&quot;],
           mode=PKGMODE_MANIFEST)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.6.7
Commit 3b76b25b64 (2022-07-19 15:11 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Xeon(R) Platinum 8171M CPU @ 2.60GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-11.0.1 (ORCJIT, skylake-avx512)
Environment:
  JULIA_PKG_SERVER_REGISTRY_PREFERENCE = eager
      Status `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl/docs/Manifest.toml`
  [aae01518] BandedMatrices v0.17.17
  [9f78cca6] SummationByPartsOperators v0.5.30 `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl`</code></pre><h2 id="Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)"><a class="docs-heading-anchor" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)">Structure-of-Arrays (SoA) and Array-of-Structures (AoS)</a><a id="Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)" title="Permalink"></a></h2><p><a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a> tries to provide efficient support of</p><ul><li><code>StaticVector</code>s from <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a></li><li><a href="https://github.com/JuliaArrays/StructArrays.jl">StructArrays.jl</a></li></ul><p>To demonstrate this, let us set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using StaticArrays, StructArrays
using LinearAlgebra, SparseArrays
using SummationByPartsOperators

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

struct Vec5{T} &lt;: FieldVector{5,T}
  x1::T
  x2::T
  x3::T
  x4::T
  x5::T
end

# Apply `mul!` to each component of a plain array of structures one after another
function mul_aos!(du, D, u, args...)
  for i in 1:size(du, 1)
    mul!(view(du, i, :), D, view(u, i, :), args...)
  end
end

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,
                            accuracy_order=4, xmin=xmin, xmax=xmax, N=101)
D_sparse = sparse(D_SBP)
D_full   = Matrix(D_SBP)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">101Ã—101 Matrix{Float64}:
 -141.176    173.529   -23.5294   â€¦    0.0         0.0       0.0
  -50.0        0.0      50.0           0.0         0.0       0.0
    9.30233  -68.6047    0.0           0.0         0.0       0.0
    3.06122    0.0     -60.2041        0.0         0.0       0.0
    0.0        0.0       8.33333       0.0         0.0       0.0
    0.0        0.0       0.0      â€¦    0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    â‹®                             â‹±                          â‹®
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0      â€¦    0.0         0.0       0.0
    0.0        0.0       0.0          -8.33333     0.0       0.0
    0.0        0.0       0.0          60.2041      0.0      -3.06122
    0.0        0.0       0.0           0.0        68.6047   -9.30233
    0.0        0.0       0.0         -50.0         0.0      50.0
    0.0        0.0       0.0      â€¦   23.5294   -173.529   141.176</code></pre><p>At first, we benchmark the application of the operators implemented in SummationByPartsOperators.jl and their representations as sparse and dense matrices in the scalar case. As before, the sparse matrix representation is around an order of magnitude slower and the dense matrix representation is far off.</p><pre><code class="language-julia hljs">println(&quot;Scalar case&quot;)
u = randn(T, size(D_SBP, 1)); du = similar(u)
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_SBP, $u))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_sparse, $u))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_full, $u))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Scalar case
D_SBP
BenchmarkTools.Trial: 10000 samples with 985 evaluations.
 Range (min â€¦ max):  40.511 ns â€¦ 105.998 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     58.177 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   60.096 ns Â±   6.156 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                  â–‚â–‚â–„â–„â– â–…â–…â–‡â–ˆâ–…â–„ â– â–ƒâ–‚â–ƒâ–‚   â–‚â–‚â–…â–…â–„â–‚                 â–‚
  â–†â–‡â–‡â–â–â–â–†â–†â–‡â–ˆâ–‡â–â–ƒâ–„â–„â–ƒâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–‡â–ˆâ–‡â–‡â–†â–† â–ˆ
  40.5 ns       Histogram: log(frequency) by time      81.8 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 188 evaluations.
 Range (min â€¦ max):  477.691 ns â€¦ 931.979 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     592.596 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   594.759 ns Â±  20.359 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                         â–„â–             â–ˆâ–„        â–  â–„          â–
  â–†â–â–â–â–â–â–â–â–â–â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–â–ƒâ–„â–â–â–â–â–„â–„â–â–†â–†â–ƒâ–ˆâ–ˆâ–â–…â–ˆâ–†â–…â–…â–ƒâ–ˆâ–ˆâ–ˆâ–†â–ˆâ–ˆâ–‡â–‡â–†â–‡â–ˆâ–‡â–‡â–‡ â–ˆ
  478 ns        Histogram: log(frequency) by time        659 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min â€¦ max):  1.790 Î¼s â€¦   5.810 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     2.230 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   2.319 Î¼s Â± 286.343 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

              â–ˆ
  â–‚â–â–â–â–â–â–â–„â–ƒâ–â–â–â–ˆâ–ƒâ–â–â–â–‚â–ƒâ–‚â–‚â–‚â–â–‚â–‚â–…â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–‚â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–â–‚â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚ â–‚
  1.79 Î¼s         Histogram: frequency by time        3.79 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we use a plain array of structures (AoS) in the form of a two-dimensional array and our custom <code>mul_aos!</code> implementation that loops over each component, using <code>mul!</code> on <code>view</code>s. Here, the differences between the timings are less pronounced.</p><pre><code class="language-julia hljs">println(&quot;Plain Array of Structures&quot;)
u_aos_plain = randn(T, 5, size(D_SBP, 1)); du_aos_plain = similar(u_aos_plain)
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_SBP, $u_aos_plain))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_sparse, $u_aos_plain))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_full, $u_aos_plain))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Plain Array of Structures
D_SBP
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min â€¦ max):  1.030 Î¼s â€¦  4.410 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     1.290 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   1.279 Î¼s Â± 87.889 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â– â–‚                              â–„ â–‚               â–‡ â–ˆ â–…   â–‚
  â–ˆâ–â–ˆâ–â–†â–â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–â–ˆâ–â–ˆâ–â–‡â–â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–ˆâ–â–ˆâ–â–ˆâ–â–ˆ â–ˆ
  1.03 Î¼s      Histogram: log(frequency) by time     1.31 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 8 evaluations.
 Range (min â€¦ max):  3.375 Î¼s â€¦   7.813 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     3.650 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   3.668 Î¼s Â± 113.227 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                       â–„â–ˆâ–ˆâ–…              â–‚                    â–‚
  â–‡â–ˆâ–†â–â–â–â–â–â–â–â–â–â–â–â–â–ƒâ–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ƒâ–â–â–â–â–â–â–â–â–â–â–ƒâ–‡â–ˆâ–ˆâ–â–ƒâ–â–ƒâ–…â–„â–„â–„â–„â–„â–„â–â–ƒâ–ƒâ–â–„â–ƒâ–ƒ â–ˆ
  3.38 Î¼s      Histogram: log(frequency) by time      4.09 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  11.300 Î¼s â€¦ 34.002 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     12.301 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   13.011 Î¼s Â±  1.891 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

      â–ˆ
  â–‚â–â–â–„â–ˆâ–‚â–â–‚â–…â–‚â–â–‚â–‚â–„â–ƒâ–â–‚â–‚â–‚â–â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–‚â–â–‚â–â–â–‚â–‚â–‚â–‚â–â–‚â–‚â–‚â–â–‚â–â–â–â–â–‚â–‚â–‚â–‚â–‚ â–‚
  11.3 Î¼s         Histogram: frequency by time        25.6 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Now, we use an array of structures (AoS) based on <code>reinterpret</code> and standard <code>mul!</code>. This is much more efficient for the implementation in SummationByPartsOperators.jl. In Julia v1.6, this is also more efficient for sparse matrices but less efficient for dense matrices (compared to the plain AoS approach with <code>mul_aos!</code> above).</p><pre><code class="language-julia hljs">println(&quot;Array of Structures (reinterpreted array)&quot;)
u_aos_r = reinterpret(reshape, Vec5{T}, u_aos_plain); du_aos_r = similar(u_aos_r)
@show D_SBP * u_aos_r â‰ˆ D_sparse * u_aos_r â‰ˆ D_full * u_aos_r
mul!(du_aos_r, D_SBP, u_aos_r)
@show reinterpret(reshape, T, du_aos_r) â‰ˆ du_aos_plain
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_SBP, $u_aos_r))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_sparse, $u_aos_r))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_full, $u_aos_r))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Array of Structures (reinterpreted array)
D_SBP * u_aos_r â‰ˆ D_sparse * u_aos_r â‰ˆ D_full * u_aos_r = true
reinterpret(reshape, T, du_aos_r) â‰ˆ du_aos_plain = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 511 evaluations.
 Range (min â€¦ max):  202.166 ns â€¦ 348.753 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     223.890 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   234.575 ns Â±  20.556 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

     â–      â–ˆ  â–ˆâ–† â–â–  â–â–â–…   â–…       â– â–ƒâ–…  â–â–†                    â–‚
  â–ˆâ–â–â–ˆâ–â–â–â–â–â–ƒâ–ˆâ–â–‡â–ˆâ–ˆâ–…â–ˆâ–ˆâ–‡â–†â–ˆâ–ˆâ–ˆâ–‡â–…â–…â–ˆâ–†â–‡â–‡â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–ˆâ–‡â–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–ˆâ–‡â–‡â–†â–‡â–‡ â–ˆ
  202 ns        Histogram: log(frequency) by time        297 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 41 evaluations.
 Range (min â€¦ max):  839.073 ns â€¦  2.625 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     907.390 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   909.454 ns Â± 26.089 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                                â–ƒâ–ˆâ–…                            â–
  â–†â–‡â–„â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–‡â–â–…â–„â–â–â–â–â–â–â–â–â–â–â–â–â–…â–…â–â–…â–†â–…â–„â–ƒâ–ƒâ–„â–ƒ â–ˆ
  839 ns        Histogram: log(frequency) by time       968 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  13.800 Î¼s â€¦ 53.004 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     17.601 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   18.121 Î¼s Â±  2.555 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

              â–ˆ
  â–ƒâ–‚â–â–â–â–â–ƒâ–ƒâ–„â–â–‚â–„â–ˆâ–‚â–‚â–‚â–‚â–…â–‚â–‚â–‚â–‚â–‚â–…â–‚â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–â–‚â–‚â–‚â–‚ â–‚
  13.8 Î¼s         Histogram: frequency by time        31.9 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we still use an array of structures (AoS), but copy the data into a plain <code>Array</code> instead of using the <code>reinterpret</code>ed versions. There is no significant difference to the previous version in this case.</p><pre><code class="language-julia hljs">println(&quot;Array of Structures&quot;)
u_aos = Array(u_aos_r); du_aos = similar(u_aos)
@show D_SBP * u_aos â‰ˆ D_sparse * u_aos â‰ˆ D_full * u_aos
mul!(du_aos, D_SBP, u_aos)
@show du_aos â‰ˆ du_aos_r
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_SBP, $u_aos))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_sparse, $u_aos))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_full, $u_aos))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Array of Structures
D_SBP * u_aos â‰ˆ D_sparse * u_aos â‰ˆ D_full * u_aos = true
du_aos â‰ˆ du_aos_r = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 545 evaluations.
 Range (min â€¦ max):  191.389 ns â€¦ 428.470 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     271.028 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   283.459 ns Â±  24.192 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                       â–ƒâ–ƒ      â–ˆâ–ˆ  â–‚â–‚â–  â–„â–… â–â–â–â–â–â– â–…â–ƒâ–…  â–â–â–â–     â–‚
  â–…â–â–â–â–â–â–â–â–â–‡â–†â–â–â–â–ƒâ–â–â–â–â–ƒâ–„â–ˆâ–ˆâ–„â–„â–„â–†â–…â–ƒâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡ â–ˆ
  191 ns        Histogram: log(frequency) by time        351 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 111 evaluations.
 Range (min â€¦ max):  881.144 ns â€¦  1.519 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     958.622 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   960.225 ns Â± 17.528 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                                â–‚â–…â–†â–ˆâ–ˆâ–„                  â–      â–‚
  â–…â–‡â–ˆâ–ˆâ–„â–â–â–â–ƒâ–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–ƒâ–â–â–â–â–â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–„â–‡â–ˆâ–ˆâ–ˆâ–†â–…â–â–â–â–â–„â–„â–„â–…â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–†â–† â–ˆ
  881 ns        Histogram: log(frequency) by time      1.02 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  15.901 Î¼s â€¦ 57.304 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     17.602 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   18.693 Î¼s Â±  2.475 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–‚   â–‚â–ƒâ–ˆ   â–‚â–…    â–‚â–„â–…                                         â–
  â–ˆâ–â–â–â–ˆâ–ˆâ–ˆâ–ƒâ–â–â–ˆâ–ˆâ–†â–„â–â–â–ˆâ–ˆâ–ˆâ–ƒâ–ƒâ–â–â–â–…â–†â–…â–„â–…â–…â–ƒâ–ƒâ–â–„â–ƒâ–â–â–„â–„â–â–â–„â–ƒâ–„â–„â–ƒâ–„â–â–ƒâ–â–â–â–ƒâ–…â–…â–†â–†â–†â–† â–ˆ
  15.9 Î¼s      Histogram: log(frequency) by time      32.4 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, let&#39;s look at a structure of arrays (SoA). Interestingly, this is slower than the array of structures we used above. On Julia v1.6, the sparse matrix representation performs particularly bad in this case.</p><pre><code class="language-julia hljs">println(&quot;Structure of Arrays&quot;)
u_soa = StructArray(u_aos); du_soa = similar(u_soa)
@show D_SBP * u_soa â‰ˆ D_sparse * u_soa â‰ˆ D_full * u_soa
mul!(du_soa, D_SBP, u_soa)
@show du_soa â‰ˆ du_aos
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_SBP, $u_soa))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_sparse, $u_soa))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_full, $u_soa))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Structure of Arrays
D_SBP * u_soa â‰ˆ D_sparse * u_soa â‰ˆ D_full * u_soa = true
du_soa â‰ˆ du_aos = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 301 evaluations.
 Range (min â€¦ max):  238.555 ns â€¦ 537.246 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     297.030 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   310.563 ns Â±  27.490 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

               â–ƒ       â–ˆ     â–â– â–ƒâ–ƒ         â–‚â–…                   â–
  â–…â–â–â–â–â–â–â–â–â–â–â–â–…â–ˆâ–ƒâ–„â–ƒâ–â–„â–…â–†â–ˆâ–…â–ˆâ–†â–ƒâ–ƒâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–†â–†â–…â–†â–…â–†â–ˆâ–‡â–‡â–ˆâ–ˆâ–‡â–ˆâ–ˆâ–ˆâ–‡â–†â–‡â–ˆâ–†â–†â–‡â–†â–‡â–†â–…â–†â–†â–† â–ˆ
  239 ns        Histogram: log(frequency) by time        404 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  338.323 Î¼s â€¦  10.487 ms  â”Š GC (min â€¦ max): 0.00% â€¦ 94.40%
 Time  (median):     376.226 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   450.858 Î¼s Â± 664.136 Î¼s  â”Š GC (mean Â± Ïƒ):  9.86% Â±  6.43%

          â–ˆ
  â–‚â–‚â–‚â–‚â–‚â–‚â–„â–…â–ˆâ–ˆâ–‡â–„â–„â–ƒâ–ƒâ–ƒâ–ƒâ–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–‚â–â–‚â–‚â–‚â–‚â–â–‚â–‚â–‚â–â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–„â–…â–ƒâ–ƒâ–‚ â–‚
  338 Î¼s           Histogram: frequency by time          586 Î¼s &lt;

 Memory estimate: 328.25 KiB, allocs estimate: 10504.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  211.815 Î¼s â€¦  10.028 ms  â”Š GC (min â€¦ max):  0.00% â€¦ 96.03%
 Time  (median):     260.618 Î¼s               â”Š GC (median):     0.00%
 Time  (mean Â± Ïƒ):   331.627 Î¼s Â± 646.909 Î¼s  â”Š GC (mean Â± Ïƒ):  13.04% Â±  6.50%

            â–ˆ â–
  â–‚â–‚â–‚â–â–‚â–‚â–‚â–‚â–ƒâ–‡â–ˆâ–†â–ˆâ–„â–„â–ƒâ–ƒâ–ƒâ–ƒâ–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–â–‚â–â–‚â–‚â–‚â–‚â–‚â–â–‚â–‚â–„â–„â–ƒâ–‚â–‚ â–‚
  212 Î¼s           Histogram: frequency by time          466 Î¼s &lt;

 Memory estimate: 328.25 KiB, allocs estimate: 10504.</code></pre><p>These results were obtained using the following versions.</p><pre><code class="language-julia hljs">using InteractiveUtils
versioninfo()

using Pkg
Pkg.status([&quot;SummationByPartsOperators&quot;, &quot;StaticArrays&quot;, &quot;StructArrays&quot;],
           mode=PKGMODE_MANIFEST)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.6.7
Commit 3b76b25b64 (2022-07-19 15:11 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Xeon(R) Platinum 8171M CPU @ 2.60GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-11.0.1 (ORCJIT, skylake-avx512)
Environment:
  JULIA_PKG_SERVER_REGISTRY_PREFERENCE = eager
      Status `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl/docs/Manifest.toml`
  [90137ffa] StaticArrays v1.5.17
  [09ab397b] StructArrays v0.6.15
  [9f78cca6] SummationByPartsOperators v0.5.30 `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl`</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../applications/">Â« Applications &amp; references</a><a class="docs-footer-nextpage" href="../api_reference/">API reference Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 15 March 2023 10:04">Wednesday 15 March 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
