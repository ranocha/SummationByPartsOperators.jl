var documenterSearchIndex = {"docs":
[{"location":"tutorials/variable_linear_advection/#Linear-advection-equation-with-variable-coefficients","page":"Linear advection equation with variable coefficients","title":"Linear advection equation with variable coefficients","text":"","category":"section"},{"location":"tutorials/variable_linear_advection/","page":"Linear advection equation with variable coefficients","title":"Linear advection equation with variable coefficients","text":"This tutorial is concerned with the linear advection equation","category":"page"},{"location":"tutorials/variable_linear_advection/","page":"Linear advection equation with variable coefficients","title":"Linear advection equation with variable coefficients","text":"beginaligned\n    partial_t u(tx) + partial_x (a(x) u(tx)) = 0  t in (0T) x in (x_min x_max) \n    u(0x) = u_0(x)  x in (x_min x_max) \n    textboundary conditions  x in partial (x_min x_max)\nendaligned","category":"page"},{"location":"tutorials/variable_linear_advection/","page":"Linear advection equation with variable coefficients","title":"Linear advection equation with variable coefficients","text":"with variable coefficient a.","category":"page"},{"location":"tutorials/variable_linear_advection/","page":"Linear advection equation with variable coefficients","title":"Linear advection equation with variable coefficients","text":"The boundary conditions depend on the sign of the transport velocity a at the boundary. In particular, specifying a Dirichlet type boundary condition is only allowed for inflow boundaries, e.g. a(x_min)  0 at x = x_min.","category":"page"},{"location":"tutorials/variable_linear_advection/","page":"Linear advection equation with variable coefficients","title":"Linear advection equation with variable coefficients","text":"SummationByPartsOperators.jl includes a pre-built semidiscretization of this equation: VariableLinearAdvectionNonperiodicSemidiscretization. Have a look at the source code if you want to dig deeper. Below is an example demonstrating how to use this semidiscretization.","category":"page"},{"location":"tutorials/variable_linear_advection/","page":"Linear advection equation with variable coefficients","title":"Linear advection equation with variable coefficients","text":"using SummationByPartsOperators, OrdinaryDiffEq\nusing LaTeXStrings; using Plots: Plots, plot, plot!, savefig\n\n# general parameters\nxmin = -1.\nxmax = +1.\ntspan = (0., 8.0)\nafunc(x) = one(x)\nu0func(x) = sinpi(x)\n# Dirichlet type boundary conditions; they are used only at inflow boundaries\nleft_bc(t) = t >= 3 ? sinpi(t) : zero(t)\nright_bc(t) = zero(t)\n\n# discretization parameters\ninterior_order = 4\nN = 101\n# whether a split form should be applied or not\nsplit_form = Val(false)\n\n# setup spatial semidiscretization\nD = derivative_operator(MattssonSvÃ¤rdShoeybi2008(), 1, interior_order, xmin, xmax, N)\n# whether or not artificial dissipation should be applied: nothing, dissipation_operator(D)\nDi = nothing\nsemi = VariableLinearAdvectionNonperiodicSemidiscretization(D, Di, afunc, split_form, left_bc, right_bc)\node = semidiscretize(u0func, semi, tspan)\n\n# solve ODE\nsol = solve(ode, SSPRK104(), dt=D.Î”x, adaptive=false,\n            save_everystep=false)\n\n# visualise the result\nplot(xguide=L\"x\", yguide=L\"u\")\nplot!(evaluate_coefficients(sol[1], semi), label=L\"u_0\")\nplot!(evaluate_coefficients(sol[end], semi), label=L\"u_\\mathrm{numerical}\")\nsavefig(\"example_linear_advection.png\");","category":"page"},{"location":"tutorials/variable_linear_advection/","page":"Linear advection equation with variable coefficients","title":"Linear advection equation with variable coefficients","text":"(Image: )","category":"page"},{"location":"applications/#Applications","page":"Applications & references","title":"Applications","text":"","category":"section"},{"location":"applications/","page":"Applications & references","title":"Applications & references","text":"Here is a (non-exhaustive) list of research using SummationByPartsOperators.jl.","category":"page"},{"location":"applications/","page":"Applications & references","title":"Applications & references","text":"Hendrik Ranocha, Manuel Quezada de Luna, and David I Ketcheson (2021). On the Rate of Error Growth in Time for Numerical Solutions of Nonlinear Dispersive Wave Equations. arXiv: 2102.07376 [math.NA] A reproducibility repository containing source code for all numerical experiments is available at DOI: 10.5281/zenodo.4540467\nHendrik Ranocha, Dimitrios Mitsotakis, and David I Ketcheson (2021). A Broad Class of Conservative Numerical Methods for Dispersive Wave Equations. DOI: 10.4208/cicp.OA-2020-0119 A reproducibility repository containing source code for all numerical experiments is available at DOI: 10.5281/zenodo.3908803\nPhilippe G LeFloch and Hendrik Ranocha (2021). Kinetic functions for nonclassical shocks, entropy stability, and discrete summation by parts. DOI: 10.1007/s10915-021-01463-6\nJan NordstrÃ¶m and Hendrik Ranocha (2021). A New Class of A Stable Summation by Parts Time Integration Schemes with Strong Initial Conditions. DOI: 10.1007/s10915-021-01454-7 A reproducibility repository containing source code for all numerical experiments is available at DOI: 10.5281/zenodo.3699173\nHendrik Ranocha (2021). On Strong Stability of Explicit Runge-Kutta Methods for Nonlinear Semibounded Operators. DOI: 10.1093/imanum/drz070\nHendrik Ranocha and David I Ketcheson (2020). Energy Stability of Explicit Runge-Kutta Methods for Nonautonomous or Nonlinear Problems. DOI: 10.1137/19M1290346 A reproducibility repository containing source code for all numerical experiments is available at DOI: 10.5281/zenodo.3464243\nHendrik Ranocha, Katharina Ostaszewski, and Philip Heinisch (2020). Discrete Vector Calculus and Helmholtz Hodge Decomposition for Classical Finite Difference Summation by Parts Operators. DOI: 10.1007/s42967-019-00057-2 A reproducibility repository containing source code for all numerical experiments is available at DOI: 10.5281/zenodo.3375170\nHendrik Ranocha and Gregor J Gassner (2020). Preventing pressure oscillations does not fix local linear stability issues of entropy-based split-form high-order schemes. arXiv: 2009.13139 [math.NA] A reproducibility repository containing source code for all numerical experiments is available at DOI: 10.5281/zenodo.4054366\nPhilipp Ã–ffner and Hendrik Ranocha (2019). Error Boundedness of Discontinuous Galerkin Methods with Variable Coefficients. DOI: 10.1007/s10915-018-00902-1","category":"page"},{"location":"applications/","page":"Applications & references","title":"Applications & references","text":"If you use this package for your own research, please cite it as described in the documentation and make a PR to add your work to the list above.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"EditURL = \"https://github.com/ranocha/SummationByPartsOperators.jl/blob/main/CONTRIBUTING.md\"","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"ContributingSummationByPartsOperators.jl is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as pull requests) any time. For planned larger contributions, it is often beneficial to get in contact first, for example via issues.SummationByPartsOperators.jl and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.Developer Certificate of Origin (Version 1.1)The following text was taken from https://developercertificate.org:Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"tutorials/constant_linear_advection/#Linear-advection-equation-with-constant-coefficients","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"","category":"section"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"This tutorial is concerned with the basic linear advection equation","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"beginaligned\n    partial_t u(tx) + partial_x u(tx) = 0  t in (0T) x in (x_min x_max) \n    u(0x) = u_0(x)  x in (x_min x_max) \n    u(tx_min) = u_L(t)\nendaligned","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"Note that the advection velocity is positive (unity). Thus, a boundary condition needs to be specified exactly at the left boundary. Otherwise, the problem will not be well-posed (under-specified or over-specified).","category":"page"},{"location":"tutorials/constant_linear_advection/#Basic-example-using-finite-difference-SBP-operators","page":"Linear advection equation with constant coefficients","title":"Basic example using finite difference SBP operators","text":"","category":"section"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"Let's create an appropriate discretization of this equation step by step. At first, we load packages that we will use in this example.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"using SummationByPartsOperators, OrdinaryDiffEq\nusing LaTeXStrings; using Plots: Plots, plot, plot!, savefig","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"Next, we specify the initial and boundary data as Julia functions as well as the spatial domain and the time span.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"xmin, xmax = -1.0, 1.0\nu0_func(x) = sinpi(x)\nuL_func(t) = t >= 3 ? sinpi(t) : zero(t)\ntspan = (0., 8.0)","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"This choice of the domain and boundary condition ensures that the initial profile is transported out of the domain before non-homogeneous boundary data influences the solution.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"Next, we implement the semidiscretization using the interface of OrdinaryDiffEq.jl which is part of DifferentialEquations.jl.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"function rhs!(du, u, params, t)\n  D = params.D\n\n  # Set `du = - D * u` using in-place multiplication avoiding allocations\n  # for efficiency\n  mul!(du, D, u, -one(eltype(D)))\n\n  # Next, we impose the boundary conditions weakly using an SAT at the left\n  # boundary. Since we use the strong form of the equation, we do not need to\n  # do anything at the right boundary.\n  # Assuming that boundary nodes are included in the grid, adding this SAT\n  # can be achieved by\n  du[begin] += (uL_func(t) - u[begin]) / left_boundary_weight(D)\n\n  return nothing\nend","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"Here, we have used a simultaneous approximation term (SAT) to impose the boundary condition weakly. In general, this approach is related to the weak imposition of boundary conditions using numerical fluxes in finite volume and discontinuous Galerkin methods; they are even equivalent for the linear advection equation considered here.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"Next, we choose an SBP operator D, evaluate the initial data on the grid, and set up the semidiscretization as an ODE problem.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"D = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1, accuracy_order=4,\n                        xmin=xmin, xmax=xmax, N=101)\nu0 = compute_coefficients(u0_func, D)\nparams = (D=D, )\node = ODEProblem(rhs!, u0, tspan, params);","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"Finally, we can solve the ODE using an explicit Runge-Kutta method with adaptive time stepping.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"sol = solve(ode, Tsit5(), saveat=range(first(tspan), stop=last(tspan), length=200));\n\nplot(xguide=L\"x\", yguide=L\"u\")\nplot!(evaluate_coefficients(sol[1], D), label=L\"u_0\")\nplot!(evaluate_coefficients(sol[end], D), label=L\"u_\\mathrm{numerical}\")\nsavefig(\"example_linear_advection.png\");","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"(Image: )","category":"page"},{"location":"tutorials/constant_linear_advection/#Advanced-visualization","page":"Linear advection equation with constant coefficients","title":"Advanced visualization","text":"","category":"section"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"Let's create an animation of the numerical solution.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"using Printf; using Plots: Animation, frame, gif\n\nlet anim = Animation()\n    idx = 1\n    x, u = evaluate_coefficients(sol[idx], D)\n    fig = plot(x, u, xguide=L\"x\", yguide=L\"u\", xlim=extrema(x), ylim=(-1.05, 1.05),\n              label=\"\", title=@sprintf(\"\\$t = %6.2f \\$\", sol.t[idx]))\n    for idx in 1:length(sol.t)\n        fig[1] = x, sol.u[idx]\n        plot!(title=@sprintf(\"\\$t = %6.2f \\$\", sol.t[idx]))\n        frame(anim)\n    end\n    gif(anim, \"example_linear_advection.gif\")\nend","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"(Image: example_linear_advection_animation)","category":"page"},{"location":"tutorials/constant_linear_advection/#Continuous-and-discontinuous-Galerkin-methods","page":"Linear advection equation with constant coefficients","title":"Continuous and discontinuous Galerkin methods","text":"","category":"section"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"You can use a CG or DG method by swapping out the derivative operator D.","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"plot(xguide=L\"x\", yguide=L\"u\")\nplot!(evaluate_coefficients(sol[1], D), label=L\"u_0\")\nplot!(evaluate_coefficients(sol[end], D), label=L\"u_\\mathrm{FD}\")\n\n# CGSEM using polynomials of degree 3, i.e. 4 nodes per element, and 30 elements\nD_CGSEM = couple_continuously(\n            legendre_derivative_operator(xmin=-1.0, xmax=1.0, N=4),\n            UniformMesh1D(xmin=xmin, xmax=xmax, Nx=30))\node_CGSEM = ODEProblem(rhs!, compute_coefficients(u0_func, D_CGSEM), tspan, (D=D_CGSEM,))\nsol_CGSEM = solve(ode_CGSEM, Tsit5(), save_everystep=false)\nplot!(evaluate_coefficients(sol_CGSEM[end], D_CGSEM), label=L\"u_\\mathrm{CG}\")\n\n# DGSEM using polynomials of degree 3, i.e. 4 nodes per element, and 30 elements\n# which are coupled using upwind fluxes\nD_DGSEM = couple_discontinuously(\n            legendre_derivative_operator(xmin=-1.0, xmax=1.0, N=4),\n            UniformMesh1D(xmin=xmin, xmax=xmax, Nx=30),\n            Val(:minus))\node_DGSEM = ODEProblem(rhs!, compute_coefficients(u0_func, D_DGSEM), tspan, (D=D_DGSEM,))\nsol_DGSEM = solve(ode_DGSEM, Tsit5(), save_everystep=false)\nplot!(evaluate_coefficients(sol_DGSEM[end], D_DGSEM), label=L\"u_\\mathrm{DG}\")\n\nsavefig(\"example_linear_advection_Galerkin.png\");","category":"page"},{"location":"tutorials/constant_linear_advection/","page":"Linear advection equation with constant coefficients","title":"Linear advection equation with constant coefficients","text":"(Image: )","category":"page"},{"location":"tutorials/advection_diffusion/#Linear-advection-diffusion-equation-with-periodic-boundary-conditions","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"","category":"section"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"Let's consider the linear advection diffusion equation","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"beginaligned\n    partial_t u(tx) + a partial_x u(tx) = varepsilon partial_x^2 u(tx)  t in (0T) x in (x_min x_max) \n    u(0x) = u_0(x)  x in (x_min x_max) \nendaligned","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"with periodic boundary conditions. Here, a is the constant advection velocity and Îµ > 0 is the constant diffusion coefficient.","category":"page"},{"location":"tutorials/advection_diffusion/#Basic-example-using-finite-difference-SBP-operators","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Basic example using finite difference SBP operators","text":"","category":"section"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"Let's create an appropriate discretization of this equation step by step. At first, we load packages that we will use in this example.","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"using SummationByPartsOperators, OrdinaryDiffEq\nusing LaTeXStrings; using Plots: Plots, plot, plot!, savefig","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"Next, we specify the initial data as Julia function as well as the spatial domain and the time span.","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"xmin, xmax = -1.0, 1.0\nu0_func(x) = sinpi(x)\ntspan = (0., 10.0)","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"Next, we implement the semidiscretization using the interface of OrdinaryDiffEq.jl which is part of DifferentialEquations.jl.","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"function advection_diffusion!(du, u, params, t)\n    # In-place version of du = -a * D1 * u\n    mul!(du, params.D1, u, -params.a)\n    # In-place version of du = du + Îµ * D2 * u\n    mul!(du, params.D2, u, params.Îµ, true)\nend","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"Next, we choose first- and second-derivative SBP operators D1, D2, evaluate the initial data on the grid, and set up the semidiscretization as an ODE problem.","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"N = 100 # number of grid points\nD1 = periodic_derivative_operator(derivative_order=1, accuracy_order=4,\n                                  xmin=xmin, xmax=xmax, N=N)\nD2 = periodic_derivative_operator(derivative_order=2, accuracy_order=4,\n                                  xmin=xmin, xmax=xmax, N=N)\nu0 = u0_func.(grid(D1))\nparams = (D1=D1, D2=D2, a=1.0, Îµ=0.03)\node = ODEProblem(advection_diffusion!, u0, tspan, params);","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"Finally, we can solve the ODE using an explicit Runge-Kutta method with adaptive time stepping.","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"sol = solve(ode, Tsit5(), saveat=range(first(tspan), stop=last(tspan), length=200));\n\nplot(xguide=L\"x\", yguide=L\"u\")\nplot!(evaluate_coefficients(sol[1], D1), label=L\"u_0\")\nplot!(evaluate_coefficients(sol[end], D1), label=L\"u_\\mathrm{numerical}\")\nsavefig(\"example_advection_diffusion.png\");","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"(Image: )","category":"page"},{"location":"tutorials/advection_diffusion/#Advanced-visualization","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Advanced visualization","text":"","category":"section"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"Let's create an animation of the numerical solution.","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"using Printf; using Plots: Animation, frame, gif\n\nlet anim = Animation()\n    idx = 1\n    x, u = evaluate_coefficients(sol[idx], D1)\n    fig = plot(x, u, xguide=L\"x\", yguide=L\"u\", xlim=extrema(x), ylim=(-1.05, 1.05),\n              label=\"\", title=@sprintf(\"\\$t = %6.2f \\$\", sol.t[idx]))\n    for idx in 1:length(sol.t)\n        fig[1] = x, sol.u[idx]\n        plot!(title=@sprintf(\"\\$t = %6.2f \\$\", sol.t[idx]))\n        frame(anim)\n    end\n    gif(anim, \"example_advection_diffusion.gif\")\nend","category":"page"},{"location":"tutorials/advection_diffusion/","page":"Linear advection diffusion equation with periodic boundary conditions","title":"Linear advection diffusion equation with periodic boundary conditions","text":"(Image: example_advection_diffusion_animation)","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Here are some simple benchmarks. Take them with a grain of salt since they run on virtual machines in the cloud to generate the documentation automatically.","category":"page"},{"location":"benchmarks/#First-derivative-operators","page":"Benchmarks","title":"First-derivative operators","text":"","category":"section"},{"location":"benchmarks/#Periodic-domains","page":"Benchmarks","title":"Periodic domains","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Let's set up some benchmark code.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BenchmarkTools\nusing LinearAlgebra, SparseArrays\nusing SummationByPartsOperators, DiffEqOperators\n\nBLAS.set_num_threads(1) # make sure that BLAS is serial to be fair\n\nT = Float64\nxmin, xmax = T(0), T(1)\n\nD_SBP = periodic_derivative_operator(derivative_order=1, accuracy_order=2,\n                                     xmin=xmin, xmax=xmax, N=100)\nx = grid(D_SBP)\nD_DEO = CenteredDifference(derivative_order(D_SBP), accuracy_order(D_SBP),\n                           step(x), length(x)) * PeriodicBC(eltype(D_SBP))\n\nD_sparse = sparse(D_SBP)\n\nu = randn(eltype(D_SBP), length(x)); du = similar(u);\n@show D_SBP * u â‰ˆ D_DEO * u â‰ˆ D_sparse * u\n\nfunction doit(D, text, du, u)\n  println(text)\n  sleep(0.1)\n  show(stdout, MIME\"text/plain\"(), @benchmark mul!($du, $D, $u))\n  println()\nend","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"First, we benchmark the implementation from SummationByPartsOperators.jl.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"doit(D_SBP, \"D_SBP:\", du, u)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Next, we compare this to the runtime obtained using a sparse matrix representation of the derivative operator. Depending on the hardware etc., this can be an order of magnitude slower than the optimized implementation from SummationByPartsOperators.jl.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"doit(D_sparse, \"D_sparse:\", du, u)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Finally, we benchmark the implementation of the same derivative operator in DiffEqOperators.jl.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"doit(D_DEO, \"D_DEO:\", du, u)","category":"page"},{"location":"benchmarks/#Bounded-domains","page":"Benchmarks","title":"Bounded domains","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"We start again by setting up some benchmark code.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BenchmarkTools\nusing LinearAlgebra, SparseArrays\nusing SummationByPartsOperators, BandedMatrices\n\nBLAS.set_num_threads(1) # make sure that BLAS is serial to be fair\n\nT = Float64\nxmin, xmax = T(0), T(1)\n\nD_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,\n                            accuracy_order=6, xmin=xmin, xmax=xmax, N=10^3)\nD_sparse = sparse(D_SBP)\nD_banded = BandedMatrix(D_SBP)\n\nu = randn(eltype(D_SBP), size(D_SBP, 1)); du = similar(u);\n@show D_SBP * u â‰ˆ D_sparse * u â‰ˆ D_banded * u\n\nfunction doit(D, text, du, u)\n  println(text)\n  sleep(0.1)\n  show(stdout, MIME\"text/plain\"(), @benchmark mul!($du, $D, $u))\n  println()\nend","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"First, we benchmark the implementation from SummationByPartsOperators.jl.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"doit(D_SBP, \"D_SBP:\", du, u)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Again, we compare this to a representation of the derivative operator as a sparse matrix. No surprise - it is again much slower, as in periodic domains.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"doit(D_sparse, \"D_sparse:\", du, u)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"FInally, we compare it to a representation as banded matrix. Disappointingly, this is still much slower than the optimized implementation from SummationByPartsOperators.jl.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"doit(D_banded, \"D_banded:\", du, u)","category":"page"},{"location":"benchmarks/#Dissipation-operators","page":"Benchmarks","title":"Dissipation operators","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"We follow the same structure as before. At first, we set up some benchmark code.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BenchmarkTools\nusing LinearAlgebra, SparseArrays\nusing SummationByPartsOperators, BandedMatrices\n\nBLAS.set_num_threads(1) # make sure that BLAS is serial to be fair\n\nT = Float64\nxmin, xmax = T(0), T(1)\n\nD_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,\n                            accuracy_order=6, xmin=xmin, xmax=xmax, N=10^3)\nDi_SBP  = dissipation_operator(MattssonSvÃ¤rdNordstrÃ¶m2004(), D_SBP)\nDi_sparse = sparse(Di_SBP)\nDi_banded = BandedMatrix(Di_SBP)\nDi_full   = Matrix(Di_SBP)\n\nu = randn(eltype(D_SBP), size(D_SBP, 1)); du = similar(u);\n@show Di_SBP * u â‰ˆ Di_sparse * u â‰ˆ Di_banded * u â‰ˆ Di_full * u\n\nfunction doit(D, text, du, u)\n  println(text)\n  sleep(0.1)\n  show(stdout, MIME\"text/plain\"(), @benchmark mul!($du, $D, $u))\n  println()\nend","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"At first, let us benchmark the derivative and dissipation operators implemented in SummationByPartsOperators.jl.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"doit(D_SBP, \"D_SBP:\", du, u)\ndoit(Di_SBP, \"Di_SBP:\", du, u)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Next, we compare the results to sparse matrix representations. It will not come as a surprise that these are again much (around an order of magnitude) slower.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"doit(Di_sparse, \"Di_sparse:\", du, u)\ndoit(Di_banded, \"Di_banded:\", du, u)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Finally, let's benchmark the same computation if a full (dense) matrix is used to represent the derivative operator. This is obviously a bad idea but ðŸ¤·","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"doit(Di_full, \"Di_full:\", du, u)","category":"page"},{"location":"benchmarks/#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)","page":"Benchmarks","title":"Structure-of-Arrays (SoA) and Array-of-Structures (AoS)","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"SummationByPartsOperators.jl tries to provide efficient support of","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"StaticVectors from StaticArrays.jl\nStructArrays.jl","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"To demonstrate this, let us set up some benchmark code.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BenchmarkTools\nusing StaticArrays, StructArrays\nusing LinearAlgebra, SparseArrays\nusing SummationByPartsOperators, BandedMatrices\n\nBLAS.set_num_threads(1) # make sure that BLAS is serial to be fair\n\nstruct Vec5{T} <: FieldVector{5,T}\n  x1::T\n  x2::T\n  x3::T\n  x4::T\n  x5::T\nend\n\n# Apply `mul!` to each component of a plain array of structures one after another\nfunction mul_aos!(du, D, u, args...)\n  for i in 1:size(du, 1)\n    mul!(view(du, i, :), D, view(u, i, :), args...)\n  end\nend\n\nT = Float64\nxmin, xmax = T(0), T(1)\n\nD_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,\n                            accuracy_order=4, xmin=xmin, xmax=xmax, N=101)\nD_sparse = sparse(D_SBP)\nD_full   = Matrix(D_SBP)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"At first, we benchmark the application of the operators implemented in SummationByPartsOperators.jl and their representations as sparse and dense matrices in the scalar case. As before, the sparse matrix representation is around an order of magnitude slower and the dense matrix representation is far off.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"println(\"Scalar case\")\nu = randn(T, size(D_SBP, 1)); du = similar(u)\nprintln(\"D_SBP\")\nshow(stdout, MIME\"text/plain\"(), @benchmark mul!($du, $D_SBP, $u))\nprintln(\"\\nD_sparse\")\nshow(stdout, MIME\"text/plain\"(), @benchmark mul!($du, $D_sparse, $u))\nprintln(\"\\nD_full\")\nshow(stdout, MIME\"text/plain\"(), @benchmark mul!($du, $D_full, $u))","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Next, we use a plain array of structures (AoS) in the form of a two-dimensional array and our custom mul_aos! implementation that loops over each component, using mul! on views. Here, the differences between the timings are less pronounced.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"println(\"Plain Array of Structures\")\nu_aos_plain = randn(T, 5, size(D_SBP, 1)); du_aos_plain = similar(u_aos_plain)\nprintln(\"D_SBP\")\nshow(stdout, MIME\"text/plain\"(), @benchmark mul_aos!($du_aos_plain, $D_SBP, $u_aos_plain))\nprintln(\"\\nD_sparse\")\nshow(stdout, MIME\"text/plain\"(), @benchmark mul_aos!($du_aos_plain, $D_sparse, $u_aos_plain))\nprintln(\"\\nD_full\")\nshow(stdout, MIME\"text/plain\"(), @benchmark mul_aos!($du_aos_plain, $D_full, $u_aos_plain))","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Now, we use an array of structures (AoS) based on reinterpret and standard mul!. This is much more efficient for the implementation in SummationByPartsOperators.jl. In Julia v1.6, this is also more efficient for sparse matrices but less efficient for dense matrices (compared to the plain AoS approach with mul_aos! above).","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"println(\"Array of Structures (reinterpreted array)\")\nu_aos_r = reinterpret(reshape, Vec5{T}, u_aos_plain); du_aos_r = similar(u_aos_r)\n@show D_SBP * u_aos_r â‰ˆ D_sparse * u_aos_r â‰ˆ D_full * u_aos_r\nmul!(du_aos_r, D_SBP, u_aos_r)\n@show reinterpret(reshape, T, du_aos_r) â‰ˆ du_aos_plain\nprintln(\"D_SBP\")\nshow(stdout, MIME\"text/plain\"(), @benchmark mul!($du_aos_r, $D_SBP, $u_aos_r))\nprintln(\"\\nD_sparse\")\nshow(stdout, MIME\"text/plain\"(), @benchmark mul!($du_aos_r, $D_sparse, $u_aos_r))\nprintln(\"\\nD_full\")\nshow(stdout, MIME\"text/plain\"(), @benchmark mul!($du_aos_r, $D_full, $u_aos_r))","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Next, we still use an array of structures (AoS), but copy the data into a plain Array instead of using the reinterpreted versions. There is no significant difference to the previous version in this case.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"println(\"Array of Structures\")\nu_aos = Array(u_aos_r); du_aos = similar(u_aos)\n@show D_SBP * u_aos â‰ˆ D_sparse * u_aos â‰ˆ D_full * u_aos\nmul!(du_aos, D_SBP, u_aos)\n@show du_aos â‰ˆ du_aos_r\nprintln(\"D_SBP\")\nshow(stdout, MIME\"text/plain\"(), @benchmark mul!($du_aos, $D_SBP, $u_aos))\nprintln(\"\\nD_sparse\")\nshow(stdout, MIME\"text/plain\"(), @benchmark mul!($du_aos, $D_sparse, $u_aos))\nprintln(\"\\nD_full\")\nshow(stdout, MIME\"text/plain\"(), @benchmark mul!($du_aos, $D_full, $u_aos))","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Finally, let's look at a structure of arrays (SoA). Interestingly, this is slower than the array of structures we used above. On Julia v1.6, the sparse matrix representation performs particularly bad in this case.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"println(\"Structure of Arrays\")\nu_soa = StructArray(u_aos); du_soa = similar(u_soa)\n@show D_SBP * u_soa â‰ˆ D_sparse * u_soa â‰ˆ D_full * u_soa\nmul!(du_soa, D_SBP, u_soa)\n@show du_soa â‰ˆ du_aos\nprintln(\"D_SBP\")\nshow(stdout, MIME\"text/plain\"(), @benchmark mul!($du_soa, $D_SBP, $u_soa))\nprintln(\"\\nD_sparse\")\nshow(stdout, MIME\"text/plain\"(), @benchmark mul!($du_soa, $D_sparse, $u_soa))\nprintln(\"\\nD_full\")\nshow(stdout, MIME\"text/plain\"(), @benchmark mul!($du_soa, $D_full, $u_soa))","category":"page"},{"location":"api_reference/#SummationByPartsOperators.jl-API","page":"API reference","title":"SummationByPartsOperators.jl API","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"CurrentModule = SummationByPartsOperators","category":"page"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"Modules = [SummationByPartsOperators]","category":"page"},{"location":"api_reference/#SummationByPartsOperators.SummationByPartsOperators","page":"API reference","title":"SummationByPartsOperators.SummationByPartsOperators","text":"SummationByPartsOperators.jl is a Julia library of summation-by-parts (SBP) operators, which are discrete derivative operators developed to get provably stable semidiscretizations, paying special attention to boundary conditions. Discretizations included in this framework are finite difference, Fourier pseudospectral, continuous Galerkin, and discontinuous Galerkin methods. The main aim of SummationByPartsOperators.jl is to be useful for researchers and students to learn the basic concepts by providing a unified framework of all of these seemingly different discretizations. At the same time, the implementation is optimized to achieve good performance without sacrificing flexibility.\n\nCheck out the documentation for further information. Some noticable functions to start with are derivative_operator, legendre_derivative_operator, periodic_derivative_operator, fourier_derivative_operator, dissipation_operator, and grid.\n\nIf you use this package for your research, please cite it using\n\n@article{ranocha2021sbp,\n  title={{SummationByPartsOperators.jl}: {A} {J}ulia library of provably stable\n         semidiscretization techniques with mimetic properties},\n  author={Ranocha, Hendrik},\n  journal={Journal of Open Source Software},\n  year={2021},\n  month={08},\n  doi={10.21105/joss.03454},\n  volume={6},\n  number={64},\n  pages={3454},\n  publisher={The Open Journal},\n  url={https://github.com/ranocha/SummationByPartsOperators.jl}\n}\n\n\n\n\n\n","category":"module"},{"location":"api_reference/#SummationByPartsOperators.BeljaddLeFlochMishraParÃ©s2017","page":"API reference","title":"SummationByPartsOperators.BeljaddLeFlochMishraParÃ©s2017","text":"BeljaddLeFlochMishraParÃ©s2017()\n\nCoefficients of the periodic operators given in\n\nBeljadid, LeFloch, Mishra, ParÃ©s (2017) Schemes with Well-Controlled Dissipation. Hyperbolic Systems in   Nonconservative Form. Communications in Computational Physics 21.4, pp. 913-946.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.BurgersNonperiodicSemidiscretization","page":"API reference","title":"SummationByPartsOperators.BurgersNonperiodicSemidiscretization","text":"BurgersNonperiodicSemidiscretization(D, Di, split_form, left_bc, right_bc)\n\nA semidiscretization of Burgers' equation     partial_t u(tx) + partial_x fracu(tx)^22 = 0 with boundary conditions left_bc(t), right_bc(t).\n\nD is a first-derivative SBP operator, Di an associated dissipation operator or nothing, and split_form::Union{Val(true), Val(false)} determines whether the canonical split form or the conservative form is used.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.BurgersPeriodicSemidiscretization","page":"API reference","title":"SummationByPartsOperators.BurgersPeriodicSemidiscretization","text":"BurgersPeriodicSemidiscretization(D, Di, split_form)\n\nA semidiscretization of Burgers' equation     partial_t u(tx) + partial_x fracu(tx)^22 = 0 with periodic boundary conditions.\n\nD is a first-derivative SBP operator, Di an associated dissipation operator or nothing, and split_form::Union{Val(true), Val(false)} determines whether the canonical split form or the conservative form is used.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.ConstantFilter","page":"API reference","title":"SummationByPartsOperators.ConstantFilter","text":"ConstantFilter\n\nRepresents the action of a modal filter on values in a nodal basis with fixed strength.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.ConstantFilter-Union{Tuple{T}, Tuple{FourierDerivativeOperator{T, Grid, RFFT, BRFFT} where {Grid, RFFT, BRFFT}, Any}} where T","page":"API reference","title":"SummationByPartsOperators.ConstantFilter","text":"ConstantFilter(D::FourierDerivativeOperator, filter)\n\nCreate a modal filter with constant parameters adapted to the Fourier derivative operator D with parameters given by the filter function filter.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.ConstantFilter-Union{Tuple{T}, Tuple{LegendreDerivativeOperator{T}, Any}, Tuple{LegendreDerivativeOperator{T}, Any, Any}} where T","page":"API reference","title":"SummationByPartsOperators.ConstantFilter","text":"ConstantFilter(D::LegendreDerivativeOperator, filter, TmpEltype=T)\n\nCreate a modal filter with constant parameters adapted to the Legendre derivative operator D with parameters given by the filter function filter.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.CubicNonperiodicSemidiscretization","page":"API reference","title":"SummationByPartsOperators.CubicNonperiodicSemidiscretization","text":"CubicNonperiodicSemidiscretization(D, Di, split_form, left_bc, right_bc)\n\nA semidiscretization of the cubic conservation law     partial_t u(tx) + partial_x u(tx)^3 = 0 with nonperiodic boundary conditions left_bc(t), right_bc(t).\n\nD is a first-derivative SBP operator, Di an associated dissipation operator or nothing, and split_form::Union{Val(true), Val(false)} determines whether the canonical split form or the conservative form is used.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.CubicPeriodicSemidiscretization","page":"API reference","title":"SummationByPartsOperators.CubicPeriodicSemidiscretization","text":"CubicPeriodicSemidiscretization(D, Di, split_form)\n\nA semidiscretization of the cubic conservation law     partial_t u(tx) + partial_x u(tx)^3 = 0 with periodic boundary conditions.\n\nD is a first-derivative SBP operator, Di an associated dissipation operator or nothing, and split_form::Union{Val(true), Val(false)} determines whether the canonical split form or the conservative form is used.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.DerivativeCoefficientRow","page":"API reference","title":"SummationByPartsOperators.DerivativeCoefficientRow","text":"DerivativeCoefficientRow{T,Start,Length}\n\nA struct representing a row in the boundary block of an SBP derivative operator with scalar type T.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.DerivativeCoefficients","page":"API reference","title":"SummationByPartsOperators.DerivativeCoefficients","text":"DerivativeCoefficients\n\nThe coefficients of a derivative operator on a nonperiodic grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.DerivativeOperator","page":"API reference","title":"SummationByPartsOperators.DerivativeOperator","text":"DerivativeOperator\n\nA derivative operator on a nonperiodic finite difference grid. See derivative_operator.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.DissipationOperator","page":"API reference","title":"SummationByPartsOperators.DissipationOperator","text":"DissipationOperator\n\nA dissipation operator on a nonperiodic finite difference grid. See dissipation_operator.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.ExponentialFilter","page":"API reference","title":"SummationByPartsOperators.ExponentialFilter","text":"ExponentialFilter\n\nRepresents the exponential filter function Ïƒ(Î·) = exp(-Î±*Î·^p).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.FactorisationWrapper","page":"API reference","title":"SummationByPartsOperators.FactorisationWrapper","text":"FactorisationWrapper\n\nA small wrapper around a a factorisation fact, allowing to represent multiplication by the inverse of fact.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.FastMode","page":"API reference","title":"SummationByPartsOperators.FastMode","text":"FastMode()\n\nA (probably) faster execution mode that might depend on packages such as LoopVectorization.jl.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.Fornberg1998","page":"API reference","title":"SummationByPartsOperators.Fornberg1998","text":"Fornberg1998()\n\nCoefficients of the periodic operators given in\n\nFornberg (1998) Calculation of Weights in Finite Difference Formulas. SIAM Rev. 40.3, pp. 685-691.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.FourierConstantViscosity","page":"API reference","title":"SummationByPartsOperators.FourierConstantViscosity","text":"FourierConstantViscosity\n\nFourier viscosity operator with constant coefficients for the periodic 1st derivative Fourier operator.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.FourierDerivativeOperator","page":"API reference","title":"SummationByPartsOperators.FourierDerivativeOperator","text":"FourierDerivativeOperator{T}\n\nA derivative operator on a periodic grid with real scalar type T computing the first derivative using a spectral Fourier expansion via real discrete Fourier transforms.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.FourierDerivativeOperator-Union{Tuple{T}, Tuple{T, T, Integer}} where T<:Real","page":"API reference","title":"SummationByPartsOperators.FourierDerivativeOperator","text":"FourierDerivativeOperator(xmin::T, xmax::T, N::Integer) where {T<:Real}\n\nConstruct the FourierDerivativeOperator on a uniform grid between xmin and xmax using N nodes and NÃ·2+1 complex Fourier modes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.FourierDerivativeOperator2D","page":"API reference","title":"SummationByPartsOperators.FourierDerivativeOperator2D","text":"FourierDerivativeOperator2D{T<:Real}\n\nA derivative operator on a two-dimensional periodic grid with scalar type T computing the first derivatives using a spectral Fourier expansion via real discrete Fourier transforms.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.FourierDerivativeOperator2D-Union{Tuple{T}, Tuple{T, T, Int64, T, T, Int64}} where T<:Real","page":"API reference","title":"SummationByPartsOperators.FourierDerivativeOperator2D","text":"FourierDerivativeOperator2D(xmin, xmax, Nx, ymin, ymax, Ny)\n\nConstruct the FourierDerivativeOperator on a uniform grid between xmin and xmax using Nx nodes and ymin and ymax using Ny nodes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.Holoborodko2008","page":"API reference","title":"SummationByPartsOperators.Holoborodko2008","text":"Holoborodko2008()\n\nCoefficients of the periodic operators given in\n\nHoloborodko (2008) Smooth Noise Robust Differentiators. http://www.holoborodko.com/pavel/numerical-methods/numerical-derivative/smooth-low-noise-differentiators/\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.LegendreDerivativeOperator","page":"API reference","title":"SummationByPartsOperators.LegendreDerivativeOperator","text":"LegendreDerivativeOperator{T<:Real}\n\nA derivative operator on a nonperiodic Lobatto-Legendre grid with scalar type T computing the first derivative using a Legendre expansion.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.LegendreDerivativeOperator-Union{Tuple{T}, Tuple{T, T, Int64}} where T<:Real","page":"API reference","title":"SummationByPartsOperators.LegendreDerivativeOperator","text":"LegendreDerivativeOperator(xmin::T, xmax::T, N::Int) where {T<:Real}\n\nConstruct the LegendreDerivativeOperator on a uniform grid between xmin and xmax using N nodes and N-1 Legendre modes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.LegendreSecondDerivativeOperator","page":"API reference","title":"SummationByPartsOperators.LegendreSecondDerivativeOperator","text":"LegendreSecondDerivativeOperator{T<:Real}\n\nA derivative operator on a nonperiodic Lobatto-Legendre grid with scalar type T computing the second derivative using a Legendre expansion.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.MadayTadmor1989","page":"API reference","title":"SummationByPartsOperators.MadayTadmor1989","text":"MadayTadmor1989()\n\nCoefficients of the Fourier spectral viscosity given in\n\nMaday, Tadmor (1989) Analysis of the Spectral Vanishing Viscosity Method for Periodic Conservation   Laws. SIAM Journal on Numerical Analysis 26.4, pp. 854-870.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.Mattsson2012","page":"API reference","title":"SummationByPartsOperators.Mattsson2012","text":"Mattsson2012()\n\nCoefficients of the SBP operators given in\n\nMattsson (2012) Summation by Parts Operators for Finite Difference Approximations of   Second-Derivatives with Variable Coefficients. Journal of Scientific Computing 51, pp. 650-682.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.Mattsson2014","page":"API reference","title":"SummationByPartsOperators.Mattsson2014","text":"Mattsson2014()\n\nCoefficients of the SBP operators given in\n\nMattsson (2014) Diagonal-norm summation by parts operators for fiite difference approximations   of third and fourth derivatives. Journal of Computational Physics 274, pp. 432-454.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.Mattsson2017","page":"API reference","title":"SummationByPartsOperators.Mattsson2017","text":"Mattsson2017(version::Symbol)\n\nCoefficients of the upwind SBP operators given in\n\nMattsson (2017) Diagonal-norm upwind SBP operators. Journal of Computational Physics 335, pp. 283-310.\n\nYou can choose between the different versions :central, :plus, and :minus.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.MattssonAlmquistCarpenter2014Extended","page":"API reference","title":"SummationByPartsOperators.MattssonAlmquistCarpenter2014Extended","text":"MattssonAlmquistCarpenter2014Extended()\n\nCoefficients of the extended SBP operators given in\n\nMattsson, Almquist, Carpenter (2014) Optimal diagonal-norm SBP operators. Journal of Computational Physics 264, pp. 91-111.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.MattssonAlmquistCarpenter2014Optimal","page":"API reference","title":"SummationByPartsOperators.MattssonAlmquistCarpenter2014Optimal","text":"MattssonAlmquistCarpenter2014Optimal()\n\nCoefficients of the optimal SBP operators with nonuniform grid given in\n\nMattsson, Almquist, Carpenter (2014) Optimal diagonal-norm SBP operators. Journal of Computational Physics 264, pp. 91-111.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.MattssonAlmquistVanDerWeide2018Accurate","page":"API reference","title":"SummationByPartsOperators.MattssonAlmquistVanDerWeide2018Accurate","text":"MattssonAlmquistVanDerWeide2018Accurate()\n\nCoefficients of the optimized SBP operators with nonuniform grid given in\n\nMattsson, Almquist, van der Weide (2018) Boundary optimized diagonal-norm SBP operators. Journal of Computational Physics 374, pp. 1261-1266.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.MattssonAlmquistVanDerWeide2018Minimal","page":"API reference","title":"SummationByPartsOperators.MattssonAlmquistVanDerWeide2018Minimal","text":"MattssonAlmquistVanDerWeide2018Minimal()\n\nCoefficients of the optimized SBP operators with nonuniform grid given in\n\nMattsson, Almquist, van der Weide (2018) Boundary optimized diagonal-norm SBP operators. Journal of Computational Physics 374, pp. 1261-1266.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.MattssonNordstrÃ¶m2004","page":"API reference","title":"SummationByPartsOperators.MattssonNordstrÃ¶m2004","text":"MattssonNordstrÃ¶m2004()\n\nCoefficients of the SBP operators given in\n\nMattsson, NordstrÃ¶m (2004) Summation by parts operators for finite difference approximations of second derivatives. Journal of Computational Physics 199, pp. 503-540.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.MattssonSvÃ¤rdNordstrÃ¶m2004","page":"API reference","title":"SummationByPartsOperators.MattssonSvÃ¤rdNordstrÃ¶m2004","text":"MattssonSvÃ¤rdNordstrÃ¶m2004()\n\nCoefficients of the SBP operators given in\n\nMattsson, SvÃ¤rd, NordstrÃ¶m (2004) Stable and Accurate Artificial Dissipation. Journal of Scientific Computing 21.1, pp. 57-79.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.MattssonSvÃ¤rdShoeybi2008","page":"API reference","title":"SummationByPartsOperators.MattssonSvÃ¤rdShoeybi2008","text":"MattssonSvÃ¤rdShoeybi2008()\n\nCoefficients of the SBP operators given in\n\nMattsson, SvÃ¤rd, Shoeybi (2008) Stable and accurate schemes for the compressible Navier-Stokes equations. Journal of Computational Physics 227, pp. 2293-2316.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.PeriodicDerivativeCoefficients","page":"API reference","title":"SummationByPartsOperators.PeriodicDerivativeCoefficients","text":"PeriodicDerivativeCoefficients\n\nThe coefficients of a derivative operator on a periodic grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.PeriodicDerivativeOperator","page":"API reference","title":"SummationByPartsOperators.PeriodicDerivativeOperator","text":"PeriodicDerivativeOperator\n\nA derivative operator on a uniform periodic grid. See periodic_derivative_operator and periodic_central_derivative_operator.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.PeriodicDissipationOperator","page":"API reference","title":"SummationByPartsOperators.PeriodicDissipationOperator","text":"PeriodicDissipationOperator\n\nA dissipation operator on a periodic finite difference grid. See dissipation_operator.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.QuarticNonconvexPeriodicSemidiscretization","page":"API reference","title":"SummationByPartsOperators.QuarticNonconvexPeriodicSemidiscretization","text":"QuarticNonconvexPeriodicSemidiscretization(D, Di, split_form)\n\nA semidiscretization of the quartic nonconvex conservation law     partial_t u(tx) + partial_x ( u(tx)^4 - 10 u(tx)^2 + 3 u(tx) ) = 0 with periodic boundary conditions.\n\nD is a first-derivative SBP operator, Di an associated dissipation operator or nothing, and split_form::Union{Val(true), Val(false)} determines whether the canonical split form or the conservative form is used.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.SafeMode","page":"API reference","title":"SummationByPartsOperators.SafeMode","text":"SafeMode()\n\nA safe execution mode relying only on basic functionality of Julia.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.SourceOfCoefficients","page":"API reference","title":"SummationByPartsOperators.SourceOfCoefficients","text":"SourceOfCoefficients\n\nAll sources of coefficients (articles) are subtypes of this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.SumOfDerivativeOperators","page":"API reference","title":"SummationByPartsOperators.SumOfDerivativeOperators","text":"SumOfDerivativeOperators\n\nSum several derivative operators lazily.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.Tadmor1989","page":"API reference","title":"SummationByPartsOperators.Tadmor1989","text":"Tadmor1989()\n\nCoefficients of the Fourier spectral viscosity given in\n\nTadmor (1989) Convergence of Spectral Methods for Nonlinear Conservation Laws. SIAM Journal on Numerical Analysis 26.1, pp. 30-44.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.Tadmor1993","page":"API reference","title":"SummationByPartsOperators.Tadmor1993","text":"Tadmor1993()\n\nCoefficients of the Fourier super spectral viscosity given in\n\nTadmor (1993) Super Viscosity and Spectral Approximations of Nonlinear Conservation Laws. Numerical Methods for Fluid Dynamics IV, pp. 69-82.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.TadmorWaagan2012Convergent","page":"API reference","title":"SummationByPartsOperators.TadmorWaagan2012Convergent","text":"TadmorWaagan2012Convergent()\n\nCoefficients of the Fourier spectral viscosity given in\n\nTadmor, Waagan (2012) Adaptive Spectral Viscosity for Hyperbolic Conservation Laws. SIAM Journal on Scientific Computing 34.2, pp. A993-A1009.\n\nSee also\n\nSchochet (1990) The Rate of Convergence of Spectral-Viscosity Methods for Periodic Scalar   Conservation Laws. SIAM Journal on Numerical Analysis 27.5, pp. 1142-1159.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.TadmorWaagan2012Standard","page":"API reference","title":"SummationByPartsOperators.TadmorWaagan2012Standard","text":"TadmorWaagan2012Standard()\n\nCoefficients of the Fourier spectral viscosity given in\n\nTadmor, Waagan (2012) Adaptive Spectral Viscosity for Hyperbolic Conservation Laws. SIAM Journal on Scientific Computing 34.2, pp. A993-A1009.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.ThreadedMode","page":"API reference","title":"SummationByPartsOperators.ThreadedMode","text":"ThreadedMode()\n\nAn execution mode using multiple threads and possibly further optimizations, cf. FastMode.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.UniformMesh1D","page":"API reference","title":"SummationByPartsOperators.UniformMesh1D","text":"UniformMesh1D(xmin::Real, xmax::Real, Nx::Integer)\nUniformMesh1D(; xmin::Real, xmax::Real, Nx::Integer)\n\nA uniform mesh in one space dimension of Nx cells between xmin and xmax.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.UniformPeriodicMesh1D","page":"API reference","title":"SummationByPartsOperators.UniformPeriodicMesh1D","text":"UniformPeriodicMesh1D(xmin::Real, xmax::Real, Nx::Integer)\nUniformPeriodicMesh1D(; xmin::Real, xmax::Real, Nx::Integer)\n\nA uniform periodic mesh in one space dimension of Nx cells between xmin and xmax.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.VarCoefDerivativeCoefficients","page":"API reference","title":"SummationByPartsOperators.VarCoefDerivativeCoefficients","text":"VarCoefDerivativeCoefficients\n\nThe coefficients of a variable coefficient derivative operator on a nonperiodic grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.VarCoefDerivativeOperator","page":"API reference","title":"SummationByPartsOperators.VarCoefDerivativeOperator","text":"VarCoefDerivativeOperator\n\nA dissipation operator on a nonperiodic finite difference grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.VariableLinearAdvectionNonperiodicSemidiscretization","page":"API reference","title":"SummationByPartsOperators.VariableLinearAdvectionNonperiodicSemidiscretization","text":"VariableLinearAdvectionNonperiodicSemidiscretization(D, Di, a, split_form,\n                                                     left_bc, right_bc)\n\nA semidiscretization of the linear advection equation     partial_t u(tx) + partial_x ( a(x) u(tx) ) = 0 with boundary conditions left_bc(t), right_bc(t).\n\nD is an SBP derivative operator, Di an associated dissipation operator or nothing, a(x) the variable coefficient, and split_form::Union{Val(false), Val(true)} determines whether the canonical split form or the conservative form should be used.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SummationByPartsOperators.WaveEquationNonperiodicSemidiscretization","page":"API reference","title":"SummationByPartsOperators.WaveEquationNonperiodicSemidiscretization","text":"WaveEquationNonperiodicSemidiscretization(D, left_bc, right_bc)\n\nA semidiscretization of the linear wave equation     partial_t^2 u(tx) = partial_x^2 u(tx).\n\nD is assumed to be a second-derivative SBP operator and the boundary conditions can be Val(:HomogeneousNeumann), Val(:HomogeneousDirichlet), or Val(:NonReflecting).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#LinearAlgebra.mul!","page":"API reference","title":"LinearAlgebra.mul!","text":"mul!(du, D::DerivativeOperator, u, Î±=true, Î²=false)\n\nEfficient in-place version of du = Î± * D * u + Î² * du. Note that du must not be aliased with u.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#PolynomialBases.compute_coefficients!-Tuple{Any, Any, SummationByPartsOperators.AbstractDerivativeOperator}","page":"API reference","title":"PolynomialBases.compute_coefficients!","text":"compute_coefficients!(uval, u, D::AbstractDerivativeOperator)\n\nCompute the nodal values of the function u at the grid associated to the derivative operator D and stores the result in uval.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#PolynomialBases.compute_coefficients-Tuple{Any, SummationByPartsOperators.AbstractDerivativeOperator}","page":"API reference","title":"PolynomialBases.compute_coefficients","text":"compute_coefficients(u, D::AbstractDerivativeOperator)\n\nCompute the nodal values of the function u at the grid associated to the derivative operator D.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#PolynomialBases.evaluate_coefficients!-Tuple{Any, Any, Any, SummationByPartsOperators.AbstractDerivativeOperator}","page":"API reference","title":"PolynomialBases.evaluate_coefficients!","text":"evaluate_coefficients!(xplot, uplot, u, D::AbstractDerivativeOperator)\n\nEvaluates the nodal coefficients u at a grid associated to the derivative operator D and stores the result in xplot, uplot. Returns xplot, uplot, where xplot contains the nodes and uplot the corresponding values of u.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#PolynomialBases.evaluate_coefficients-Tuple{Any, SummationByPartsOperators.AbstractDerivativeOperator}","page":"API reference","title":"PolynomialBases.evaluate_coefficients","text":"evaluate_coefficients(u, D::AbstractDerivativeOperator)\n\nEvaluates the nodal coefficients u at a grid associated to the derivative operator D. Returns xplot, uplot, where xplot contains the nodes and uplot the corresponding values of u.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#PolynomialBases.integrate-Tuple{Any, AbstractVector{T} where T, DerivativeOperator}","page":"API reference","title":"PolynomialBases.integrate","text":"integrate(func, u, D::DerivativeOperator)\n\nMap the function func to the coefficients u and integrate with respect to the quadrature rule associated with the SBP derivative operator D.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#PolynomialBases.integrate-Tuple{Any, AbstractVector{T} where T, PeriodicDerivativeOperator}","page":"API reference","title":"PolynomialBases.integrate","text":"integrate(func, u, D::PeriodicDerivativeOperator)\n\nMap the function func to the coefficients u and integrate with respect to the quadrature rule associated with the periodic derivative operator D.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#PolynomialBases.integrate-Tuple{Any, AbstractVector{T} where T, SummationByPartsOperators.AbstractPeriodicDerivativeOperator}","page":"API reference","title":"PolynomialBases.integrate","text":"integrate(func, u, D::AbstractPeriodicDerivativeOperator)\n\nMap the function func to the coefficients u and integrate with respect to the quadrature rule associated with the derivative operator D.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.accuracy_order","page":"API reference","title":"SummationByPartsOperators.accuracy_order","text":"accuracy_order(D)\n\nReturn the order of accuracy of a derivative operator D. For SBP finite difference operators, this refers to the interior order of accuracy.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.derivative_left-Tuple{SummationByPartsOperators.AbstractNonperiodicDerivativeOperator, Any}","page":"API reference","title":"SummationByPartsOperators.derivative_left","text":"derivative_left(D::AbstractNonperiodicDerivativeOperator, der_order)\n\nGet a representation of the linear functional evaluation the Nth derivative at the left boundary node as (dense) vector.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.derivative_left-Union{Tuple{N}, Tuple{DerivativeOperator, Any, Val{N}}} where N","page":"API reference","title":"SummationByPartsOperators.derivative_left","text":"derivative_left(D::DerivativeOperator, u, der_order::Val{N})\n\nCompute the N-th derivative of the function given by the coefficients u at the left boundary of the grid.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.derivative_operator","page":"API reference","title":"SummationByPartsOperators.derivative_operator","text":"derivative_operator(source_of_coefficients,\n                    derivative_order, accuracy_order,\n                    xmin, xmax, N, mode=FastMode())\nderivative_operator(source_of_coefficients;\n                    derivative_order, accuracy_order,\n                    xmin, xmax, N, mode=FastMode())\n\nCreate a DerivativeOperator approximating the derivative_order-th derivative on a grid between xmin and xmax with N grid points up to order of accuracy accuracy_order. with coefficients given by source_of_coefficients. The evaluation of the derivative can be parallized using threads by chosing mode=ThreadedMode().\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.derivative_order","page":"API reference","title":"SummationByPartsOperators.derivative_order","text":"derivative_order(D)\n\nReturn the order of the derivative associated to the derivative operator D. For example, it will return 1 for a first-derivative SBP operator.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.derivative_right-Tuple{SummationByPartsOperators.AbstractNonperiodicDerivativeOperator, Any}","page":"API reference","title":"SummationByPartsOperators.derivative_right","text":"derivative_right(D::AbstractNonperiodicDerivativeOperator, der_order)\n\nGet a representation of the linear functional evaluation the Nth derivative at the right boundary node as (dense) vector.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.derivative_right-Union{Tuple{N}, Tuple{DerivativeOperator, Any, Val{N}}} where N","page":"API reference","title":"SummationByPartsOperators.derivative_right","text":"derivative_right(D::DerivativeOperator, u, der_order::Val{N})\n\nCompute the N-th derivative of the function given by the coefficients u at the right boundary of the grid.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.dissipation_operator","page":"API reference","title":"SummationByPartsOperators.dissipation_operator","text":"dissipation_operator(source_of_coefficients, order, xmin, xmax, N,\n                     left_weights, right_weights, mode=FastMode())\n\nCreate a negative semidefinite DissipationOperator using undivided differences approximating a weighted order-th derivative on a grid between xmin and xmax with N grid points up to order of accuracy 2 with coefficients given by source_of_coefficients. The norm matrix is given by left_weights and right_weights. The evaluation of the derivative can be parallized using threads by chosing mode=ThreadedMode().\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.dissipation_operator-Tuple{PeriodicDerivativeOperator}","page":"API reference","title":"SummationByPartsOperators.dissipation_operator","text":"dissipation_operator(D::PeriodicDerivativeOperator;\n                     strength=one(eltype(D)),\n                     order=accuracy_order(D),\n                     mode=D.coefficients.mode)\n\nCreate a negative semidefinite DissipationOperator using undivided differences approximating a order-th derivative with strength strength adapted to the derivative operator D. The evaluation of the derivative can be parallized using threads by chosing mode=ThreadedMode().\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.dissipation_operator-Union{Tuple{T}, Tuple{Any, DerivativeOperator{T, LeftBoundary, RightBoundary, LeftBoundaryDerivatives, RightBoundaryDerivatives, LowerOffset, UpperOffset, LeftWidth, RightWidth, ExecutionMode, SourceOfCoefficients, Grid} where {LeftBoundary, RightBoundary, LeftBoundaryDerivatives, RightBoundaryDerivatives, LowerOffset, UpperOffset, LeftWidth, RightWidth, ExecutionMode, SourceOfCoefficients, Grid}}} where T","page":"API reference","title":"SummationByPartsOperators.dissipation_operator","text":"dissipation_operator([source_of_coefficients=MattssonSvÃ¤rdNordstrÃ¶m2004()],\n                     D::DerivativeOperator{T};\n                     strength=one(T),\n                     order::Int=accuracy_order(D),\n                     mode=D.coefficients.mode)\n\nCreate a negative semidefinite DissipationOperator using undivided differences approximating a weighted order-th derivative adapted to the derivative operator D with coefficients given in source_of_coefficients. The evaluation of the derivative can be parallized using threads by chosing mode=ThreadedMode().\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.fornberg-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T","page":"API reference","title":"SummationByPartsOperators.fornberg","text":"fornberg(x::Vector{T}, m::Int) where {T}\n\nCalculate the weights of a finite difference approximation of the mth derivative with maximal order of accuracy at 0 using the nodes x, see Fornberg (1998) Calculation of Weights in Finite Difference Formulas SIAM Rev. 40.3, pp. 685-691.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.fourier_derivative_matrix","page":"API reference","title":"SummationByPartsOperators.fourier_derivative_matrix","text":"fourier_derivative_matrix(N, xmin::Real=0.0, xmax::Real=2Ï€)\n\nCompute the Fourier derivative matrix with respect to the corresponding nodal basis using N nodes, see Kopriva (2009) Implementing Spectral Methods for PDEs, Algorithm 18.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.fourier_derivative_operator-Tuple{Real, Real, Integer}","page":"API reference","title":"SummationByPartsOperators.fourier_derivative_operator","text":"fourier_derivative_operator(xmin::Real, xmax::Real, N::Integer)\nfourier_derivative_operator(; xmin::Real, xmax::Real, N::Integer)\n\nConstruct the FourierDerivativeOperator on a uniform grid between xmin and xmax using N nodes and NÃ·2+1 complex Fourier modes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.grid","page":"API reference","title":"SummationByPartsOperators.grid","text":"grid(D)\n\nReturn the grid associated to a derivative operator D.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.left_boundary_weight","page":"API reference","title":"SummationByPartsOperators.left_boundary_weight","text":"left_boundary_weight(D)\n\nReturn the left-boundary weight of the (diagonal) mass matrix M associated to the derivative operator D.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.legendre_derivative_operator-Tuple{Real, Real, Integer}","page":"API reference","title":"SummationByPartsOperators.legendre_derivative_operator","text":"legendre_derivative_operator(xmin::Real, xmax::Real, N::Integer)\nlegendre_derivative_operator(; xmin::Real, xmax::Real, N::Integer)\n\nConstruct the LegendreDerivativeOperator on a uniform grid between xmin and xmax using N nodes and N-1 Legendre modes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.legendre_second_derivative_operator-Tuple{Real, Real, Integer}","page":"API reference","title":"SummationByPartsOperators.legendre_second_derivative_operator","text":"legendre_second_derivative_operator(xmin::Real, xmax::Real, N::Integer)\nlegendre_second_derivative_operator(; xmin::Real, xmax::Real, N::Integer)\n\nConstruct the LegendreDerivativeOperator on a uniform grid between xmin and xmax using N nodes and N-1 Legendre modes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.mass_matrix-Tuple{Union{DerivativeOperator, VarCoefDerivativeOperator}}","page":"API reference","title":"SummationByPartsOperators.mass_matrix","text":"mass_matrix(D::Union{DerivativeOperator,VarCoefDerivativeOperator})\n\nCreate the diagonal mass matrix for the SBP derivative operator D.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.mul_transpose_derivative_left!-Union{Tuple{N}, Tuple{AbstractVector{T} where T, DerivativeOperator, Val{N}}, Tuple{AbstractVector{T} where T, DerivativeOperator, Val{N}, Any}, Tuple{AbstractVector{T} where T, DerivativeOperator, Val{N}, Any, Any}} where N","page":"API reference","title":"SummationByPartsOperators.mul_transpose_derivative_left!","text":"mul_transpose_derivative_left!(u, D::DerivativeOperator, der_order::Val{N}, Î±=true, Î²=false)\n\nSet the grid function u to Î± times the transposed N-th derivative functional applied to u plus Î² times u in the domain of the N-th derivative functional at the left boundary of the grid. Thus, the coefficients Î±, Î² have the same meaning as in mul!.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.mul_transpose_derivative_right!-Union{Tuple{N}, Tuple{AbstractVector{T} where T, DerivativeOperator, Val{N}}, Tuple{AbstractVector{T} where T, DerivativeOperator, Val{N}, Any}, Tuple{AbstractVector{T} where T, DerivativeOperator, Val{N}, Any, Any}} where N","page":"API reference","title":"SummationByPartsOperators.mul_transpose_derivative_right!","text":"mul_transpose_derivative_right!(u, D::DerivativeOperator, der_order::Val{N}, Î±=true, Î²=false)\n\nSet the grid function u to Î± times the transposed N-th derivative functional applied to u plus Î² times u in the domain of the N-th derivative functional at the right boundary of the grid. Thus, the coefficients Î±, Î² have the same meaning as in mul!.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.periodic_central_derivative_coefficients","page":"API reference","title":"SummationByPartsOperators.periodic_central_derivative_coefficients","text":"periodic_central_derivative_coefficients(derivative_order, accuracy_order, T=Float64, mode=FastMode())\n\nCreate the PeriodicDerivativeCoefficients approximating the derivative_order-th derivative with an order of accuracy accuracy_order and scalar type T. The evaluation of the derivative can be parallized using threads by chosing mode=ThreadedMode()).\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.periodic_central_derivative_operator","page":"API reference","title":"SummationByPartsOperators.periodic_central_derivative_operator","text":"periodic_central_derivative_operator(derivative_order, accuracy_order,\n                                     xmin, xmax, N, mode=FastMode())\n\nCreate a PeriodicDerivativeOperator approximating the derivative_order-th derivative on a uniform grid between xmin and xmax with N grid points up to order of accuracy accuracy_order. The evaluation of the derivative can be parallized using threads by chosing mode=ThreadedMode().\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.periodic_derivative_coefficients","page":"API reference","title":"SummationByPartsOperators.periodic_derivative_coefficients","text":"periodic_derivative_coefficients(derivative_order, accuracy_order,\n                                 left_offset=-(accuracy_order+1)Ã·2,\n                                 T=Float64, mode=FastMode())\n\nCreate the PeriodicDerivativeCoefficients approximating the derivative_order-th derivative with an order of accuracy accuracy_order and scalar type T where the leftmost grid point used is determined by left_offset. The evaluation of the derivative can be parallized using threads by chosing mode=ThreadedMode()`.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.periodic_derivative_coefficients-Tuple{Holoborodko2008, Any, Any}","page":"API reference","title":"SummationByPartsOperators.periodic_derivative_coefficients","text":"periodic_derivative_coefficients(source::Holoborodko2008, derivative_order, accuracy_order;\n                                 T=Float64, mode=FastMode(),\n                                 stencil_width=accuracy_order+3)\n\nCreate the PeriodicDerivativeCoefficients approximating the derivative_order-th derivative with an order of accuracy accuracy_order and scalar type T given by Holoborodko2008. The evaluation of the derivative can be parallized using threads by chosing mode=ThreadedMode()`.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.periodic_derivative_operator","page":"API reference","title":"SummationByPartsOperators.periodic_derivative_operator","text":"periodic_derivative_operator(derivative_order, accuracy_order,\n                             xmin, xmax, N,\n                             left_offset=-(accuracy_order+1)Ã·2,\n                             mode=FastMode())\nperiodic_derivative_operator(; derivative_order, accuracy_order,\n                             xmin, xmax, N,\n                             left_offset=-(accuracy_order+1)Ã·2,\n                             mode=FastMode())\n\nCreate a PeriodicDerivativeOperator approximating the derivative_order-th derivative on a uniform grid between xmin and xmax with N grid points up to order of accuracy accuracy_order where the leftmost grid point used is determined by left_offset. The evaluation of the derivative can be parallized using threads by chosing mode=ThreadedMode()).\n\nExamples\n\njulia> periodic_derivative_operator(derivative_order=1, accuracy_order=2,\n                                    xmin=0.0, xmax=1.0, N=11)\nPeriodic first-derivative operator of order 2 on a grid in [0.0, 1.0] using 11 nodes,\nstencils with 1 nodes to the left, 1 nodes to the right, and coefficients of Fornberg (1998)\n  Calculation of Weights in Finite Difference Formulas.\n  SIAM Rev. 40.3, pp. 685-691.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.periodic_derivative_operator-2","page":"API reference","title":"SummationByPartsOperators.periodic_derivative_operator","text":"periodic_derivative_operator(derivative_order, accuracy_order, grid,\n                             left_offset=-(accuracy_order+1)Ã·2, mode=FastMode())\n\nCreate a PeriodicDerivativeOperator approximating the derivative_order-th derivative on thr uniform grid up to order of accuracy accuracy_order where the leftmost grid point used is determined by left_offset. The evaluation of the derivative can be parallized using threads by chosing mode=ThreadedMode()).\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.periodic_derivative_operator-Tuple{Holoborodko2008, Any, Any, Any, Any, Any}","page":"API reference","title":"SummationByPartsOperators.periodic_derivative_operator","text":"periodic_derivative_operator(source::Holoborodko2008,\n                             derivative_order, accuracy_order,\n                             xmin, xmax, N; mode=FastMode(), kwargs...)\nperiodic_derivative_operator(source::Holoborodko2008;\n                             derivative_order, accuracy_order,\n                             xmin, xmax, N, mode=FastMode(), kwargs...)\n\nCreate a PeriodicDerivativeOperator approximating the derivative_order-th derivative on a uniform grid between xmin and xmax with N grid points up to order of accuracy accuracy_order where the leftmost grid point used is determined by left_offset. The evaluation of the derivative can be parallized using threads by chosing mode=ThreadedMode().\n\nExamples\n\njulia> periodic_derivative_operator(Holoborodko2008(), derivative_order=1, accuracy_order=2,\n                                    xmin=0.0, xmax=1.0, N=11)\nPeriodic first-derivative operator of order 2 on a grid in [0.0, 1.0] using 11 nodes,\nstencils with 2 nodes to the left, 2 nodes to the right, and coefficients of   Holoborodko (2008)\n  Smooth Noise Robust Differentiators.\n  http://www.holoborodko.com/pavel/numerical-methods/numerical-derivative/smooth-low-noise-differentiators/\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.right_boundary_weight","page":"API reference","title":"SummationByPartsOperators.right_boundary_weight","text":"right_boundary_weight(D)\n\nReturn the left-boundary weight of the (diagonal) mass matrix M associated to the derivative operator D.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.semidiscretize-Tuple{Any, SummationByPartsOperators.AbstractSemidiscretization, Any}","page":"API reference","title":"SummationByPartsOperators.semidiscretize","text":"semidiscretize(u0func, semi::AbstractSemidiscretization, tspan)\n\nApply the semidiscretization semi to the initial data given by u0func and return an ODEProblem with time span tspan.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.source_of_coefficients-Tuple{Any}","page":"API reference","title":"SummationByPartsOperators.source_of_coefficients","text":"source_of_coefficients(D)\n\nReturn the source of coefficients of the derivative operator D. If you use the operator D for your research, please cite this source in addition to SummationByPartsOperators.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SummationByPartsOperators.var_coef_derivative_operator","page":"API reference","title":"SummationByPartsOperators.var_coef_derivative_operator","text":"var_coef_derivative_operator(source_of_coefficients, derivative_order, accuracy_order,\n                             xmin, xmax, N, left_weights, right_weights, bfunc,\n                             mode=FastMode())\n\nCreate a VarCoefDerivativeOperator approximating a derivative_order-th derivative with variable coefficients bfunc on a grid between xmin and xmax with N grid points up to order of accuracy accuracy_order with coefficients given by source_of_coefficients. The evaluation of the derivative can be parallized using threads by chosing mode=ThreadedMode().\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.xmax","page":"API reference","title":"SummationByPartsOperators.xmax","text":"xmax(D)\n\nReturn the right boundary xmax of the domain specified when constructing the derivative operator D. Note that this might be different from the rightmost node of the grid of D when not all boundary nodes are included, e.g., for periodic derivative operators.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SummationByPartsOperators.xmin","page":"API reference","title":"SummationByPartsOperators.xmin","text":"xmin(D)\n\nReturn the left boundary xmin of the domain specified when constructing the derivative operator D. Note that this might be different from the leftmost node of the grid of D when not all boundary nodes are included, e.g., for periodic derivative operators.\n\n\n\n\n\n","category":"function"},{"location":"license/","page":"License","title":"License","text":"EditURL = \"https://github.com/ranocha/SummationByPartsOperators.jl/blob/main/LICENSE.md\"","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2017-present Hendrik Ranocha <mail@ranocha.de>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"tutorials/wave_equation/#Wave-equation","page":"Wave equation","title":"Wave equation","text":"","category":"section"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"Consider the linear wave equation","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"beginaligned\n    partial_t^2 u(tx) = partial_x^2 u(tx)  t in (0T) x in (x_min x_max) \n    u(0x) = u_0(x)  x in (x_min x_max) \n    partial_t u(0x) = v_0(x)  x in (x_min x_max) \n    textboundary conditions  x in partial (x_min x_max)\nendaligned","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"SummationByPartsOperators.jl includes a pre-built semidiscretization of this equation: WaveEquationNonperiodicSemidiscretization. Have a look at the source code if you want to dig deeper. In particular, you can find applications of derivative_left, derivative_right mul_transpose_derivative_left!, and mul_transpose_derivative_right!. Below is an example demonstrating how to use this semidiscretization.","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"using SummationByPartsOperators, OrdinaryDiffEq\nusing LaTeXStrings; using Plots: Plots, plot, plot!, savefig\n\n# general parameters\nxmin = -1.\nxmax = +1.\ntspan = (0., 8.0)\nu0_func(x) = exp(-20x^2)\nv0_func(x) = zero(x)\n# HomogeneousNeumann, HomogeneousDirichlet, and NonReflecting BCs are available\nleft_bc  = Val(:HomogeneousNeumann)\nright_bc = Val(:HomogeneousDirichlet)\n\n# setup spatial semidiscretization\nD2 = derivative_operator(MattssonSvÃ¤rdShoeybi2008(), derivative_order=2,\n                         accuracy_order=4, xmin=xmin, xmax=xmax, N=101)\nsemi = WaveEquationNonperiodicSemidiscretization(D2, left_bc, right_bc)\node = semidiscretize(v0_func, u0_func, semi, tspan)\n\n# solve second-order ODE using a Runge-Kutta-NystrÃ¶m method\nsol = solve(ode, DPRKN6(), saveat=range(first(tspan), stop=last(tspan), length=200))\n\n# visualize the result\nplot(xguide=L\"x\")\nplot!(evaluate_coefficients(sol[end].x[2], semi), label=L\"u\")\nplot!(evaluate_coefficients(sol[end].x[1], semi), label=L\"\\partial_t u\")\nsavefig(\"example_wave_equation.png\");","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"(Image: )","category":"page"},{"location":"tutorials/wave_equation/#Advanced-visualization-of-different-boundary-conditions","page":"Wave equation","title":"Advanced visualization of different boundary conditions","text":"","category":"section"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"Let's create animations of the numerical solutions for different boundary conditions.","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"using Printf; using Plots: Animation, frame, gif\n\nfunction create_gif(left_bc::Val{LEFT_BC}, right_bc::Val{RIGHT_BC}) where {LEFT_BC, RIGHT_BC}\n    xmin = -1.\n    xmax = +1.\n    tspan = (0., 8.0)\n    u0_func(x) = exp(-20x^2)\n    v0_func(x) = zero(x)\n\n    D2 = derivative_operator(MattssonSvÃ¤rdShoeybi2008(), derivative_order=2,\n                            accuracy_order=4, xmin=xmin, xmax=xmax, N=101)\n    semi = WaveEquationNonperiodicSemidiscretization(D2, left_bc, right_bc)\n    ode = semidiscretize(v0_func, u0_func, semi, tspan)\n\n    sol = solve(ode, DPRKN6(), saveat=range(first(tspan), stop=last(tspan), length=200))\n\n    anim = Animation()\n    idx = 1\n    x, u = evaluate_coefficients(sol[idx].x[2], D2)\n    fig = plot(x, u, xguide=L\"x\", yguide=L\"u\", xlim=extrema(x), ylim=(-1.05, 1.05),\n              label=\"\", title=@sprintf(\"\\$t = %6.2f \\$\", sol.t[idx]))\n    for idx in 1:length(sol.t)\n        fig[1] = x, sol.u[idx].x[2]\n        plot!(title=@sprintf(\"\\$t = %6.2f \\$\", sol.t[idx]))\n        frame(anim)\n    end\n    gif(anim, \"wave_equation_$(LEFT_BC)_$(RIGHT_BC).gif\")\nend\n\ncreate_gif(Val(:HomogeneousNeumann), Val(:HomogeneousNeumann))","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"(Image: wave_equation_HomogeneousNeumann_HomogeneousNeumann)","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"create_gif(Val(:HomogeneousNeumann), Val(:HomogeneousDirichlet))","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"(Image: wave_equation_HomogeneousNeumann_HomogeneousDirichlet)","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"create_gif(Val(:HomogeneousNeumann), Val(:NonReflecting))","category":"page"},{"location":"tutorials/wave_equation/","page":"Wave equation","title":"Wave equation","text":"(Image: wave_equation_HomogeneousNeumann_NonReflecting)","category":"page"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Summation-by-parts (SBP) operators are discrete derivative operators designed to enable (semi-) discrete stability proofs mimicking the energy method from the continuous level. To do so, SBP operators mimic integration-by-parts discretely. Here, we will briefly explain the basic concepts. If you want to learn more about this subject, the classical review articles of [SvÃ¤rdNordstrÃ¶m2014] and [FernÃ¡ndezHickenZingg2014] are good starting points. More recent references and applications of SBP operators from many classes implemented in SummationByPartsOperators.jl are given by [RanochaMitsotakisKetcheson2021].","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Since SBP operators are designed to mimic integration-by-parts, they need a notion of derivatives and integrals. Here, derivatives are interpreted as linear operators D (derivative matrices) and integrals are interpreted as discrete inner products, represented by the associated mass/norm matrices M. Thus, the discrete derivative of a grid function u is D * u and the discrete inner product of two grid functions u and v is dot(u, M, v), where M = mass_matrix(D). Here, we have already introduced some basic interfaces provided by SummationByPartsOperators.jl:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Derivative operators act as linear operators implementing * (and mul! for more efficient in-place updates avoiding allocations).\nThe mass matrix associated to an SBP derivative operator can be retrieved via mass_matrix.","category":"page"},{"location":"introduction/#Periodic-domains","page":"Introduction","title":"Periodic domains","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Periodic (central) SBP operators mimic the properties of differential operators on periodic domains. Hence, they are","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"skew-symmetric if they approximate odd derivatives\nsymmetric and semi-definite if they approximate even derivatives; second-derivative operators are negative semi-definite, fourth-derivative operators are positive semi-definite etc.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Classical central finite difference operators on periodic domains are periodic SBP operators. They can be constructed via periodic_derivative_operator. Similarly, Fourier collocation methods can be interpreted as periodic SBP operators, which can be constructed via fourier_derivative_operator.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> using SummationByPartsOperators, LinearAlgebra\n\njulia> D = periodic_derivative_operator(derivative_order=1, accuracy_order=2,\n                                        xmin=0.0, xmax=2.0, N=20)\nPeriodic first-derivative operator of order 2 on a grid in [0.0, 2.0] using 20 nodes,\nstencils with 1 nodes to the left, 1 nodes to the right, and coefficients of Fornberg (1998)\n  Calculation of Weights in Finite Difference Formulas.\n  SIAM Rev. 40.3, pp. 685-691.\n\njulia> M = mass_matrix(D)\nUniformScaling{Float64}\n0.1*I\n\njulia> M * Matrix(D) + Matrix(D)' * M |> norm\n0.0\n\njulia> D = fourier_derivative_operator(xmin=0.0, xmax=2.0, N=20)\nPeriodic 1st derivative Fourier operator {T=Float64}\non a grid in [0.0, 2.0] using 20 nodes and 11 modes\n\njulia> M = mass_matrix(D)\nUniformScaling{Float64}\n0.1*I\n\njulia> norm(M * Matrix(D) + Matrix(D)' * M) < 10 * eps(eltype(D))\ntrue","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"As you have seen above, conversion methods to other common types such as Matrix, sparse from the standard library SparseArrays, and BandedMatrix from BandedMatrices.jl are available.","category":"page"},{"location":"introduction/#Non-periodic-domains","page":"Introduction","title":"Non-periodic domains","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"On non-periodic domains, additional boundary terms appear. Thus, the basic symmetry properties of SBP operators are the same as the ones of periodic SBP operators modulo boundary terms. Note that the correct handling of boundary terms is the basic reason of the success of SBP operators. In particular for hyperbolic problems, other boundary treatments that might appear senseful can result in catastrophic failure.","category":"page"},{"location":"introduction/#First-derivative-operators","page":"Introduction","title":"First-derivative operators","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"First-derivative SBP operators need to mimic","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"  int_x_mathrmmin^x_mathrmmax u(x) bigl( partial_x v(x) bigr) mathrmdx\n+ int_x_mathrmmin^x_mathrmmax bigl( partial_x u(x) bigr) v(x) mathrmdx\n= u(x_mathrmmax) v(x_mathrmmax) - u(x_mathrmmin) v(x_mathrmmin)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Thus, a discrete evaluation at the boundary of the domain is necessary. For SBP operators with a grid including the boundary nodes, this can be achieved by simply picking the first/last nodal coefficient of a grid function u. If boundary nodes are not included, some interpolation is necessary in general. Nevertheless, getting a boundary value is a linear functional that is often represented in the literature using (transposed) vectors tL, tR. Then, an SBP operator has to satisfy M * D + D' * M == tR * tR' - tL * tL'. The boundary operators are represented matrix-free via derivative_left and derivative_right for zeroth-order derivatives.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"``jldoctest; filter = r\"((â”Œ.*[\\n\\r]+)(â”‚LoopVectorization.check_argson your inputs failed; running fallback@inbounds @fastmath` loop instead.[\\n\\r]+)(â”‚.[\\n\\r]+)(â””.*[\\n\\r]+))\" julia> using SummationByPartsOperators, LinearAlgebra","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> D = derivativeoperator(MattssonNordstrÃ¶m2004(), derivativeorder=1, accuracy_order=2,                                xmin=0//1, xmax=1//1, N=9) SBP first-derivative operator of order 2 on a grid in [0//1, 1//1] using 9 nodes and coefficients of Mattsson, NordstrÃ¶m (2004)   Summation by parts operators for finite difference approximations of second     derivatives.   Journal of Computational Physics 199, pp. 503-540.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> tL = zeros(eltype(D), size(D, 1)); tL[1] = 1; tL' 1Ã—9 adjoint(::Vector{Rational{Int64}}) with eltype Rational{Int64}:  1//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> tR = zeros(eltype(D), size(D, 1)); tR[end] = 1; tR' 1Ã—9 adjoint(::Vector{Rational{Int64}}) with eltype Rational{Int64}:  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  1//1","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> M = mass_matrix(D) 9Ã—9 Diagonal{Rational{Int64}, Vector{Rational{Int64}}}:  1//16   â‹…     â‹…     â‹…     â‹…     â‹…     â‹…     â‹…     â‹…   â‹…     1//8   â‹…     â‹…     â‹…     â‹…     â‹…     â‹…     â‹…   â‹…      â‹…    1//8   â‹…     â‹…     â‹…     â‹…     â‹…     â‹…   â‹…      â‹…     â‹…    1//8   â‹…     â‹…     â‹…     â‹…     â‹…   â‹…      â‹…     â‹…     â‹…    1//8   â‹…     â‹…     â‹…     â‹…   â‹…      â‹…     â‹…     â‹…     â‹…    1//8   â‹…     â‹…     â‹…   â‹…      â‹…     â‹…     â‹…     â‹…     â‹…    1//8   â‹…     â‹…   â‹…      â‹…     â‹…     â‹…     â‹…     â‹…     â‹…    1//8   â‹…   â‹…      â‹…     â‹…     â‹…     â‹…     â‹…     â‹…     â‹…    1//16","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> M * Matrix(D) + Matrix(D)' * M == tR * tR' - tL * tL' true","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> u = randn(size(grid(D))); derivative_left(D, u, Val(0)) == u[begin] true","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> u = randn(size(grid(D))); derivative_right(D, u, Val(0)) == u[end] true","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"\nHere, we have introduced some additional features. Firstly, exact rational\ncoefficients are provided, based on the type of `xmin` and `xmax` (if available).\nSecondly, a [`source_of_coefficients`](@ref) has to be provided when constructing\nthe SBP operator. You can list them using","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"@example using InteractiveUtils, SummationByPartsOperators subtypes(SourceOfCoefficients)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Here and in the following, the order of accuracy of (finite difference) SBP\noperators refers to the local order of accuracy in the interior, cf.\n[`accuracy_order`](@ref).\n\nA special case of first-derivative SBP operators are polynomial derivative operators\non Lobatto-Legendre nodes, implemented in [`legendre_derivative_operator`](@ref).\n\n### Second-derivative operators\n\nTo mimic integration-by-parts of second derivatives,","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"math   \\int{x\\mathrm{min}}^{x\\mathrm{max}} u(x) \\bigl( \\partialx^2 v(x) \\bigr) \\mathrm{d}x = - \\int{x\\mathrm{min}}^{x\\mathrm{max}} \\bigl( \\partialx u(x) \\bigr) \\bigl( \\partial_x v(x) \\bigr) \\mathrm{d}x","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"u(x\\mathrm{max}) \\bigl( \\partialx v(x_\\mathrm{max}) \\bigr)\n\\bigl( \\partialx u(x\\mathrm{min})) v(x_\\mathrm{min}),","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"the evaluation of the first derivative at the boundaries is necessary. These\nlinear functionals are available as [`derivative_left`](@ref) and\n[`derivative_right`](@ref). In the literature, they are often called `dL` and\n`dR`. Then, a second-derivative SBP operator has to be of the form\n`M * D == -A + tR * dR' - tL * dL'`, where `A` is symmetric and positive\nsemidefinite.\n","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"jldoctest julia> using SummationByPartsOperators, LinearAlgebra","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> D = derivativeoperator(MattssonNordstrÃ¶m2004(), derivativeorder=2, accuracy_order=2,                                xmin=0//1, xmax=1//1, N=9) SBP second-derivative operator of order 2 on a grid in [0//1, 1//1] using 9 nodes and coefficients of Mattsson, NordstrÃ¶m (2004)   Summation by parts operators for finite difference approximations of second     derivatives.   Journal of Computational Physics 199, pp. 503-540.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> M = mass_matrix(D) 9Ã—9 Diagonal{Rational{Int64}, Vector{Rational{Int64}}}:  1//16   â‹…     â‹…     â‹…     â‹…     â‹…     â‹…     â‹…     â‹…   â‹…     1//8   â‹…     â‹…     â‹…     â‹…     â‹…     â‹…     â‹…   â‹…      â‹…    1//8   â‹…     â‹…     â‹…     â‹…     â‹…     â‹…   â‹…      â‹…     â‹…    1//8   â‹…     â‹…     â‹…     â‹…     â‹…   â‹…      â‹…     â‹…     â‹…    1//8   â‹…     â‹…     â‹…     â‹…   â‹…      â‹…     â‹…     â‹…     â‹…    1//8   â‹…     â‹…     â‹…   â‹…      â‹…     â‹…     â‹…     â‹…     â‹…    1//8   â‹…     â‹…   â‹…      â‹…     â‹…     â‹…     â‹…     â‹…     â‹…    1//8   â‹…   â‹…      â‹…     â‹…     â‹…     â‹…     â‹…     â‹…     â‹…    1//16","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> tL = derivative_left(D, Val(0)); tL' 1Ã—9 adjoint(::Vector{Bool}) with eltype Bool:  1  0  0  0  0  0  0  0  0","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> tR = derivative_right(D, Val(0)); tR' 1Ã—9 adjoint(::Vector{Bool}) with eltype Bool:  0  0  0  0  0  0  0  0  1","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> dL = derivative_left(D, Val(1)); dL' 1Ã—9 adjoint(::Vector{Rational{Int64}}) with eltype Rational{Int64}:  -12//1  16//1  -4//1  0//1  0//1  0//1  0//1  0//1  0//1","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> dR = derivative_right(D, Val(1)); dR' 1Ã—9 adjoint(::Vector{Rational{Int64}}) with eltype Rational{Int64}:  0//1  0//1  0//1  0//1  0//1  0//1  4//1  -16//1  12//1","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> A = -M * Matrix(D) + tR * dR' - tL * dL' 9Ã—9 Matrix{Rational{Int64}}:   8//1  -8//1   0//1   0//1   0//1   0//1   0//1   0//1   0//1  -8//1  16//1  -8//1   0//1   0//1   0//1   0//1   0//1   0//1   0//1  -8//1  16//1  -8//1   0//1   0//1   0//1   0//1   0//1   0//1   0//1  -8//1  16//1  -8//1   0//1   0//1   0//1   0//1   0//1   0//1   0//1  -8//1  16//1  -8//1   0//1   0//1   0//1   0//1   0//1   0//1   0//1  -8//1  16//1  -8//1   0//1   0//1   0//1   0//1   0//1   0//1   0//1  -8//1  16//1  -8//1   0//1   0//1   0//1   0//1   0//1   0//1   0//1  -8//1  16//1  -8//1   0//1   0//1   0//1   0//1   0//1   0//1   0//1  -8//1   8//1","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> isposdef(A) true","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Usually, there is no need to form `dL, dR` explicitly. Instead, you can use the\nmatrix-free variants [`derivative_left`](@ref) and [`derivative_right`](@ref).\nSome procedures imposing boundary conditions weakly require adding the transposed\nboundary derivatives to a grid function, which can be achieved by\n[`mul_transpose_derivative_left!`](@ref) and [`mul_transpose_derivative_right!`](@ref).\nYou can find applications of these operators in the source code of\n[`WaveEquationNonperiodicSemidiscretization`](@ref).\n\nA special case of second-derivative SBP operators are polynomial derivative operators\non Lobatto-Legendre nodes, implemented in [`legendre_second_derivative_operator`](@ref).\n\n\n## Upwind operators\n\nUpwind SBP operators were introduced by [`Mattsson2017`](@ref). They combine\ntwo derivative operators `Dp` (`:plus`) and `Dm` (`:minus`) such that\n`M * Dp + Dm' * M == tR * tR' - tL * tL'` and `M * (Dp - Dm)` is negative\nsemidefinite.\n","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"jldoctest julia> using SummationByPartsOperators, LinearAlgebra","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> Dp = derivativeoperator(Mattsson2017(:plus), derivativeorder=1, accuracy_order=2,                                 xmin=0//1, xmax=1//1, N=9) SBP first-derivative operator of order 2 on a grid in [0//1, 1//1] using 9 nodes and coefficients of Mattsson (2017)   Diagonal-norm upwind SBP operators.   Journal of Computational Physics 335, pp. 283-310.   (upwind coefficients plus)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> Dm = derivativeoperator(Mattsson2017(:minus), derivativeorder=1, accuracy_order=2,                                 xmin=0//1, xmax=1//1, N=9) SBP first-derivative operator of order 2 on a grid in [0//1, 1//1] using 9 nodes and coefficients of Mattsson (2017)   Diagonal-norm upwind SBP operators.   Journal of Computational Physics 335, pp. 283-310.   (upwind coefficients minus)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> M = mass_matrix(Dp) 9Ã—9 Diagonal{Rational{Int64}, Vector{Rational{Int64}}}:  1//32   â‹…      â‹…     â‹…     â‹…     â‹…     â‹…     â‹…      â‹…   â‹…     5//32   â‹…     â‹…     â‹…     â‹…     â‹…     â‹…      â‹…   â‹…      â‹…     1//8   â‹…     â‹…     â‹…     â‹…     â‹…      â‹…   â‹…      â‹…      â‹…    1//8   â‹…     â‹…     â‹…     â‹…      â‹…   â‹…      â‹…      â‹…     â‹…    1//8   â‹…     â‹…     â‹…      â‹…   â‹…      â‹…      â‹…     â‹…     â‹…    1//8   â‹…     â‹…      â‹…   â‹…      â‹…      â‹…     â‹…     â‹…     â‹…    1//8   â‹…      â‹…   â‹…      â‹…      â‹…     â‹…     â‹…     â‹…     â‹…    5//32   â‹…   â‹…      â‹…      â‹…     â‹…     â‹…     â‹…     â‹…     â‹…     1//32","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> M * Matrix(Dp) + Matrix(Dm)' * M 9Ã—9 Matrix{Rational{Int64}}:  -1//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1   0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1   0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1   0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1   0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1   0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1   0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1   0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1   0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  1//1","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> minimum(eigvals(-M * (Matrix(Dp) - Matrix(Dm)))) > -100 * eps() # tolerance for zero eigenvalues true","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"\n\n## Continuous and discontinuous Galerkin methods\n\nSBP operators can be coupled to obtain (nodal) continuous Galerkin (CG) methods.\nIf the underlying SBP operators are [`LegendreDerivativeOperator`](@ref)s,\nthese are CG spectral element methods (CGSEM). However, a continuous coupling\nof arbitrary SBP operators is supported.\n","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"jldoctest julia> using SummationByPartsOperators, LinearAlgebra","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> D = couplecontinuously(                legendrederivative_operator(xmin=-1.0, xmax=1.0, N=3),                UniformMesh1D(xmin=0.0, xmax=1.0, Nx=3)) First derivative operator {T=Float64} on 3 Lobatto Legendre nodes in [-1.0, 1.0] coupled continuously on UniformMesh1D{Float64} with 3 cells in (0.0, 1.0)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> Matrix(D) 7Ã—7 Matrix{Float64}:  -9.0  12.0  -3.0   0.0   0.0    0.0   0.0  -3.0   0.0   3.0   0.0   0.0    0.0   0.0   1.5  -6.0   0.0   6.0  -1.5    0.0   0.0   0.0   0.0  -3.0   0.0   3.0    0.0   0.0   0.0   0.0   1.5  -6.0   0.0    6.0  -1.5   0.0   0.0   0.0   0.0  -3.0    0.0   3.0   0.0   0.0   0.0   0.0   3.0  -12.0   9.0","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> mass_matrix(D) 7Ã—7 Diagonal{Float64, Vector{Float64}}:  0.0555556   â‹…         â‹…         â‹…         â‹…         â‹…         â‹…   â‹…         0.222222   â‹…         â‹…         â‹…         â‹…         â‹…   â‹…          â‹…        0.111111   â‹…         â‹…         â‹…         â‹…   â‹…          â‹…         â‹…        0.222222   â‹…         â‹…         â‹…   â‹…          â‹…         â‹…         â‹…        0.111111   â‹…         â‹…   â‹…          â‹…         â‹…         â‹…         â‹…        0.222222   â‹…   â‹…          â‹…         â‹…         â‹…         â‹…         â‹…        0.0555556","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"\nSBP operators can also be coupled as in discontinuous Galerkin (DG) methods.\nUsing a central numerical flux results in central SBP operators; upwind fluxes\nyield upwind SBP operators. If [`LegendreDerivativeOperator`](@ref)s are used,\nthe discontinuous coupling yields DG spectral element methods (DGSEM).\n","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"jldoctest julia> using SummationByPartsOperators, LinearAlgebra","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> D = couplediscontinuously(                legendrederivative_operator(xmin=-1.0, xmax=1.0, N=3),                UniformPeriodicMesh1D(xmin=0.0, xmax=1.0, Nx=3),                Val(:central)) First derivative operator {T=Float64} on 3 Lobatto Legendre nodes in [-1.0, 1.0] coupled discontinuously (upwind: Val{:central}()) on UniformPeriodicMesh1D{Float64} with 3 cells in (0.0, 1.0)","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> M = mass_matrix(D);","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> M * Matrix(D) + Matrix(D)' * M |> iszero true ```","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Right now, only uniform meshes UniformMesh1D and UniformPeriodicMesh1D are implemented.","category":"page"},{"location":"introduction/#Basic-interfaces-and-additional-features","page":"Introduction","title":"Basic interfaces and additional features","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"To actually compute and plot the discrete grid functions, a few additional ingredients are necessary.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The discrete coefficients of a function on the grid of an SBP operator can usually be computed as x = grid(D); u = u_function.(x), at least for nodal bases. In general, compute_coefficients (or the in-place version compute_coefficients!) can also be used for this task.\nTo get a grid and discrete values suitable for plotting, you can use evaluate_coefficients (or the in-place version evaluate_coefficients!). The plot nodes returned from evaluate_coefficients can be different from the nodes of the grid associated to an SBP operator.\nTo implement boundary procedures, the weights of the mass matrix at the boundary are often needed. These can be obtained without forming M = mass_matrix(D) explicitly via left_boundary_weight and right_boundary_weight.\nInstead of forming a mass matrix explicitly, discrete integrals can be evaluated efficiently using integrate.\nDissipation operators based on the same discrete inner product as SBP derivative operators can be obtained via dissipation_operator.","category":"page"},{"location":"introduction/#Next-steps","page":"Introduction","title":"Next steps","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"If you are familiar with SBP operators in general, this introduction might already be enough for you to apply SummationByPartsOperators.jl to your problems. Otherwise, you might want to have a look at the references, the tutorials coming next, or some ready-to-use semidiscretizations of the following partial differential equations (PDEs). These are shipped with this package and you are encouraged to look at their source code to learn more about it.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Linear scalar advection with variable coefficient: VariableLinearAdvectionNonperiodicSemidiscretization\nBurgers' equation (inviscid): BurgersPeriodicSemidiscretization, BurgersNonperiodicSemidiscretization\nScalar conservation law with cubic flux: CubicPeriodicSemidiscretization, CubicNonperiodicSemidiscretization\nA scalar conservation law with quartic, non-convex flux: QuarticNonconvexPeriodicSemidiscretization\nThe second-order wave equation: WaveEquationNonperiodicSemidiscretization","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Some additional examples are included as Jupyter notebooks in the directory notebooks. Even more examples and research articles making use of SummationByPartsOperators.jl are listed in the section Applications. If you want to know even more, you can have a look at the test.","category":"page"},{"location":"introduction/#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"[SvÃ¤rdNordstrÃ¶m2014]: SvÃ¤rd, NordstrÃ¶m (2014). Review of summation-by-parts schemes for initialâ€“boundary-value problems. DOI: 10.1016/j.jcp.2014.02.031","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"[FernÃ¡ndezHickenZingg2014]: FernÃ¡ndez, Hicken, Zingg (2014). Review of summation-by-parts operators with simultaneous approximation terms for the numerical solution of partial differential equations. DOI: 10.1016/j.compfluid.2014.02.016","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"[RanochaMitsotakisKetcheson2021]: Ranocha, Mitsotakis, Ketcheson (2021). A Broad Class of Conservative Numerical Methods for Dispersive Wave Equations. DOI: 10.4208/cicp.OA-2020-0119","category":"page"},{"location":"#SummationByPartsOperators.jl","page":"Home","title":"SummationByPartsOperators.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Julia library SummationByPartsOperators.jl provides a unified interface of different discretization approaches including finite difference, Fourier pseudospectral, continuous Galerkin, and discontinuous Galerkin methods. This unified interface is based on the notion of summation-by-parts (SBP) operators. Originally developed for finite difference methods, SBP operators are discrete derivative operators designed specifically to get provably stable (semi-) discretizations, mimicking energy/entropy estimates from the continuous level discretely and paying special attention to boundary conditions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SummationByPartsOperators.jl is mainly written to be useful for both students learning the basic concepts and researchers developing new numerical algorithms based on SBP operators. Thus, this package uses Julia's multiple dispatch and strong type system to provide a unified framework of all of these seemingly different discretizations while being reasonably optimized at the same time, achieving good performance without sacrificing flexibility.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SummationByPartsOperators.jl is a registered Julia package. Thus, you can install it from the Julia REPL via","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"SummationByPartsOperators\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to update SummationByPartsOperators.jl, you can use","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.update(\"SummationByPartsOperators\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"As usual, if you want to update SummationByPartsOperators.jl and all other packages in your current project, you can execute","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.update()","category":"page"},{"location":"#Basic-examples","page":"Home","title":"Basic examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Compute the derivative on a periodic domain using a central finite difference operator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SummationByPartsOperators\n\njulia> using Plots: plot, plot!\n\njulia> D = periodic_derivative_operator(derivative_order=1, accuracy_order=2,\n                                        xmin=0.0, xmax=2.0, N=20)\nPeriodic first-derivative operator of order 2 on a grid in [0.0, 2.0] using 20 nodes,\nstencils with 1 nodes to the left, 1 nodes to the right, and coefficients of Fornberg (1998)\n  Calculation of Weights in Finite Difference Formulas.\n  SIAM Rev. 40.3, pp. 685-691.\n\njulia> x = grid(D); u = sinpi.(x);\n\njulia> plot(x, D * u, label=\"numerical\")\n\njulia> plot!(x, Ï€ .* cospi.(x), label=\"analytical\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"You should see a plot like the following.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Compute the derivative on a bounded domain using an SBP finite difference operator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SummationByPartsOperators\n\njulia> using Plots: plot, plot!\n\njulia> D = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1, accuracy_order=2,\n                               xmin=0.0, xmax=1.0, N=21)\nSBP first-derivative operator of order 2 on a grid in [0.0, 1.0] using 21 nodes\nand coefficients of Mattsson, NordstrÃ¶m (2004)\n  Summation by parts operators for finite difference approximations of second\n    derivatives.\n  Journal of Computational Physics 199, pp. 503-540.\n\njulia> x = grid(D); u = exp.(x);\n\njulia> plot(x, D * u, label=\"numerical\")\n\njulia> plot!(x, exp.(x), label=\"analytical\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"You should see a plot like the following.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Referencing","page":"Home","title":"Referencing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use SummationByPartsOperators.jl for your research, please cite it using the bibtex entry","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{ranocha2021sbp,\n  title={{SummationByPartsOperators.jl}: {A} {J}ulia library of provably stable\n         semidiscretization techniques with mimetic properties},\n  author={Ranocha, Hendrik},\n  journal={Journal of Open Source Software},\n  year={2021},\n  month={08},\n  doi={10.21105/joss.03454},\n  volume={6},\n  number={64},\n  pages={3454},\n  publisher={The Open Journal},\n  url={https://github.com/ranocha/SummationByPartsOperators.jl}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please also cite the appropriate references for specific SBP operators you use, which can be obtained via source_of_coefficients.","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is licensed under the MIT license (see License). Since it is an open-source project, we are very happy to accept contributions from the community. Please refer to the section Contributing for more details.","category":"page"}]
}
