<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Benchmarks Â· SummationByPartsOperators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/benchmarks/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SummationByPartsOperators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/constant_linear_advection/">Linear advection equation with constant coefficients</a></li><li><a class="tocitem" href="../tutorials/advection_diffusion/">Linear advection diffusion equation with periodic boundary conditions</a></li><li><a class="tocitem" href="../tutorials/variable_linear_advection/">Linear advection equation with variable coefficients</a></li><li><a class="tocitem" href="../tutorials/wave_equation/">Wave equation</a></li></ul></li><li><a class="tocitem" href="../applications/">Applications &amp; references</a></li><li class="is-active"><a class="tocitem" href>Benchmarks</a><ul class="internal"><li><a class="tocitem" href="#First-derivative-operators"><span>First-derivative operators</span></a></li><li><a class="tocitem" href="#Dissipation-operators"><span>Dissipation operators</span></a></li><li><a class="tocitem" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)"><span>Structure-of-Arrays (SoA) and Array-of-Structures (AoS)</span></a></li></ul></li><li><a class="tocitem" href="../api_reference/">API reference</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Benchmarks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Benchmarks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ranocha/SummationByPartsOperators.jl/blob/main/docs/src/benchmarks.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Benchmarks"><a class="docs-heading-anchor" href="#Benchmarks">Benchmarks</a><a id="Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarks" title="Permalink"></a></h1><p>Here are some simple benchmarks. Take them with a grain of salt since they run on virtual machines in the cloud to generate the documentation automatically.</p><h2 id="First-derivative-operators"><a class="docs-heading-anchor" href="#First-derivative-operators">First-derivative operators</a><a id="First-derivative-operators-1"></a><a class="docs-heading-anchor-permalink" href="#First-derivative-operators" title="Permalink"></a></h2><h4 id="Periodic-domains"><a class="docs-heading-anchor" href="#Periodic-domains">Periodic domains</a><a id="Periodic-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-domains" title="Permalink"></a></h4><p>Let&#39;s set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, DiffEqOperators

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = periodic_derivative_operator(derivative_order=1, accuracy_order=2,
                                     xmin=xmin, xmax=xmax, N=100)
x = grid(D_SBP)
D_DEO = CenteredDifference(derivative_order(D_SBP), accuracy_order(D_SBP),
                           step(x), length(x)) * PeriodicBC(eltype(D_SBP))

D_sparse = sparse(D_SBP)

u = randn(eltype(D_SBP), length(x)); du = similar(u);
@show D_SBP * u â‰ˆ D_DEO * u â‰ˆ D_sparse * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>First, we benchmark the implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 987 evaluations.
 Range (min â€¦ max):  51.265 ns â€¦ 93.617 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     51.368 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   51.486 ns Â±  1.139 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

   â–ˆ
  â–ƒâ–ˆâ–ƒâ–‚â–‚â–‚â–‚â–â–â–‚â–â–â–â–â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‚â–â–â–â–â–â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚ â–‚
  51.3 ns         Histogram: frequency by time        56.8 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we compare this to the runtime obtained using a sparse matrix representation of the derivative operator. Depending on the hardware etc., this can be an order of magnitude slower than the optimized implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_sparse, &quot;D_sparse:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_sparse:
BenchmarkTools.Trial: 10000 samples with 257 evaluations.
 Range (min â€¦ max):  302.724 ns â€¦ 574.315 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     303.891 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   304.468 ns Â±   5.299 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

   â–ˆâ–‡
  â–„â–ˆâ–ˆâ–†â–ƒâ–‚â–‚â–‚â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚ â–‚
  303 ns           Histogram: frequency by time          328 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, we benchmark the implementation of the same derivative operator in DiffEqOperators.jl.</p><pre><code class="language-julia hljs">doit(D_DEO, &quot;D_DEO:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_DEO:
â”Œ Warning: #= /home/runner/.julia/packages/DiffEqOperators/NWEwW/src/derivative_operators/convolutions.jl:375 =#:
â”‚ `LoopVectorization.check_args` on your inputs failed; running fallback `@inbounds @fastmath` loop instead.
â”‚ Use `warn_check_args=false`, e.g. `@turbo warn_check_args=false ...`, to disable this warning.
â”” @ DiffEqOperators ~/.julia/packages/LoopVectorization/DyiiG/src/condense_loopset.jl:995
â”Œ Warning: #= /home/runner/.julia/packages/DiffEqOperators/NWEwW/src/derivative_operators/convolutions.jl:419 =#:
â”‚ `LoopVectorization.check_args` on your inputs failed; running fallback `@inbounds @fastmath` loop instead.
â”‚ Use `warn_check_args=false`, e.g. `@turbo warn_check_args=false ...`, to disable this warning.
â”” @ DiffEqOperators ~/.julia/packages/LoopVectorization/DyiiG/src/condense_loopset.jl:995
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min â€¦ max):  1.050 Î¼s â€¦   3.600 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     1.090 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   1.137 Î¼s Â± 114.660 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

   â–…â–‡ â–ˆâ–ˆâ–‡ â–†â–…â–„ â–„â–ƒ â–‚â–‚â–         â–‚â–ƒ â–„â–„â–ƒ â–ƒâ–ƒ â–ƒâ–‚â– â–â–â–                â–ƒ
  â–†â–ˆâ–ˆâ–â–ˆâ–ˆâ–ˆâ–â–ˆâ–ˆâ–ˆâ–â–ˆâ–ˆâ–â–ˆâ–ˆâ–ˆâ–â–ˆâ–ˆâ–†â–â–‡â–‡â–â–ˆâ–ˆâ–ˆâ–â–ˆâ–ˆâ–ˆâ–â–ˆâ–ˆâ–â–ˆâ–ˆâ–ˆâ–â–ˆâ–ˆâ–ˆâ–â–ˆâ–ˆâ–â–ˆâ–ˆâ–ˆâ–â–‡â–‡â–‡â–â–ˆâ–†â–… â–ˆ
  1.05 Î¼s      Histogram: log(frequency) by time      1.48 Î¼s &lt;

 Memory estimate: 416 bytes, allocs estimate: 6.</code></pre><p>These results were obtained using the following versions.</p><pre><code class="language-julia hljs">using InteractiveUtils
versioninfo()

using Pkg
Pkg.status([&quot;SummationByPartsOperators&quot;, &quot;DiffEqOperators&quot;],
           mode=PKGMODE_MANIFEST)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.6.6
Commit b8708f954a (2022-03-28 07:17 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Xeon(R) Platinum 8370C CPU @ 2.80GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-11.0.1 (ORCJIT, icelake-server)
      Status `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl/docs/Manifest.toml`
  [9fdde737] DiffEqOperators v4.43.1
  [9f78cca6] SummationByPartsOperators v0.5.19 `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl`</code></pre><h4 id="Bounded-domains"><a class="docs-heading-anchor" href="#Bounded-domains">Bounded domains</a><a id="Bounded-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Bounded-domains" title="Permalink"></a></h4><p>We start again by setting up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,
                            accuracy_order=6, xmin=xmin, xmax=xmax, N=10^3)
D_sparse = sparse(D_SBP)
D_banded = BandedMatrix(D_SBP)

u = randn(eltype(D_SBP), size(D_SBP, 1)); du = similar(u);
@show D_SBP * u â‰ˆ D_sparse * u â‰ˆ D_banded * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>First, we benchmark the implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 140 evaluations.
 Range (min â€¦ max):  709.993 ns â€¦ 983.571 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     711.429 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   714.572 ns Â±  13.964 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–†â–ˆ                                                         â–‚â– â–
  â–ˆâ–ˆâ–†â–…â–â–â–â–â–â–„â–‡â–ˆâ–…â–…â–„â–â–â–â–â–ƒâ–â–â–â–â–â–â–â–â–„â–„â–†â–…â–ˆâ–†â–‡â–†â–‡â–†â–‡â–…â–…â–†â–â–…â–„â–…â–…â–ƒâ–ƒâ–…â–…â–â–â–…â–â–…â–ƒâ–…â–ˆâ–ˆâ–ˆ â–ˆ
  710 ns        Histogram: log(frequency) by time        776 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Again, we compare this to a representation of the derivative operator as a sparse matrix. No surprise - it is again much slower, as in periodic domains.</p><pre><code class="language-julia hljs">doit(D_sparse, &quot;D_sparse:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_sparse:
BenchmarkTools.Trial: 10000 samples with 5 evaluations.
 Range (min â€¦ max):  6.180 Î¼s â€¦  12.580 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     6.220 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   6.238 Î¼s Â± 130.664 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

        â–ˆ  â–„
  â–‚â–â–â–„â–â–â–ˆâ–â–â–ˆâ–â–â–â–ƒâ–â–â–‚â–â–â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‚â–â–â–‚â–â–â–‚ â–‚
  6.18 Î¼s         Histogram: frequency by time        6.54 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>FInally, we compare it to a representation as banded matrix. Disappointingly, this is still much slower than the optimized implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_banded, &quot;D_banded:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_banded:
BenchmarkTools.Trial: 10000 samples with 3 evaluations.
 Range (min â€¦ max):  8.733 Î¼s â€¦  13.967 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     8.867 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   8.909 Î¼s Â± 217.153 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

         â–ˆ   â–…          â–‚
  â–‚â–â–â–‡â–â–â–â–ˆâ–â–â–â–ˆâ–â–â–‡â–â–â–â–ˆâ–â–â–â–ˆâ–â–â–†â–â–â–â–„â–â–â–â–„â–â–â–„â–â–â–â–„â–â–â–â–„â–â–â–‚â–â–â–â–‚â–â–â–â–‚â–â–â–‚ â–ƒ
  8.73 Î¼s         Histogram: frequency by time        9.27 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>These results were obtained using the following versions.</p><pre><code class="language-julia hljs">using InteractiveUtils
versioninfo()

using Pkg
Pkg.status([&quot;SummationByPartsOperators&quot;, &quot;BandedMatrices&quot;],
           mode=PKGMODE_MANIFEST)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.6.6
Commit b8708f954a (2022-03-28 07:17 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Xeon(R) Platinum 8370C CPU @ 2.80GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-11.0.1 (ORCJIT, icelake-server)
      Status `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl/docs/Manifest.toml`
  [aae01518] BandedMatrices v0.16.13
  [9f78cca6] SummationByPartsOperators v0.5.19 `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl`</code></pre><h2 id="Dissipation-operators"><a class="docs-heading-anchor" href="#Dissipation-operators">Dissipation operators</a><a id="Dissipation-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Dissipation-operators" title="Permalink"></a></h2><p>We follow the same structure as before. At first, we set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,
                            accuracy_order=6, xmin=xmin, xmax=xmax, N=10^3)
Di_SBP  = dissipation_operator(MattssonSvÃ¤rdNordstrÃ¶m2004(), D_SBP)
Di_sparse = sparse(Di_SBP)
Di_banded = BandedMatrix(Di_SBP)
Di_full   = Matrix(Di_SBP)

u = randn(eltype(D_SBP), size(D_SBP, 1)); du = similar(u);
@show Di_SBP * u â‰ˆ Di_sparse * u â‰ˆ Di_banded * u â‰ˆ Di_full * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>At first, let us benchmark the derivative and dissipation operators implemented in SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)
doit(Di_SBP, &quot;Di_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 135 evaluations.
 Range (min â€¦ max):  722.963 ns â€¦ 1.015 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     725.926 ns             â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   727.587 ns Â± 8.966 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

   â–„â–‡â–ˆâ–ˆâ–†â–ƒ                                                     â–‚
  â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–„â–â–â–â–â–â–â–„â–†â–‡â–ˆâ–‡â–†â–…â–ƒâ–„â–â–â–â–â–â–â–â–â–ƒâ–â–„â–â–â–â–â–ƒâ–â–„â–„â–„â–†â–†â–…â–‡â–†â–†â–†â–†â–†â–‡â–†â–†â–†â–‡â–‡ â–ˆ
  723 ns       Histogram: log(frequency) by time       770 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
Di_SBP:
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min â€¦ max):  1.630 Î¼s â€¦  6.020 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     1.640 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   1.647 Î¼s Â± 62.467 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                              â–ˆ                            â–
  â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆ â–‚
  1.63 Î¼s        Histogram: frequency by time        1.65 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we compare the results to sparse matrix representations. It will not come as a surprise that these are again much (around an order of magnitude) slower.</p><pre><code class="language-julia hljs">doit(Di_sparse, &quot;Di_sparse:&quot;, du, u)
doit(Di_banded, &quot;Di_banded:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Di_sparse:
BenchmarkTools.Trial: 10000 samples with 5 evaluations.
 Range (min â€¦ max):  6.980 Î¼s â€¦  14.100 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     7.000 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   7.020 Î¼s Â± 146.422 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

     â–ˆ  â–ƒ
  â–ƒâ–â–â–ˆâ–â–â–ˆâ–â–â–‚â–â–â–â–‚â–â–â–â–â–â–‚â–â–â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‚â–â–â–‚â–â–â–‚ â–‚
  6.98 Î¼s         Histogram: frequency by time        7.34 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
Di_banded:
BenchmarkTools.Trial: 10000 samples with 4 evaluations.
 Range (min â€¦ max):  7.800 Î¼s â€¦  17.400 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     8.025 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   8.076 Î¼s Â± 233.155 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                â–… â–ˆ
  â–‚â–‚â–â–…â–â–‡â–â–„â–â–ƒâ–â–…â–†â–â–ˆâ–â–ˆâ–â–‡â–â–ƒâ–â–‚â–‚â–â–ƒâ–â–ƒâ–â–„â–â–„â–â–„â–â–ƒâ–ƒâ–â–‚â–â–‚â–â–‚â–â–ƒâ–â–ƒâ–ƒâ–â–‚â–â–„â–â–ƒâ–â–‚â–â–‚â–‚ â–ƒ
  7.8 Î¼s          Histogram: frequency by time         8.6 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, let&#39;s benchmark the same computation if a full (dense) matrix is used to represent the derivative operator. This is obviously a bad idea but ğŸ¤·</p><pre><code class="language-julia hljs">doit(Di_full, &quot;Di_full:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Di_full:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  276.800 Î¼s â€¦ 509.099 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     277.999 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   278.621 Î¼s Â±   3.676 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

     â–â–…â–†â–ˆâ–ˆâ–…â–…â–ƒâ–â–        â–â–                    â–â–‚â–ƒâ–â–              â–‚
  â–ƒâ–…â–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–…â–†â–…â–†â–†â–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–‡â–â–„â–ƒâ–„â–ƒâ–ƒâ–„â–â–â–â–â–â–â–„â–ƒâ–…â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–†â–‡â–†â–†â–…â–…â–…â–†â–… â–ˆ
  277 Î¼s        Histogram: log(frequency) by time        287 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>These results were obtained using the following versions.</p><pre><code class="language-julia hljs">using InteractiveUtils
versioninfo()

using Pkg
Pkg.status([&quot;SummationByPartsOperators&quot;, &quot;BandedMatrices&quot;],
           mode=PKGMODE_MANIFEST)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.6.6
Commit b8708f954a (2022-03-28 07:17 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Xeon(R) Platinum 8370C CPU @ 2.80GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-11.0.1 (ORCJIT, icelake-server)
      Status `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl/docs/Manifest.toml`
  [aae01518] BandedMatrices v0.16.13
  [9f78cca6] SummationByPartsOperators v0.5.19 `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl`</code></pre><h2 id="Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)"><a class="docs-heading-anchor" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)">Structure-of-Arrays (SoA) and Array-of-Structures (AoS)</a><a id="Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)" title="Permalink"></a></h2><p><a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a> tries to provide efficient support of</p><ul><li><code>StaticVector</code>s from <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a></li><li><a href="https://github.com/JuliaArrays/StructArrays.jl">StructArrays.jl</a></li></ul><p>To demonstrate this, let us set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using StaticArrays, StructArrays
using LinearAlgebra, SparseArrays
using SummationByPartsOperators

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

struct Vec5{T} &lt;: FieldVector{5,T}
  x1::T
  x2::T
  x3::T
  x4::T
  x5::T
end

# Apply `mul!` to each component of a plain array of structures one after another
function mul_aos!(du, D, u, args...)
  for i in 1:size(du, 1)
    mul!(view(du, i, :), D, view(u, i, :), args...)
  end
end

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,
                            accuracy_order=4, xmin=xmin, xmax=xmax, N=101)
D_sparse = sparse(D_SBP)
D_full   = Matrix(D_SBP)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">101Ã—101 Matrix{Float64}:
 -141.176    173.529   -23.5294   â€¦    0.0         0.0       0.0
  -50.0        0.0      50.0           0.0         0.0       0.0
    9.30233  -68.6047    0.0           0.0         0.0       0.0
    3.06122    0.0     -60.2041        0.0         0.0       0.0
    0.0        0.0       8.33333       0.0         0.0       0.0
    0.0        0.0       0.0      â€¦    0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    â‹®                             â‹±                          â‹®
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0      â€¦    0.0         0.0       0.0
    0.0        0.0       0.0          -8.33333     0.0       0.0
    0.0        0.0       0.0          60.2041      0.0      -3.06122
    0.0        0.0       0.0           0.0        68.6047   -9.30233
    0.0        0.0       0.0         -50.0         0.0      50.0
    0.0        0.0       0.0      â€¦   23.5294   -173.529   141.176</code></pre><p>At first, we benchmark the application of the operators implemented in SummationByPartsOperators.jl and their representations as sparse and dense matrices in the scalar case. As before, the sparse matrix representation is around an order of magnitude slower and the dense matrix representation is far off.</p><pre><code class="language-julia hljs">println(&quot;Scalar case&quot;)
u = randn(T, size(D_SBP, 1)); du = similar(u)
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_SBP, $u))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_sparse, $u))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_full, $u))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Scalar case
D_SBP
BenchmarkTools.Trial: 10000 samples with 968 evaluations.
 Range (min â€¦ max):  80.474 ns â€¦ 139.152 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     80.682 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   80.860 ns Â±   1.299 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

   â–…â–ˆâ–‡â–ƒ                                                        â–‚
  â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–†â–ƒâ–â–ƒâ–â–â–â–â–â–â–ƒâ–„â–†â–‡â–‡â–†â–…â–ƒâ–ƒâ–„â–ƒâ–ƒâ–â–â–â–â–â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–â–ƒâ–„â–…â–†â–…â–†â–†â–†â–…â–…â–†â–…â–†â–† â–ˆ
  80.5 ns       Histogram: log(frequency) by time      86.3 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 196 evaluations.
 Range (min â€¦ max):  473.464 ns â€¦ 770.918 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     476.531 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   477.647 ns Â±   7.636 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

     â–‚â–†â–‡â–†â–ˆ
  â–‚â–ƒâ–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„â–ƒâ–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–â–â–â–â–‚â–â–â–â–â–â–â–â–â–â–â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚ â–ƒ
  473 ns           Histogram: frequency by time          509 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 9 evaluations.
 Range (min â€¦ max):  2.333 Î¼s â€¦  5.833 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     2.344 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   2.352 Î¼s Â± 68.716 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                     â–ˆ                  â–
  â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‚ â–‚
  2.33 Î¼s        Histogram: frequency by time        2.37 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we use a plain array of structures (AoS) in the form of a two-dimensional array and our custom <code>mul_aos!</code> implementation that loops over each component, using <code>mul!</code> on <code>view</code>s. Here, the differences between the timings are less pronounced.</p><pre><code class="language-julia hljs">println(&quot;Plain Array of Structures&quot;)
u_aos_plain = randn(T, 5, size(D_SBP, 1)); du_aos_plain = similar(u_aos_plain)
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_SBP, $u_aos_plain))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_sparse, $u_aos_plain))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_full, $u_aos_plain))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Plain Array of Structures
D_SBP
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min â€¦ max):  1.140 Î¼s â€¦  3.590 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     1.150 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   1.154 Î¼s Â± 51.955 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                               â–ˆ
  â–„â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‚â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–… â–‚
  1.14 Î¼s        Histogram: frequency by time        1.16 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 8 evaluations.
 Range (min â€¦ max):  3.162 Î¼s â€¦   8.238 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     3.300 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   3.281 Î¼s Â± 125.537 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

       â–„  â–ˆ  â–„                          â–  â–ƒ  â–ƒ  â–
  â–‚â–â–…â–â–â–ˆâ–â–â–ˆâ–â–â–ˆâ–â–â–†â–â–â–ƒâ–â–â–‚â–â–â–‚â–â–â–‚â–â–â–‚â–â–â–„â–â–â–†â–â–â–ˆâ–â–â–ˆâ–â–â–ˆâ–â–â–ˆâ–â–â–†â–â–â–„â–â–â–ƒâ–â–‚ â–ƒ
  3.16 Î¼s         Histogram: frequency by time        3.41 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  12.000 Î¼s â€¦  51.200 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     12.200 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   12.193 Î¼s Â± 669.274 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                     â–„                   â–ˆ
  â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‚ â–‚
  12 Î¼s           Histogram: frequency by time         12.3 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Now, we use an array of structures (AoS) based on <code>reinterpret</code> and standard <code>mul!</code>. This is much more efficient for the implementation in SummationByPartsOperators.jl. In Julia v1.6, this is also more efficient for sparse matrices but less efficient for dense matrices (compared to the plain AoS approach with <code>mul_aos!</code> above).</p><pre><code class="language-julia hljs">println(&quot;Array of Structures (reinterpreted array)&quot;)
u_aos_r = reinterpret(reshape, Vec5{T}, u_aos_plain); du_aos_r = similar(u_aos_r)
@show D_SBP * u_aos_r â‰ˆ D_sparse * u_aos_r â‰ˆ D_full * u_aos_r
mul!(du_aos_r, D_SBP, u_aos_r)
@show reinterpret(reshape, T, du_aos_r) â‰ˆ du_aos_plain
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_SBP, $u_aos_r))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_sparse, $u_aos_r))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_full, $u_aos_r))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Array of Structures (reinterpreted array)
D_SBP * u_aos_r â‰ˆ D_sparse * u_aos_r â‰ˆ D_full * u_aos_r = true
reinterpret(reshape, T, du_aos_r) â‰ˆ du_aos_plain = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 496 evaluations.
 Range (min â€¦ max):  221.369 ns â€¦ 327.621 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     221.976 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   222.368 ns Â±   2.454 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

   â–„â–‡â–ˆâ–‡â–„                                                        â–‚
  â–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–ƒâ–ƒâ–â–â–â–â–â–â–â–ƒâ–‡â–ˆâ–‡â–‡â–…â–„â–â–â–â–â–â–ƒâ–â–â–ƒâ–â–â–â–â–â–ƒâ–â–â–â–â–â–„â–â–…â–…â–…â–‡â–‡â–‡â–‡â–†â–‡â–†â–…â–‡â–†â–‡â–…â–„ â–ˆ
  221 ns        Histogram: log(frequency) by time        233 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 125 evaluations.
 Range (min â€¦ max):  742.392 ns â€¦  1.068 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     767.200 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   769.158 ns Â± 16.090 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

       â– â–‚â–      â–ƒ â–ˆâ–â–† â–„â–„          â–‚ â–ƒ
  â–â–ƒâ–ƒâ–‡â–…â–ˆâ–…â–ˆâ–ˆâ–„â–‡â–„â–†â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–ˆâ–ˆâ–†â–ˆâ–ƒâ–ƒâ–‚â–ƒâ–ƒâ–†â–‡â–…â–ˆâ–†â–ˆâ–…â–‡â–…â–‚â–ƒâ–‚â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â– â–ƒ
  742 ns          Histogram: frequency by time          818 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  16.999 Î¼s â€¦  77.700 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     17.100 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   17.121 Î¼s Â± 743.703 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–…                            â–‚â–ˆ                              â–
  â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‡ â–ˆ
  17 Î¼s         Histogram: log(frequency) by time      17.2 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we still use an array of structures (AoS), but copy the data into a plain <code>Array</code> instead of using the <code>reinterpret</code>ed versions. There is no significant difference to the previous version in this case.</p><pre><code class="language-julia hljs">println(&quot;Array of Structures&quot;)
u_aos = Array(u_aos_r); du_aos = similar(u_aos)
@show D_SBP * u_aos â‰ˆ D_sparse * u_aos â‰ˆ D_full * u_aos
mul!(du_aos, D_SBP, u_aos)
@show du_aos â‰ˆ du_aos_r
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_SBP, $u_aos))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_sparse, $u_aos))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_full, $u_aos))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Array of Structures
D_SBP * u_aos â‰ˆ D_sparse * u_aos â‰ˆ D_full * u_aos = true
du_aos â‰ˆ du_aos_r = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 511 evaluations.
 Range (min â€¦ max):  217.025 ns â€¦ 373.386 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     218.004 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   218.389 ns Â±   2.800 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

   â–‚â–…â–‡â–ˆâ–‡â–„                                                       â–‚
  â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–…â–„â–ƒâ–â–â–â–â–â–ƒâ–„â–‡â–ˆâ–ˆâ–‡â–…â–ƒâ–ƒâ–â–â–â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–„â–†â–‡â–…â–†â–‡â–‡â–‡â–†â–†â–†â–‡â–†â–‡â–†â–†â–… â–ˆ
  217 ns        Histogram: log(frequency) by time        230 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 123 evaluations.
 Range (min â€¦ max):  743.089 ns â€¦  3.924 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     758.537 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   760.676 ns Â± 35.526 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

         â–ƒ â–† â–† â–ˆâ–â–‡ â–‚
  â–‚â–‚â–‚â–ƒâ–ƒâ–‡â–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–„â–†â–ƒâ–„â–‚â–ƒâ–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–‚ â–ƒ
  743 ns          Histogram: frequency by time          817 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  16.999 Î¼s â€¦  78.000 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     17.100 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   17.135 Î¼s Â± 827.066 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ƒ                            â–‚â–ˆ                            â–ƒ â–
  â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆ â–ˆ
  17 Î¼s         Histogram: log(frequency) by time      17.2 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, let&#39;s look at a structure of arrays (SoA). Interestingly, this is slower than the array of structures we used above. On Julia v1.6, the sparse matrix representation performs particularly bad in this case.</p><pre><code class="language-julia hljs">println(&quot;Structure of Arrays&quot;)
u_soa = StructArray(u_aos); du_soa = similar(u_soa)
@show D_SBP * u_soa â‰ˆ D_sparse * u_soa â‰ˆ D_full * u_soa
mul!(du_soa, D_SBP, u_soa)
@show du_soa â‰ˆ du_aos
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_SBP, $u_soa))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_sparse, $u_soa))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_full, $u_soa))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Structure of Arrays
D_SBP * u_soa â‰ˆ D_sparse * u_soa â‰ˆ D_full * u_soa = true
du_soa â‰ˆ du_aos = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 203 evaluations.
 Range (min â€¦ max):  386.700 ns â€¦ 616.256 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     387.685 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   388.518 ns Â±   5.294 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

   â–…â–ˆâ–‡â–ƒ                                                         â–‚
  â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–†â–„â–â–â–â–â–â–â–â–â–â–ƒâ–â–†â–‡â–‡â–…â–…â–…â–â–ƒâ–â–„â–ƒâ–â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–„â–…â–†â–â–†â–…â–‡â–†â–†â–†â–…â–„ â–ˆ
  387 ns        Histogram: log(frequency) by time        413 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  254.999 Î¼s â€¦   6.064 ms  â”Š GC (min â€¦ max): 0.00% â€¦ 93.81%
 Time  (median):     278.899 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   321.559 Î¼s Â± 408.864 Î¼s  â”Š GC (mean Â± Ïƒ):  9.19% Â±  6.86%

    â–â–ƒâ–„â–…â–†â–ˆâ–†â–„â–…â–†â–„â–‚â–ƒâ–ƒâ–ƒâ–‚â–‚â–ƒâ–‚â–â–â–                                â–ƒâ–ƒâ–‚â–  â–‚
  â–ƒâ–…â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–…â–…â–„â–ƒâ–ƒâ–ƒâ–ƒâ–â–„â–„â–„â–ƒâ–ƒâ–â–„â–ƒâ–ƒâ–â–ƒâ–ƒâ–„â–â–„â–ƒâ–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ
  255 Î¼s        Histogram: log(frequency) by time        437 Î¼s &lt;

 Memory estimate: 328.25 KiB, allocs estimate: 10504.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  200.300 Î¼s â€¦   6.186 ms  â”Š GC (min â€¦ max):  0.00% â€¦ 94.78%
 Time  (median):     219.700 Î¼s               â”Š GC (median):     0.00%
 Time  (mean Â± Ïƒ):   263.004 Î¼s Â± 416.455 Î¼s  â”Š GC (mean Â± Ïƒ):  11.44% Â±  6.93%

   â–‚â–„â–…â–…â–‡â–ˆâ–†â–„â–…â–‡â–†â–ƒâ–‚â–ƒâ–ƒâ–‚â–‚â–‚â–‚â–‚â–â–â–  â–â–                            â–ƒâ–ƒâ–‚â–  â–‚
  â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–…â–ƒâ–…â–…â–ƒâ–…â–…â–ƒâ–ƒâ–…â–„â–â–ƒâ–â–„â–ƒâ–â–„â–â–ƒâ–„â–â–…â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ
  200 Î¼s        Histogram: log(frequency) by time        372 Î¼s &lt;

 Memory estimate: 328.25 KiB, allocs estimate: 10504.</code></pre><p>These results were obtained using the following versions.</p><pre><code class="language-julia hljs">using InteractiveUtils
versioninfo()

using Pkg
Pkg.status([&quot;SummationByPartsOperators&quot;, &quot;StaticArrays&quot;, &quot;StructArrays&quot;],
           mode=PKGMODE_MANIFEST)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.6.6
Commit b8708f954a (2022-03-28 07:17 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Xeon(R) Platinum 8370C CPU @ 2.80GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-11.0.1 (ORCJIT, icelake-server)
      Status `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl/docs/Manifest.toml`
  [90137ffa] StaticArrays v1.5.0
  [09ab397b] StructArrays v0.6.11
  [9f78cca6] SummationByPartsOperators v0.5.19 `~/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl`</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../applications/">Â« Applications &amp; references</a><a class="docs-footer-nextpage" href="../api_reference/">API reference Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Friday 1 July 2022 14:01">Friday 1 July 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
