<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Benchmarks Â· SummationByPartsOperators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/benchmarks/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SummationByPartsOperators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/constant_linear_advection/">Linear advection equation with constant coefficients</a></li><li><a class="tocitem" href="../tutorials/advection_diffusion/">Linear advection diffusion equation with periodic boundary conditions</a></li><li><a class="tocitem" href="../tutorials/variable_linear_advection/">Linear advection equation with variable coefficients</a></li><li><a class="tocitem" href="../tutorials/wave_equation/">Wave equation</a></li></ul></li><li><a class="tocitem" href="../applications/">Applications &amp; references</a></li><li class="is-active"><a class="tocitem" href>Benchmarks</a><ul class="internal"><li><a class="tocitem" href="#First-derivative-operators"><span>First-derivative operators</span></a></li><li><a class="tocitem" href="#Dissipation-operators"><span>Dissipation operators</span></a></li><li><a class="tocitem" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)"><span>Structure-of-Arrays (SoA) and Array-of-Structures (AoS)</span></a></li></ul></li><li><a class="tocitem" href="../api_reference/">API reference</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Benchmarks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Benchmarks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ranocha/SummationByPartsOperators.jl/blob/master/docs/src/benchmarks.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Benchmarks"><a class="docs-heading-anchor" href="#Benchmarks">Benchmarks</a><a id="Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarks" title="Permalink"></a></h1><p>Here are some simple benchmarks. Take them with a grain of salt since they run on virtual machines in the cloud to generate the documentation automatically.</p><h2 id="First-derivative-operators"><a class="docs-heading-anchor" href="#First-derivative-operators">First-derivative operators</a><a id="First-derivative-operators-1"></a><a class="docs-heading-anchor-permalink" href="#First-derivative-operators" title="Permalink"></a></h2><h4 id="Periodic-domains"><a class="docs-heading-anchor" href="#Periodic-domains">Periodic domains</a><a id="Periodic-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-domains" title="Permalink"></a></h4><p>Let&#39;s set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, DiffEqOperators

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = periodic_derivative_operator(derivative_order=1, accuracy_order=2,
                                     xmin=xmin, xmax=xmax, N=100)
x = grid(D_SBP)
D_DEO = CenteredDifference(derivative_order(D_SBP), accuracy_order(D_SBP),
                           step(x), length(x)) * PeriodicBC(eltype(D_SBP))

D_sparse = sparse(D_SBP)

u = randn(eltype(D_SBP), length(x)); du = similar(u);
@show D_SBP * u â‰ˆ D_DEO * u â‰ˆ D_sparse * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>First, we benchmark the implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 994 evaluations.
 Range (min â€¦ max):  30.885 ns â€¦ 74.850 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     31.490 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   33.226 ns Â±  3.263 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ƒ â–ˆ        â–
  â–ˆâ–‡â–ˆâ–â–â–‚â–‚â–‚â–‚â–ˆâ–„â–ˆâ–â–‚â–‚â–‚â–‚â–‚â–‚â–ƒâ–ƒâ–…â–ƒâ–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–â–‚â–‚â–â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚ â–ƒ
  30.9 ns         Histogram: frequency by time        48.6 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we compare this to the runtime obtained using a sparse matrix representation of the derivative operator. Depending on the hardware etc., this can be an order of magnitude slower than the optimized implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_sparse, &quot;D_sparse:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_sparse:
BenchmarkTools.Trial: 10000 samples with 196 evaluations.
 Range (min â€¦ max):  503.577 ns â€¦ 641.337 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     506.128 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   506.574 ns Â±   5.830 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

    â–† â–ˆ
  â–…â–ƒâ–ˆâ–„â–ˆâ–‡â–‚â–‚â–‚â–‚â–â–â–â–â–â–â–â–‚â–‚â–‚â–‚â–‚â–‚â–â–â–â–‚â–‚â–â–â–â–‚â–â–â–â–â–â–â–â–â–â–â–â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚ â–‚
  504 ns           Histogram: frequency by time          536 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, we benchmark the implementation of the same derivative operator in DiffEqOperators.jl.</p><pre><code class="language-julia hljs">doit(D_DEO, &quot;D_DEO:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_DEO:
â”Œ Warning: #= /home/runner/.julia/packages/DiffEqOperators/Xddum/src/derivative_operators/convolutions.jl:375 =#:
â”‚ `LoopVectorization.check_args` on your inputs failed; running fallback `@inbounds @fastmath` loop instead.
â”‚ Use `warn_check_args=false`, e.g. `@turbo warn_check_args=false ...`, to disable this warning.
â”” @ DiffEqOperators ~/.julia/packages/LoopVectorization/wLMFa/src/condense_loopset.jl:825
â”Œ Warning: #= /home/runner/.julia/packages/DiffEqOperators/Xddum/src/derivative_operators/convolutions.jl:419 =#:
â”‚ `LoopVectorization.check_args` on your inputs failed; running fallback `@inbounds @fastmath` loop instead.
â”‚ Use `warn_check_args=false`, e.g. `@turbo warn_check_args=false ...`, to disable this warning.
â”” @ DiffEqOperators ~/.julia/packages/LoopVectorization/wLMFa/src/condense_loopset.jl:825
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min â€¦ max):  1.220 Î¼s â€¦   4.450 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     1.360 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   1.415 Î¼s Â± 209.536 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–‡â–‚   â–†â–ˆâ–
  â–ˆâ–ˆâ–†â–…â–„â–ˆâ–ˆâ–ˆâ–‡â–…â–ƒâ–„â–ˆâ–ˆâ–†â–…â–„â–„â–ƒâ–„â–ƒâ–ƒâ–ƒâ–‚â–‚â–‚â–‚â–ƒâ–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–â–â–â–â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚ â–ƒ
  1.22 Î¼s         Histogram: frequency by time        2.42 Î¼s &lt;

 Memory estimate: 416 bytes, allocs estimate: 6.</code></pre><h4 id="Bounded-domains"><a class="docs-heading-anchor" href="#Bounded-domains">Bounded domains</a><a id="Bounded-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Bounded-domains" title="Permalink"></a></h4><p>We start again by setting up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,
                            accuracy_order=6, xmin=xmin, xmax=xmax, N=10^3)
D_sparse = sparse(D_SBP)
D_banded = BandedMatrix(D_SBP)

u = randn(eltype(D_SBP), size(D_SBP, 1)); du = similar(u);
@show D_SBP * u â‰ˆ D_sparse * u â‰ˆ D_banded * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>First, we benchmark the implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 199 evaluations.
 Range (min â€¦ max):  427.643 ns â€¦ 859.814 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     429.151 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   453.841 ns Â±  36.302 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆ              â–†â–‚                â–‚â–…                           â–
  â–ˆâ–…â–â–‡â–‡â–„â–â–â–ƒâ–â–‡â–‡â–‡â–‡â–†â–ˆâ–ˆâ–…â–ƒâ–†â–…â–â–ƒâ–â–…â–â–â–…â–‡â–‡â–‡â–†â–…â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–‡â–‡â–‡â–†â–‡â–‡â–ˆâ–†â–†â–†â–†â–…â–†â–…â–†â–†â–†â–†â–…â–… â–ˆ
  428 ns        Histogram: log(frequency) by time        575 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Again, we compare this to a representation of the derivative operator as a sparse matrix. No surprise - it is again much slower, as in periodic domains.</p><pre><code class="language-julia hljs">doit(D_sparse, &quot;D_sparse:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_sparse:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  9.800 Î¼s â€¦  30.801 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     9.900 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   9.919 Î¼s Â± 407.641 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–‡       â–ˆ       â–‚                â–„        â–               â–‚ â–
  â–ˆâ–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–…â–â–â–â–â–â–â–â–ˆ â–ˆ
  9.8 Î¼s       Histogram: log(frequency) by time      10.5 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>FInally, we compare it to a representation as banded matrix. Disappointingly, this is still much slower than the optimized implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_banded, &quot;D_banded:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_banded:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  15.900 Î¼s â€¦  54.901 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     16.100 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   16.123 Î¼s Â± 601.343 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                â–              â–ˆ
  â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–„â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–†â–â–â–â–â–â–â–â–â–â–â–â–â–â–‡â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–â–‚ â–‚
  15.9 Î¼s         Histogram: frequency by time         16.3 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><h2 id="Dissipation-operators"><a class="docs-heading-anchor" href="#Dissipation-operators">Dissipation operators</a><a id="Dissipation-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Dissipation-operators" title="Permalink"></a></h2><p>We follow the same structure as before. At first, we set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,
                            accuracy_order=6, xmin=xmin, xmax=xmax, N=10^3)
Di_SBP  = dissipation_operator(MattssonSvÃ¤rdNordstrÃ¶m2004(), D_SBP)
Di_sparse = sparse(Di_SBP)
Di_banded = BandedMatrix(Di_SBP)
Di_full   = Matrix(Di_SBP)

u = randn(eltype(D_SBP), size(D_SBP, 1)); du = similar(u);
@show Di_SBP * u â‰ˆ Di_sparse * u â‰ˆ Di_banded * u â‰ˆ Di_full * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>At first, let us benchmark the derivative and dissipation operators implemented in SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)
doit(Di_SBP, &quot;Di_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 199 evaluations.
 Range (min â€¦ max):  429.151 ns â€¦ 830.161 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     430.658 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   456.556 ns Â±  37.884 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆ              â–†                â–…                             â–
  â–ˆâ–ƒâ–â–ˆâ–†â–â–ƒâ–â–â–ƒâ–ˆâ–ˆâ–‡â–†â–ˆâ–ˆâ–…â–„â–‡â–…â–ƒâ–„â–â–„â–„â–„â–‡â–‡â–‡â–‡â–‡â–†â–ˆâ–ˆâ–‡â–‡â–ˆâ–‡â–‡â–‡â–†â–†â–†â–†â–‡â–ˆâ–‡â–†â–†â–†â–†â–†â–‡â–†â–…â–†â–„â–†â–…â–…â–† â–ˆ
  429 ns        Histogram: log(frequency) by time        584 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
Di_SBP:
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min â€¦ max):  1.840 Î¼s â€¦  3.830 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     1.860 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   1.860 Î¼s Â± 53.282 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                     â–ƒ                  â–ˆ
  â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ƒ â–‚
  1.84 Î¼s        Histogram: frequency by time        1.87 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we compare the results to sparse matrix representations. It will not come as a surprise that these are again much (around an order of magnitude) slower.</p><pre><code class="language-julia hljs">doit(Di_sparse, &quot;Di_sparse:&quot;, du, u)
doit(Di_banded, &quot;Di_banded:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Di_sparse:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  11.100 Î¼s â€¦  51.501 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     11.200 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   11.253 Î¼s Â± 582.447 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                               â–ˆ
  â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–„â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–… â–‚
  11.1 Î¼s         Histogram: frequency by time         11.3 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
Di_banded:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  12.400 Î¼s â€¦ 81.601 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     12.801 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   12.881 Î¼s Â±  1.065 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                           â–„       â–‡        â–ˆ       â–ˆ
  â–ƒâ–â–â–â–â–â–â–â–…â–â–â–â–â–â–â–â–‡â–â–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–… â–ƒ
  12.4 Î¼s         Histogram: frequency by time        13.1 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, let&#39;s benchmark the same computation if a full (dense) matrix is used to represent the derivative operator. This is obviously a bad idea but ğŸ¤·</p><pre><code class="language-julia hljs">doit(Di_full, &quot;Di_full:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Di_full:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  346.104 Î¼s â€¦ 679.409 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     350.704 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   359.812 Î¼s Â±  15.047 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

     â–ƒâ–ˆâ–ƒâ–‚  â–â–ƒâ–„â–ƒ     â–â–â–â–â–â–â–â– â–          â–„â–â– â–                   â–
  â–…â–†â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–†â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–‡â–ˆâ–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–‡â–‡â–†â–†â–‡â–†â–†â–†â–…â–†â–† â–ˆ
  346 Î¼s        Histogram: log(frequency) by time        404 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><h2 id="Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)"><a class="docs-heading-anchor" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)">Structure-of-Arrays (SoA) and Array-of-Structures (AoS)</a><a id="Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)" title="Permalink"></a></h2><p><a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a> tries to provide efficient support of</p><ul><li><code>StaticVector</code>s from <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a></li><li><a href="https://github.com/JuliaArrays/StructArrays.jl">StructArrays.jl</a></li></ul><p>To demonstrate this, let us set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using StaticArrays, StructArrays
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

struct Vec5{T} &lt;: FieldVector{5,T}
  x1::T
  x2::T
  x3::T
  x4::T
  x5::T
end

# Apply `mul!` to each component of a plain array of structures one after another
function mul_aos!(du, D, u, args...)
  for i in 1:size(du, 1)
    mul!(view(du, i, :), D, view(u, i, :), args...)
  end
end

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,
                            accuracy_order=4, xmin=xmin, xmax=xmax, N=101)
D_sparse = sparse(D_SBP)
D_full   = Matrix(D_SBP)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">101Ã—101 Matrix{Float64}:
 -141.176    173.529   -23.5294   â€¦    0.0         0.0       0.0
  -50.0        0.0      50.0           0.0         0.0       0.0
    9.30233  -68.6047    0.0           0.0         0.0       0.0
    3.06122    0.0     -60.2041        0.0         0.0       0.0
    0.0        0.0       8.33333       0.0         0.0       0.0
    0.0        0.0       0.0      â€¦    0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    â‹®                             â‹±                          â‹®
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0      â€¦    0.0         0.0       0.0
    0.0        0.0       0.0          -8.33333     0.0       0.0
    0.0        0.0       0.0          60.2041      0.0      -3.06122
    0.0        0.0       0.0           0.0        68.6047   -9.30233
    0.0        0.0       0.0         -50.0         0.0      50.0
    0.0        0.0       0.0      â€¦   23.5294   -173.529   141.176</code></pre><p>At first, we benchmark the application of the operators implemented in SummationByPartsOperators.jl and their representations as sparse and dense matrices in the scalar case. As before, the sparse matrix representation is around an order of magnitude slower and the dense matrix representation is far off.</p><pre><code class="language-julia hljs">println(&quot;Scalar case&quot;)
u = randn(T, size(D_SBP, 1)); du = similar(u)
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_SBP, $u))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_sparse, $u))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_full, $u))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Scalar case
D_SBP
BenchmarkTools.Trial: 10000 samples with 983 evaluations.
 Range (min â€¦ max):  52.187 ns â€¦ 107.020 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     59.208 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   60.941 ns Â±   4.955 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

          â–ƒâ–„  â–„â–ˆâ–…â–ˆ       â–â–ƒâ–ƒâ–„     â–‚   â–‚â–„â–â–„                     â–‚
  â–„â–â–â–‡â–†â–ƒâ–â–â–ˆâ–ˆâ–â–â–ˆâ–ˆâ–ˆâ–ˆâ–…â–‡â–‡â–ˆâ–†â–ƒâ–„â–ˆâ–ˆâ–ˆâ–ˆâ–‡â–†â–†â–…â–‡â–ˆâ–â–„â–†â–ˆâ–ˆâ–ˆâ–ˆâ–„â–â–…â–„â–†â–†â–†â–†â–‡â–†â–†â–‡â–‡â–‡â–†â–†â–†â–†â–†â–† â–ˆ
  52.2 ns       Histogram: log(frequency) by time      80.2 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 118 evaluations.
 Range (min â€¦ max):  757.636 ns â€¦  1.390 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     759.331 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   760.895 ns Â± 12.344 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–‡â–ˆâ–…â–                                                         â–
  â–ˆâ–ˆâ–ˆâ–ˆâ–ƒâ–…â–ƒâ–ƒâ–â–â–â–â–â–â–ƒâ–†â–‡â–‡â–†â–…â–…â–ƒâ–„â–â–â–â–â–â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ƒâ–ƒâ–â–„â–„â–…â–†â–…â–‡â–‡â–‡â–†â–†â–†â–†â–†â–† â–ˆ
  758 ns        Histogram: log(frequency) by time       810 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 9 evaluations.
 Range (min â€¦ max):  2.189 Î¼s â€¦   5.933 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     2.411 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   2.473 Î¼s Â± 254.401 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

         â–ˆ
  â–„â–ƒâ–â–â–â–â–â–ˆâ–ƒâ–‚â–â–â–â–‚â–‚â–…â–…â–‚â–â–â–‚â–â–‚â–‚â–‚â–â–â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–â–‚â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚ â–‚
  2.19 Î¼s         Histogram: frequency by time        3.84 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we use a plain array of structures (AoS) in the form of a two-dimensional array and our custom <code>mul_aos!</code> implementation that loops over each component, using <code>mul!</code> on <code>view</code>s. Here, the differences between the timings are less pronounced.</p><pre><code class="language-julia hljs">println(&quot;Plain Array of Structures&quot;)
u_aos_plain = randn(T, 5, size(D_SBP, 1)); du_aos_plain = similar(u_aos_plain)
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_SBP, $u_aos_plain))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_sparse, $u_aos_plain))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_full, $u_aos_plain))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Plain Array of Structures
D_SBP
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min â€¦ max):  1.220 Î¼s â€¦   4.340 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     1.320 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   1.379 Î¼s Â± 195.366 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

     â–ƒâ–ˆ    â–„     â–…                                            â–
  â–ˆâ–â–â–ˆâ–ˆâ–‡â–„â–„â–ƒâ–ˆâ–‡â–†â–…â–â–‡â–ˆâ–‡â–„â–ƒâ–ƒâ–â–â–â–â–â–…â–…â–…â–ƒâ–…â–â–ƒâ–„â–„â–â–ƒâ–ƒâ–ƒâ–…â–…â–„â–„â–ƒâ–ƒâ–ƒâ–â–ƒâ–â–â–â–ƒâ–„â–„â–…â–ƒâ–„â–„â–„â–† â–ˆ
  1.22 Î¼s      Histogram: log(frequency) by time      2.56 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 8 evaluations.
 Range (min â€¦ max):  3.837 Î¼s â€¦  6.925 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     3.850 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   3.856 Î¼s Â± 91.795 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

     â–ˆ
  â–‡â–â–â–ˆâ–â–â–ƒâ–â–â–â–‚â–â–â–â–â–â–â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‚â–â–â–â–‚â–â–â–‚â–â–â–‚ â–‚
  3.84 Î¼s        Histogram: frequency by time        4.05 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  11.700 Î¼s â€¦ 38.500 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     11.900 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   12.477 Î¼s Â±  1.621 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

    â–ˆ
  â–‚â–†â–ˆâ–ƒâ–‚â–â–â–â–â–â–â–‚â–…â–ƒâ–‚â–â–‚â–â–‚â–â–‚â–â–â–‚â–‚â–ƒâ–„â–‚â–‚â–â–â–‚â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚ â–‚
  11.7 Î¼s         Histogram: frequency by time        17.3 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Now, we use an array of structures (AoS) based on <code>reinterpret</code> and standard <code>mul!</code>. This is much more efficient for the implementation in SummationByPartsOperators.jl. In Julia v1.6, this is also more efficient for sparse matrices but less efficient for dense matrices (compared to the plain AoS approach with <code>mul_aos!</code> above).</p><pre><code class="language-julia hljs">println(&quot;Array of Structures (reinterpreted array)&quot;)
u_aos_r = reinterpret(reshape, Vec5{T}, u_aos_plain); du_aos_r = similar(u_aos_r)
@show D_SBP * u_aos_r â‰ˆ D_sparse * u_aos_r â‰ˆ D_full * u_aos_r
mul!(du_aos_r, D_SBP, u_aos_r)
@show reinterpret(reshape, T, du_aos_r) â‰ˆ du_aos_plain
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_SBP, $u_aos_r))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_sparse, $u_aos_r))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_full, $u_aos_r))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Array of Structures (reinterpreted array)
D_SBP * u_aos_r â‰ˆ D_sparse * u_aos_r â‰ˆ D_full * u_aos_r = true
reinterpret(reshape, T, du_aos_r) â‰ˆ du_aos_plain = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 487 evaluations.
 Range (min â€¦ max):  206.368 ns â€¦ 336.556 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     226.903 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   233.938 ns Â±  17.240 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

             â–‡  â–ˆ      â–   â–  â–„            â–„  â–„                 â–‚
  â–…â–â–‡â–â–â–â–â–ƒâ–â–ƒâ–ƒâ–ˆâ–„â–‡â–ˆâ–ƒâ–ˆâ–‡â–‡â–‡â–†â–ˆâ–ˆâ–‡â–†â–ˆâ–…â–…â–ˆâ–â–†â–†â–„â–…â–†â–‡â–‡â–‡â–ˆâ–‡â–‡â–ˆâ–‡â–‡â–ˆâ–‡â–‡â–‡â–†â–†â–‡â–‡â–†â–‡â–†â–†â–†â–‡â–‡â–†â–… â–ˆ
  206 ns        Histogram: log(frequency) by time        293 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min â€¦ max):  1.010 Î¼s â€¦  3.150 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     1.020 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   1.024 Î¼s Â± 41.857 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                              â–ˆ
  â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–„â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‡ â–‚
  1.01 Î¼s        Histogram: frequency by time        1.03 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  17.700 Î¼s â€¦ 93.401 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     19.600 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   19.727 Î¼s Â±  2.211 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

   â–ƒ     â–ˆâ–„
  â–ƒâ–ˆâ–‚â–â–â–â–†â–ˆâ–ˆâ–‚â–‚â–â–â–‚â–‚â–‡â–ƒâ–â–â–‚â–â–â–â–‚â–‚â–â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–â–‚â–‚â–â–‚â–‚â–â–â–â–‚â–‚â–‚â–‚â–‚ â–‚
  17.7 Î¼s         Histogram: frequency by time        31.9 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we still use an array of structures (AoS), but copy the data into a plain <code>Array</code> instead of using the <code>reinterpret</code>ed versions. There is no significant difference to the previous version in this case.</p><pre><code class="language-julia hljs">println(&quot;Array of Structures&quot;)
u_aos = Array(u_aos_r); du_aos = similar(u_aos)
@show D_SBP * u_aos â‰ˆ D_sparse * u_aos â‰ˆ D_full * u_aos
mul!(du_aos, D_SBP, u_aos)
@show du_aos â‰ˆ du_aos_r
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_SBP, $u_aos))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_sparse, $u_aos))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_full, $u_aos))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Array of Structures
D_SBP * u_aos â‰ˆ D_sparse * u_aos â‰ˆ D_full * u_aos = true
du_aos â‰ˆ du_aos_r = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 487 evaluations.
 Range (min â€¦ max):  222.795 ns â€¦ 341.277 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     226.698 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   236.471 ns Â±  18.412 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–‡ â–â–ˆ            â–„  â–†               â–â–„  â–…                      â–‚
  â–ˆâ–ƒâ–ˆâ–ˆâ–â–‡â–‡â–„â–†â–ˆâ–†â–ˆâ–ˆâ–‡â–†â–†â–ˆâ–†â–…â–ˆâ–‡â–„â–…â–†â–…â–…â–…â–‡â–‡â–ˆâ–‡â–‡â–ˆâ–ˆâ–‡â–ˆâ–ˆâ–‡â–ˆâ–ˆâ–‡â–‡â–‡â–†â–‡â–‡â–‡â–‡â–†â–‡â–†â–‡â–‡â–‡â–†â–†â–…â–‡â–‡â–†â–† â–ˆ
  223 ns        Histogram: log(frequency) by time        295 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 43 evaluations.
 Range (min â€¦ max):  902.326 ns â€¦  2.172 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     907.000 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   909.642 ns Â± 24.350 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

   â–†â–ˆâ–‡â–ƒ                                                        â–
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–„â–â–â–â–â–â–â–ƒâ–†â–…â–„â–…â–…â–…â–…â–…â–„â–ƒâ–â–â–„â–â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ƒâ–â–â–â–â–â–ƒâ–„â–…â–…â–ƒ â–ˆ
  902 ns        Histogram: log(frequency) by time      1.02 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  17.704 Î¼s â€¦ 60.716 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     19.605 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   19.719 Î¼s Â±  2.444 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–…â–‡    â–‚â–ˆ      â–†â–ƒ                                            â–‚
  â–ˆâ–ˆâ–ƒâ–â–â–â–ˆâ–ˆâ–ˆâ–ƒâ–â–â–â–ˆâ–ˆâ–ˆâ–ƒâ–â–â–â–â–â–…â–…â–…â–„â–â–ƒâ–â–â–ƒâ–„â–„â–„â–„â–„â–â–ƒâ–ƒâ–â–„â–ƒâ–…â–ƒâ–ƒâ–ƒâ–ƒâ–â–â–â–â–„â–…â–†â–‡â–‡â–†â–‡â–‡ â–ˆ
  17.7 Î¼s      Histogram: log(frequency) by time      32.7 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, let&#39;s look at a structure of arrays (SoA). Interestingly, this is slower than the array of structures we used above. On Julia v1.6, the sparse matrix representation performs particularly bad in this case.</p><pre><code class="language-julia hljs">println(&quot;Structure of Arrays&quot;)
u_soa = StructArray(u_aos); du_soa = similar(u_soa)
@show D_SBP * u_soa â‰ˆ D_sparse * u_soa â‰ˆ D_full * u_soa
mul!(du_soa, D_SBP, u_soa)
@show du_soa â‰ˆ du_aos
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_SBP, $u_soa))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_sparse, $u_soa))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_full, $u_soa))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Structure of Arrays
â”Œ Warning: #= /home/runner/work/SummationByPartsOperators.jl/SummationByPartsOperators.jl/src/SBP_operators.jl:388 =#:
â”‚ `LoopVectorization.check_args` on your inputs failed; running fallback `@inbounds @fastmath` loop instead.
â”‚ Use `warn_check_args=false`, e.g. `@turbo warn_check_args=false ...`, to disable this warning.
â”” @ SummationByPartsOperators ~/.julia/packages/LoopVectorization/wLMFa/src/condense_loopset.jl:825
D_SBP * u_soa â‰ˆ D_sparse * u_soa â‰ˆ D_full * u_soa = true
du_soa â‰ˆ du_aos = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 294 evaluations.
 Range (min â€¦ max):  260.207 ns â€¦ 530.619 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     282.316 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   299.465 ns Â±  24.940 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

            â–…â–ˆ          â–â–‡â–ƒ            â–â–†â–‚                      â–‚
  â–…â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–…â–ˆâ–‡â–„â–ƒâ–â–â–†â–ˆâ–‡â–ˆâ–ˆâ–ˆâ–„â–‡â–…â–„â–â–â–â–ƒâ–†â–‡â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–‡â–ˆâ–ˆâ–ˆâ–‡â–‡â–‡â–‡â–‡â–‡â–†â–‡â–‡â–†â–‡â–…â–†â–… â–ˆ
  260 ns        Histogram: log(frequency) by time        379 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  362.105 Î¼s â€¦  11.579 ms  â”Š GC (min â€¦ max):  0.00% â€¦ 95.06%
 Time  (median):     390.555 Î¼s               â”Š GC (median):     0.00%
 Time  (mean Â± Ïƒ):   478.135 Î¼s Â± 738.935 Î¼s  â”Š GC (mean Â± Ïƒ):  10.24% Â±  6.38%

       â–‡â–ˆ â–                                                â–
  â–‚â–ƒâ–…â–…â–„â–ˆâ–ˆâ–ˆâ–ˆâ–„â–„â–ƒâ–ƒâ–ƒâ–ƒâ–ƒâ–ƒâ–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–â–â–‚â–â–â–‚â–‚â–‚â–‚â–‚â–‚â–â–â–‚â–‚â–‚â–†â–ˆâ–„â–ƒâ–ƒ â–ƒ
  362 Î¼s           Histogram: frequency by time          590 Î¼s &lt;

 Memory estimate: 328.25 KiB, allocs estimate: 10504.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  251.303 Î¼s â€¦  11.419 ms  â”Š GC (min â€¦ max):  0.00% â€¦ 96.19%
 Time  (median):     281.103 Î¼s               â”Š GC (median):     0.00%
 Time  (mean Â± Ïƒ):   366.973 Î¼s Â± 737.874 Î¼s  â”Š GC (mean Â± Ïƒ):  13.30% Â±  6.44%

       â–ˆ  â–
  â–‚â–â–‚â–„â–„â–ˆâ–…â–…â–ˆâ–ƒâ–ƒâ–ƒâ–ƒâ–ƒâ–ƒâ–ƒâ–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–‚â–‚â–‚â–â–‚â–â–‚â–‚â–â–‚â–â–‚â–‚â–â–â–‚â–‚â–â–â–‚â–‚â–‚â–‚â–â–‚â–‚â–‚â–„â–„â–„â–„â–ƒâ–ƒâ–‚ â–‚
  251 Î¼s           Histogram: frequency by time          479 Î¼s &lt;

 Memory estimate: 328.25 KiB, allocs estimate: 10504.</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../applications/">Â« Applications &amp; references</a><a class="docs-footer-nextpage" href="../api_reference/">API reference Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.14 on <span class="colophon-date" title="Friday 4 March 2022 14:12">Friday 4 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
