<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Benchmarks Â· SummationByPartsOperators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/benchmarks/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SummationByPartsOperators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/constant_linear_advection/">Linear advection equation with constant coefficients</a></li><li><a class="tocitem" href="../tutorials/advection_diffusion/">Linear advection diffusion equation with periodic boundary conditions</a></li><li><a class="tocitem" href="../tutorials/variable_linear_advection/">Linear advection equation with variable coefficients</a></li><li><a class="tocitem" href="../tutorials/wave_equation/">Wave equation</a></li></ul></li><li><a class="tocitem" href="../applications/">Applications &amp; references</a></li><li class="is-active"><a class="tocitem" href>Benchmarks</a><ul class="internal"><li><a class="tocitem" href="#First-derivative-operators"><span>First-derivative operators</span></a></li><li><a class="tocitem" href="#Dissipation-operators"><span>Dissipation operators</span></a></li><li><a class="tocitem" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)"><span>Structure-of-Arrays (SoA) and Array-of-Structures (AoS)</span></a></li></ul></li><li><a class="tocitem" href="../api_reference/">API reference</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Benchmarks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Benchmarks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ranocha/SummationByPartsOperators.jl/blob/master/docs/src/benchmarks.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Benchmarks"><a class="docs-heading-anchor" href="#Benchmarks">Benchmarks</a><a id="Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarks" title="Permalink"></a></h1><p>Here are some simple benchmarks. Take them with a grain of salt since they run on virtual machines in the cloud to generate the documentation automatically.</p><h2 id="First-derivative-operators"><a class="docs-heading-anchor" href="#First-derivative-operators">First-derivative operators</a><a id="First-derivative-operators-1"></a><a class="docs-heading-anchor-permalink" href="#First-derivative-operators" title="Permalink"></a></h2><h4 id="Periodic-domains"><a class="docs-heading-anchor" href="#Periodic-domains">Periodic domains</a><a id="Periodic-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-domains" title="Permalink"></a></h4><p>Let&#39;s set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, DiffEqOperators

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = periodic_derivative_operator(derivative_order=1, accuracy_order=2,
                                     xmin=xmin, xmax=xmax, N=100)
x = grid(D_SBP)
D_DEO = CenteredDifference(derivative_order(D_SBP), accuracy_order(D_SBP),
                           step(x), length(x)) * PeriodicBC(eltype(D_SBP))

D_sparse = sparse(D_SBP)

u = randn(eltype(D_SBP), length(x)); du = similar(u);
@show D_SBP * u â‰ˆ D_DEO * u â‰ˆ D_sparse * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>First, we benchmark the implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 990 evaluations.
 Range (min â€¦ max):  45.860 ns â€¦  2.017 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     46.062 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   47.269 ns Â± 22.344 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆ                                                           â–
  â–ˆâ–„â–ƒâ–ƒâ–‡â–†â–ƒâ–â–â–ƒâ–…â–‡â–…â–†â–„â–â–ƒâ–ƒâ–ƒâ–„â–‡â–…â–…â–„â–…â–„â–â–ƒâ–„â–ƒâ–ƒâ–„â–„â–„â–„â–ƒâ–ƒâ–„â–„â–â–„â–…â–…â–…â–…â–…â–ƒâ–„â–ƒâ–„â–„â–„â–„â–â–„â–„â–ƒâ–…â–„ â–ˆ
  45.9 ns      Histogram: log(frequency) by time      77.4 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we compare this to the runtime obtained using a sparse matrix representation of the derivative operator. Depending on the hardware etc., this can be an order of magnitude slower than the optimized implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_sparse, &quot;D_sparse:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_sparse:
BenchmarkTools.Trial: 10000 samples with 209 evaluations.
 Range (min â€¦ max):  415.316 ns â€¦  4.455 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     428.234 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   432.611 ns Â± 56.612 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

      â–ƒâ–ˆ                                                       â–
  â–…â–„â–„â–ˆâ–ˆâ–ˆâ–…â–ƒâ–…â–‡â–ˆâ–„â–ƒâ–â–â–„â–‡â–ˆâ–‡â–†â–„â–„â–„â–„â–„â–…â–…â–‡â–‡â–…â–…â–„â–ƒâ–„â–„â–„â–„â–ƒâ–ƒâ–ƒâ–ƒâ–â–ƒâ–â–â–â–â–„â–„â–â–ƒâ–„â–„â–„â–„â–ƒâ–â–ƒâ–ƒâ–„ â–ˆ
  415 ns        Histogram: log(frequency) by time       555 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, we benchmark the implementation of the same derivative operator in DiffEqOperators.jl.</p><pre><code class="language-julia hljs">doit(D_DEO, &quot;D_DEO:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_DEO:
BenchmarkTools.Trial: 10000 samples with 852 evaluations.
 Range (min â€¦ max):  144.719 ns â€¦  2.943 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     145.424 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   147.834 ns Â± 44.363 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆâ–…      â–                                                    â–
  â–ˆâ–ˆâ–ƒâ–ˆâ–‡â–ˆâ–†â–‡â–ˆâ–‡â–†â–‡â–†â–„â–‡â–ˆâ–‡â–†â–†â–…â–…â–…â–„â–„â–â–ƒâ–â–ƒâ–â–„â–„â–„â–„â–„â–ƒâ–„â–â–…â–„â–„â–ƒâ–„â–…â–…â–„â–„â–…â–„â–…â–ƒâ–„â–â–â–„â–ƒâ–„â–ƒâ–â–„â–„ â–ˆ
  145 ns        Histogram: log(frequency) by time       195 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><h4 id="Bounded-domains"><a class="docs-heading-anchor" href="#Bounded-domains">Bounded domains</a><a id="Bounded-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Bounded-domains" title="Permalink"></a></h4><p>We start again by setting up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,
                            accuracy_order=6, xmin=xmin, xmax=xmax, N=10^3)
D_sparse = sparse(D_SBP)
D_banded = BandedMatrix(D_SBP)

u = randn(eltype(D_SBP), size(D_SBP, 1)); du = similar(u);
@show D_SBP * u â‰ˆ D_sparse * u â‰ˆ D_banded * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>First, we benchmark the implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 96 evaluations.
 Range (min â€¦ max):  797.917 ns â€¦  25.460 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     804.177 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   825.330 ns Â± 384.513 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆâ–ˆ  â–                                                         â–‚
  â–ˆâ–ˆâ–â–…â–ˆâ–†â–ƒâ–â–ƒâ–‡â–ˆâ–†â–…â–„â–„â–…â–†â–ˆâ–‡â–†â–…â–„â–…â–„â–„â–„â–„â–…â–…â–„â–„â–„â–†â–†â–†â–…â–…â–‡â–†â–â–…â–…â–„â–†â–…â–…â–…â–„â–â–„â–ƒâ–â–ƒâ–ƒâ–ƒâ–ƒâ–â–„â–„â–ƒâ–„ â–ˆ
  798 ns        Histogram: log(frequency) by time       1.21 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Again, we compare this to a representation of the derivative operator as a sparse matrix. No surprise - it is again much slower, as in periodic domains.</p><pre><code class="language-julia hljs">doit(D_sparse, &quot;D_sparse:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_sparse:
BenchmarkTools.Trial: 10000 samples with 4 evaluations.
 Range (min â€¦ max):  7.300 Î¼s â€¦ 72.126 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     7.375 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   7.464 Î¼s Â±  1.321 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

   â–ƒâ–ˆâ–ƒ
  â–„â–ˆâ–ˆâ–ˆâ–‚â–‚â–‚â–‚â–â–‚â–â–â–â–â–â–â–â–â–â–â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚ â–‚
  7.3 Î¼s         Histogram: frequency by time        9.13 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>FInally, we compare it to a representation as banded matrix. Disappointingly, this is still much slower than the optimized implementation from SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_banded, &quot;D_banded:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_banded:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  14.800 Î¼s â€¦ 180.002 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     15.000 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   15.110 Î¼s Â±   2.875 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

         â–ˆ      â–…
  â–‚â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–ˆâ–„â–â–â–â–â–â–â–‚â–â–â–â–â–â–â–‚â–‚â–â–â–â–â–â–â–‚â–â–â–â–â–â–â–‚â–â–â–â–â–â–â–â–‚â–â–â–â–â–â–â–‚ â–‚
  14.8 Î¼s         Histogram: frequency by time         15.6 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><h2 id="Dissipation-operators"><a class="docs-heading-anchor" href="#Dissipation-operators">Dissipation operators</a><a id="Dissipation-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Dissipation-operators" title="Permalink"></a></h2><p>We follow the same structure as before. At first, we set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,
                            accuracy_order=6, xmin=xmin, xmax=xmax, N=10^3)
Di_SBP  = dissipation_operator(MattssonSvÃ¤rdNordstrÃ¶m2004(), D_SBP)
Di_sparse = sparse(Di_SBP)
Di_banded = BandedMatrix(Di_SBP)
Di_full   = Matrix(Di_SBP)

u = randn(eltype(D_SBP), size(D_SBP, 1)); du = similar(u);
@show Di_SBP * u â‰ˆ Di_sparse * u â‰ˆ Di_banded * u â‰ˆ Di_full * u

function doit(D, text, du, u)
  println(text)
  sleep(0.1)
  show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D, $u))
  println()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doit (generic function with 1 method)</code></pre><p>At first, let us benchmark the derivative and dissipation operators implemented in SummationByPartsOperators.jl.</p><pre><code class="language-julia hljs">doit(D_SBP, &quot;D_SBP:&quot;, du, u)
doit(Di_SBP, &quot;Di_SBP:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">D_SBP:
BenchmarkTools.Trial: 10000 samples with 85 evaluations.
 Range (min â€¦ max):  816.482 ns â€¦  3.758 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     820.012 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   828.173 ns Â± 69.383 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–†â–ˆâ–ƒ                                                          â–
  â–ˆâ–ˆâ–ˆâ–†â–â–ƒâ–â–â–â–‡â–†â–‡â–…â–„â–ƒâ–â–â–â–â–â–â–â–„â–…â–†â–‡â–‡â–…â–…â–„â–„â–â–â–ƒâ–ƒâ–ƒâ–ƒâ–â–â–â–„â–ƒâ–…â–…â–†â–†â–†â–„â–…â–„â–„â–„â–â–„â–ƒâ–â–â–â–„â–… â–ˆ
  816 ns        Histogram: log(frequency) by time       994 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
Di_SBP:
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min â€¦ max):  1.980 Î¼s â€¦  13.940 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     1.990 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   2.013 Î¼s Â± 283.046 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–‚                  â–ˆ                   â–ˆ                  â–‚ â–‚
  â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆ â–ˆ
  1.98 Î¼s      Histogram: log(frequency) by time      2.01 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we compare the results to sparse matrix representations. It will not come as a surprise that these are again much (around an order of magnitude) slower.</p><pre><code class="language-julia hljs">doit(Di_sparse, &quot;Di_sparse:&quot;, du, u)
doit(Di_banded, &quot;Di_banded:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Di_sparse:
BenchmarkTools.Trial: 10000 samples with 3 evaluations.
 Range (min â€¦ max):  8.333 Î¼s â€¦ 601.707 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     8.434 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   8.604 Î¼s Â±   6.156 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

   â–â–ˆâ–…
  â–ƒâ–ˆâ–ˆâ–ˆâ–†â–ƒâ–‚â–‚â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‚â–‚â–‚ â–‚
  8.33 Î¼s         Histogram: frequency by time        10.7 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
Di_banded:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  12.300 Î¼s â€¦ 532.006 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     12.400 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   12.652 Î¼s Â±   8.056 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                     â–ˆ
  â–…â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–…â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–†â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‚ â–‚
  12.3 Î¼s         Histogram: frequency by time         12.6 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, let&#39;s benchmark the same computation if a full (dense) matrix is used to represent the derivative operator. This is obviously a bad idea but ğŸ¤·</p><pre><code class="language-julia hljs">doit(Di_full, &quot;Di_full:&quot;, du, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Di_full:
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  248.503 Î¼s â€¦   8.207 ms  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     252.503 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   257.833 Î¼s Â± 106.033 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆâ–…â–‚â–ˆâ–ƒ â– â–‚  â–ƒâ– â–                                               â–‚
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–ˆâ–ˆâ–‡â–ˆâ–ˆâ–‡â–…â–…â–…â–…â–„â–„â–†â–†â–ˆâ–‡â–†â–†â–†â–…â–…â–†â–…â–†â–…â–†â–‡â–†â–†â–…â–…â–‡â–†â–†â–†â–†â–…â–…â–†â–†â–…â–…â–ƒâ–…â–„â–â–…â–…â–…â–… â–ˆ
  249 Î¼s        Histogram: log(frequency) by time        329 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><h2 id="Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)"><a class="docs-heading-anchor" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)">Structure-of-Arrays (SoA) and Array-of-Structures (AoS)</a><a id="Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-of-Arrays-(SoA)-and-Array-of-Structures-(AoS)" title="Permalink"></a></h2><p><a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a> tries to provide efficient support of</p><ul><li><code>StaticVector</code>s from <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a></li><li><a href="https://github.com/JuliaArrays/StructArrays.jl">StructArrays.jl</a></li></ul><p>To demonstrate this, let us set up some benchmark code.</p><pre><code class="language-julia hljs">using BenchmarkTools
using StaticArrays, StructArrays
using LinearAlgebra, SparseArrays
using SummationByPartsOperators, BandedMatrices

BLAS.set_num_threads(1) # make sure that BLAS is serial to be fair

struct Vec5{T} &lt;: FieldVector{5,T}
  x1::T
  x2::T
  x3::T
  x4::T
  x5::T
end

# Apply `mul!` to each component of a plain array of structures one after another
function mul_aos!(du, D, u, args...)
  for i in 1:size(du, 1)
    mul!(view(du, i, :), D, view(u, i, :), args...)
  end
end

T = Float64
xmin, xmax = T(0), T(1)

D_SBP = derivative_operator(MattssonNordstrÃ¶m2004(), derivative_order=1,
                            accuracy_order=4, xmin=xmin, xmax=xmax, N=101)
D_sparse = sparse(D_SBP)
D_full   = Matrix(D_SBP)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">101Ã—101 Matrix{Float64}:
 -141.176    173.529   -23.5294   â€¦    0.0         0.0       0.0
  -50.0        0.0      50.0           0.0         0.0       0.0
    9.30233  -68.6047    0.0           0.0         0.0       0.0
    3.06122    0.0     -60.2041        0.0         0.0       0.0
    0.0        0.0       8.33333       0.0         0.0       0.0
    0.0        0.0       0.0      â€¦    0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    â‹®                             â‹±                          â‹®
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0           0.0         0.0       0.0
    0.0        0.0       0.0      â€¦    0.0         0.0       0.0
    0.0        0.0       0.0          -8.33333     0.0       0.0
    0.0        0.0       0.0          60.2041      0.0      -3.06122
    0.0        0.0       0.0           0.0        68.6047   -9.30233
    0.0        0.0       0.0         -50.0         0.0      50.0
    0.0        0.0       0.0      â€¦   23.5294   -173.529   141.176</code></pre><p>At first, we benchmark the application of the operators implemented in SummationByPartsOperators.jl and their representations as sparse and dense matrices in the scalar case. As before, the sparse matrix representation is around an order of magnitude slower and the dense matrix representation is far off.</p><pre><code class="language-julia hljs">println(&quot;Scalar case&quot;)
u = randn(T, size(D_SBP, 1)); du = similar(u)
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_SBP, $u))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_sparse, $u))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du, $D_full, $u))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Scalar case
D_SBP
BenchmarkTools.Trial: 10000 samples with 974 evaluations.
 Range (min â€¦ max):  75.462 ns â€¦  2.856 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     75.566 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   80.274 ns Â± 63.620 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆ                                                           â–
  â–ˆâ–†â–ˆâ–ƒâ–…â–ˆâ–…â–„â–„â–‡â–‡â–‡â–†â–…â–…â–†â–…â–…â–†â–‡â–†â–†â–†â–†â–…â–†â–…â–„â–…â–…â–†â–†â–…â–…â–…â–„â–†â–…â–…â–†â–„â–…â–…â–†â–…â–„â–„â–â–ƒâ–…â–„â–…â–…â–…â–…â–„â–„â–„â–„ â–ˆ
  75.5 ns      Histogram: log(frequency) by time       143 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 187 evaluations.
 Range (min â€¦ max):  552.412 ns â€¦  5.249 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     555.626 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   564.026 ns Â± 89.102 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆâ–†  â–    â–                                                   â–
  â–ˆâ–ˆâ–…â–‡â–ˆâ–†â–ƒâ–ƒâ–‡â–ˆâ–‡â–†â–…â–…â–…â–†â–‡â–‡â–†â–†â–…â–„â–…â–…â–„â–ƒâ–„â–„â–ƒâ–„â–ƒâ–â–„â–â–„â–ƒâ–„â–…â–„â–„â–„â–„â–…â–â–â–ƒâ–„â–„â–…â–ƒâ–ƒâ–…â–ƒâ–ƒâ–„â–„â–ƒâ–„â–„â–„ â–ˆ
  552 ns        Histogram: log(frequency) by time       778 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 10 evaluations.
 Range (min â€¦ max):  2.000 Î¼s â€¦  36.501 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     2.030 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   2.054 Î¼s Â± 567.969 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

      â–… â–ˆ
  â–‚â–â–ƒâ–â–ˆâ–â–ˆâ–â–…â–â–‚â–â–â–‚â–â–‚â–â–‚â–â–‚â–â–â–â–â–‚â–â–‚â–â–â–â–‚â–â–‚â–â–‚â–â–â–â–â–‚â–â–‚â–â–‚â–â–‚â–â–â–‚â–â–â–â–â–â–â–â–‚â–â–‚ â–‚
  2 Î¼s            Histogram: frequency by time        2.27 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we use a plain array of structures (AoS) in the form of a two-dimensional array and our custom <code>mul_aos!</code> implementation that loops over each component, using <code>mul!</code> on <code>view</code>s. Here, the differences between the timings are less pronounced.</p><pre><code class="language-julia hljs">println(&quot;Plain Array of Structures&quot;)
u_aos_plain = randn(T, 5, size(D_SBP, 1)); du_aos_plain = similar(u_aos_plain)
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_SBP, $u_aos_plain))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_sparse, $u_aos_plain))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul_aos!($du_aos_plain, $D_full, $u_aos_plain))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Plain Array of Structures
D_SBP
BenchmarkTools.Trial: 10000 samples with 9 evaluations.
 Range (min â€¦ max):  2.400 Î¼s â€¦  32.711 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     2.411 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   2.441 Î¼s Â± 465.715 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–‚ â–ˆ â–‡                                                       â–
  â–ˆâ–â–ˆâ–â–ˆâ–â–â–ˆâ–â–…â–â–â–ƒâ–â–„â–â–â–„â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–…â–â–ƒ â–ˆ
  2.4 Î¼s       Histogram: log(frequency) by time      2.67 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 8 evaluations.
 Range (min â€¦ max):  3.663 Î¼s â€¦  49.600 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     3.675 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   3.720 Î¼s Â± 648.705 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆâ–‡â–                                                         â–
  â–ˆâ–ˆâ–ˆâ–‡â–‡â–…â–â–ƒâ–â–â–â–â–â–â–â–â–ƒâ–â–â–ƒâ–ƒâ–„â–„â–†â–…â–…â–…â–ƒâ–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ƒâ–â–ƒâ–â–ƒâ–„â–„â–…â–„â–„â–„ â–ˆ
  3.66 Î¼s      Histogram: log(frequency) by time      4.49 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  10.900 Î¼s â€¦ 107.001 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     11.100 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   11.197 Î¼s Â±   2.115 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                               â–ˆ
  â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–…â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–„â–â–â–â–â–â–â–â–â–â–â–â–â–â–…â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–‚ â–‚
  10.9 Î¼s         Histogram: frequency by time         11.3 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Now, we use an array of structures (AoS) based on <code>reinterpret</code> and standard <code>mul!</code>. This is much more efficient for the implementation in SummationByPartsOperators.jl. In Julia v1.6, this is also more efficient for sparse matrices but less efficient for dense matrices (compared to the plain AoS approach with <code>mul_aos!</code> above).</p><pre><code class="language-julia hljs">println(&quot;Array of Structures (reinterpreted array)&quot;)
u_aos_r = reinterpret(reshape, Vec5{T}, u_aos_plain); du_aos_r = similar(u_aos_r)
@show D_SBP * u_aos_r â‰ˆ D_sparse * u_aos_r â‰ˆ D_full * u_aos_r
mul!(du_aos_r, D_SBP, u_aos_r)
@show reinterpret(reshape, T, du_aos_r) â‰ˆ du_aos_plain
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_SBP, $u_aos_r))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_sparse, $u_aos_r))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos_r, $D_full, $u_aos_r))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Array of Structures (reinterpreted array)
D_SBP * u_aos_r â‰ˆ D_sparse * u_aos_r â‰ˆ D_full * u_aos_r = true
reinterpret(reshape, T, du_aos_r) â‰ˆ du_aos_plain = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 196 evaluations.
 Range (min â€¦ max):  468.883 ns â€¦  26.554 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     471.944 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   488.886 ns Â± 400.510 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆâ–†                                                            â–
  â–ˆâ–ˆâ–ƒâ–ˆâ–‡â–„â–â–‡â–ˆâ–‡â–ƒâ–ƒâ–…â–…â–‡â–‡â–‡â–…â–†â–„â–…â–…â–…â–†â–…â–ƒâ–„â–…â–†â–†â–†â–†â–…â–†â–…â–†â–…â–…â–†â–†â–…â–…â–…â–†â–…â–…â–„â–„â–„â–…â–…â–…â–„â–„â–„â–„â–…â–…â–ƒâ–„â–… â–ˆ
  469 ns        Histogram: log(frequency) by time        703 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 14 evaluations.
 Range (min â€¦ max):  985.714 ns â€¦  31.786 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     992.857 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):     1.009 Î¼s Â± 433.682 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                                â–ˆ                             â–
  â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆ â–‚
  986 ns           Histogram: frequency by time            1 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  14.800 Î¼s â€¦ 508.506 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     14.900 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   15.083 Î¼s Â±   5.699 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–‚        â–ˆ
  â–ˆâ–â–â–â–â–â–â–â–â–ˆâ–…â–â–â–â–â–â–â–â–â–ƒâ–‚â–â–â–â–â–â–â–â–â–ƒâ–‚â–â–â–â–â–â–â–â–â–‚â–‚â–â–â–â–â–â–â–â–â–‚â–‚â–â–â–â–â–â–â–â–â–‚ â–‚
  14.8 Î¼s         Histogram: frequency by time         15.4 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Next, we still use an array of structures (AoS), but copy the data into a plain <code>Array</code> instead of using the <code>reinterpret</code>ed versions. There is no significant difference to the previous version in this case.</p><pre><code class="language-julia hljs">println(&quot;Array of Structures&quot;)
u_aos = Array(u_aos_r); du_aos = similar(u_aos)
@show D_SBP * u_aos â‰ˆ D_sparse * u_aos â‰ˆ D_full * u_aos
mul!(du_aos, D_SBP, u_aos)
@show du_aos â‰ˆ du_aos_r
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_SBP, $u_aos))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_sparse, $u_aos))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_aos, $D_full, $u_aos))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Array of Structures
D_SBP * u_aos â‰ˆ D_sparse * u_aos â‰ˆ D_full * u_aos = true
du_aos â‰ˆ du_aos_r = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 198 evaluations.
 Range (min â€¦ max):  431.318 ns â€¦  3.526 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     432.328 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   438.787 ns Â± 66.755 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆâ–ƒ  â–                                                        â–
  â–ˆâ–ˆâ–ˆâ–‡â–ˆâ–…â–â–â–„â–ˆâ–ˆâ–‡â–â–â–ƒâ–„â–„â–†â–‡â–‡â–…â–„â–„â–„â–„â–„â–„â–„â–â–â–ƒâ–„â–„â–„â–ƒâ–â–â–â–„â–ƒâ–ƒâ–„â–â–ƒâ–„â–â–„â–ƒâ–ƒâ–ƒâ–â–â–„â–ƒâ–â–â–„â–ƒâ–ƒâ–„ â–ˆ
  431 ns        Histogram: log(frequency) by time       613 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 17 evaluations.
 Range (min â€¦ max):  970.588 ns â€¦   8.988 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     982.353 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   995.286 ns Â± 205.010 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

                                â–ˆ
  â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–…â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‚ â–‚
  971 ns           Histogram: frequency by time          994 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  14.000 Î¼s â€¦ 242.803 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     14.200 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   14.360 Î¼s Â±   3.073 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

           â–ƒâ–        â–ˆâ–†        â–…â–‚                              â–
  â–‡â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–â–â–â–â–â–â–â–â–ˆâ–ˆâ–â–â–â–â–â–â–â–â–ˆâ–ˆâ–â–â–â–â–â–â–â–â–‡â–„â–â–â–â–â–â–â–â–â–†â–…â–â–â–â–â–â–â–â–â–ƒ â–ˆ
  14 Î¼s         Histogram: log(frequency) by time      14.6 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Finally, let&#39;s look at a structure of arrays (SoA). Interestingly, this is slower than the array of structures we used above. On Julia v1.6, the sparse matrix representation performs particularly bad in this case.</p><pre><code class="language-julia hljs">println(&quot;Structure of Arrays&quot;)
u_soa = StructArray(u_aos); du_soa = similar(u_soa)
@show D_SBP * u_soa â‰ˆ D_sparse * u_soa â‰ˆ D_full * u_soa
mul!(du_soa, D_SBP, u_soa)
@show du_soa â‰ˆ du_aos
println(&quot;D_SBP&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_SBP, $u_soa))
println(&quot;\nD_sparse&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_sparse, $u_soa))
println(&quot;\nD_full&quot;)
show(stdout, MIME&quot;text/plain&quot;(), @benchmark mul!($du_soa, $D_full, $u_soa))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Structure of Arrays
D_SBP * u_soa â‰ˆ D_sparse * u_soa â‰ˆ D_full * u_soa = true
du_soa â‰ˆ du_aos = true
D_SBP
BenchmarkTools.Trial: 10000 samples with 198 evaluations.
 Range (min â€¦ max):  451.015 ns â€¦  33.442 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     453.035 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   465.073 ns Â± 345.958 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆ                                                             â–
  â–ˆâ–†â–…â–ˆâ–‡â–…â–ƒâ–…â–ˆâ–‡â–†â–…â–„â–„â–…â–‡â–ˆâ–†â–†â–…â–…â–„â–„â–…â–…â–…â–„â–„â–…â–„â–…â–†â–†â–…â–†â–…â–…â–…â–…â–„â–…â–„â–…â–…â–„â–…â–„â–…â–ƒâ–„â–„â–…â–„â–„â–„â–„â–â–ƒâ–„â–„â–„ â–ˆ
  451 ns        Histogram: log(frequency) by time        664 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_sparse
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  146.701 Î¼s â€¦ 786.409 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     148.402 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   149.838 Î¼s Â±  13.383 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–†â–†â–ˆ â–    â–                                                    â–
  â–ˆâ–ˆâ–ˆâ–‡â–ˆâ–ˆâ–†â–‡â–ˆâ–ˆâ–‡â–†â–†â–‡â–ˆâ–ˆâ–‡â–†â–…â–„â–…â–„â–„â–â–â–„â–â–ƒâ–„â–„â–â–†â–„â–…â–ƒâ–„â–„â–â–â–„â–ƒâ–ƒâ–â–…â–„â–„â–…â–„â–„â–ƒâ–…â–„â–ƒâ–ƒâ–„â–„â–…â–…â–…â–†â–… â–ˆ
  147 Î¼s        Histogram: log(frequency) by time        196 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.
D_full
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min â€¦ max):  25.000 Î¼s â€¦ 401.805 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     25.200 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   25.796 Î¼s Â±   8.691 Î¼s  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–†â–ˆâ–…                                                          â–
  â–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–†â–†â–†â–ƒâ–„â–â–â–â–â–â–â–â–â–â–ƒâ–…â–…â–„â–…â–ƒâ–â–„â–â–â–ƒâ–ƒâ–â–â–â–ƒâ–â–â–â–â–â–â–â–â–â–â–ƒâ–â–â–ƒâ–„â–…â–â–„â–…â–â–ƒâ–ƒâ–â–ƒ â–ˆ
  25 Î¼s         Histogram: log(frequency) by time      33.2 Î¼s &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../applications/">Â« Applications &amp; references</a><a class="docs-footer-nextpage" href="../api_reference/">API reference Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Wednesday 25 August 2021 14:19">Wednesday 25 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
