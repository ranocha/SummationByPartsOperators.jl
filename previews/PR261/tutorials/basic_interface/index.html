<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic interface · SummationByPartsOperators.jl</title><meta name="title" content="Basic interface · SummationByPartsOperators.jl"/><meta property="og:title" content="Basic interface · SummationByPartsOperators.jl"/><meta property="twitter:title" content="Basic interface · SummationByPartsOperators.jl"/><meta name="description" content="Documentation for SummationByPartsOperators.jl."/><meta property="og:description" content="Documentation for SummationByPartsOperators.jl."/><meta property="twitter:description" content="Documentation for SummationByPartsOperators.jl."/><meta property="og:url" content="https://ranocha.github.io/SummationByPartsOperators.jl/stable/tutorials/basic_interface/"/><meta property="twitter:url" content="https://ranocha.github.io/SummationByPartsOperators.jl/stable/tutorials/basic_interface/"/><link rel="canonical" href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/tutorials/basic_interface/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SummationByPartsOperators.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../introduction/">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Basic interface</a><ul class="internal"><li><a class="tocitem" href="#Applying-SBP-operators"><span>Applying SBP operators</span></a></li><li><a class="tocitem" href="#Integration-and-the-mass/norm-matrix"><span>Integration and the mass/norm matrix</span></a></li><li><a class="tocitem" href="#Multi-dimensional-cases-or-multiple-variables"><span>Multi-dimensional cases or multiple variables</span></a></li></ul></li><li><a class="tocitem" href="../constant_linear_advection/">Linear advection equation with constant coefficients</a></li><li><a class="tocitem" href="../advection_diffusion/">Linear advection diffusion equation with periodic boundary conditions</a></li><li><a class="tocitem" href="../variable_linear_advection/">Linear advection equation with variable coefficients</a></li><li><a class="tocitem" href="../wave_equation/">Wave equation</a></li><li><a class="tocitem" href="../kdv/">Korteweg-de Vries equation</a></li></ul></li><li><a class="tocitem" href="../../ad/">Automatic differentiation (AD)</a></li><li><a class="tocitem" href="../../applications/">Applications &amp; references</a></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../../api_reference/">API reference</a></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../code_of_conduct/">Code of conduct</a></li><li><a class="tocitem" href="../../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Basic interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basic interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ranocha/SummationByPartsOperators.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ranocha/SummationByPartsOperators.jl/blob/main/docs/src/tutorials/basic_interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-interface"><a class="docs-heading-anchor" href="#Basic-interface">Basic interface</a><a id="Basic-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-interface" title="Permalink"></a></h1><p>Here, we discuss the basic interface of <a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a>. We assume you are already familiar with the concept of SBP operators in general and the <a href="../../introduction/#intro-introduction">introduction</a> describing how to construct specific operators.</p><h2 id="Applying-SBP-operators"><a class="docs-heading-anchor" href="#Applying-SBP-operators">Applying SBP operators</a><a id="Applying-SBP-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Applying-SBP-operators" title="Permalink"></a></h2><p>All SBP operators implement the general interface of matrix vector multiplication in Julia. The most simple version is to just use <code>*</code>, e.g.,</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SummationByPartsOperators</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = derivative_operator(MattssonNordström2004(),
                               derivative_order = 1, accuracy_order = 2,
                               xmin = 0.0, xmax = 1.0, N = 9)</code><code class="nohighlight hljs ansi" style="display:block;">SBP first-derivative operator of order 2 on a grid in [0.0, 1.0] using 9 nodes
and coefficients of Mattsson, Nordström (2004)
  Summation by parts operators for finite difference approximations of second
    derivatives.
  Journal of Computational Physics 199, pp. 503-540.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = grid(D)</code><code class="nohighlight hljs ansi" style="display:block;">0.0:0.125:1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = @. sin(pi * x)</code><code class="nohighlight hljs ansi" style="display:block;">9-element Vector{Float64}:
 0.0
 0.3826834323650898
 0.7071067811865475
 0.9238795325112867
 1.0
 0.9238795325112867
 0.7071067811865476
 0.3826834323650899
 1.2246467991473532e-16</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D * u</code><code class="nohighlight hljs ansi" style="display:block;">9-element Vector{Float64}:
  3.0614674589207183
  2.82842712474619
  2.1647844005847876
  1.1715728752538102
  0.0
 -1.1715728752538097
 -2.1647844005847876
 -2.82842712474619
 -3.0614674589207183</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated D * u</code><code class="nohighlight hljs ansi" style="display:block;">160</code></pre><p>As you can see above, calling <code>D * u</code> allocates a new vector for the result. If you want to apply an SBP operator multiple times and need good performance, you should consider using pre-allocating the output and using in-place update instead. This strategy is also described in the <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Pre-allocating-outputs">performance tips in the Julia manual</a>. Julia provides the function <code>mul!</code> for this purpose.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using LinearAlgebra, InteractiveUtils</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @doc mul!</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr36">  mul!(Y, A, B) -&gt; Y</span>

  Calculates the matrix-matrix or matrix-vector product <span class="sgr35">AB</span> and stores the
  result in <span class="sgr36">Y</span>, overwriting the existing value of <span class="sgr36">Y</span>. Note that <span class="sgr36">Y</span> must not be
  aliased with either <span class="sgr36">A</span> or <span class="sgr36">B</span>.

<span class="sgr1">  Examples</span>
<span class="sgr1">  ≡≡≡≡≡≡≡≡≡≡</span>

<span class="sgr36">  julia&gt; A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; Y = similar(B); mul!(Y, A, B);</span>
<span class="sgr36">  </span>
<span class="sgr36">  julia&gt; Y</span>
<span class="sgr36">  2×2 Matrix{Float64}:</span>
<span class="sgr36">   3.0  3.0</span>
<span class="sgr36">   7.0  7.0</span>

<span class="sgr1">  Implementation</span>
<span class="sgr1">  ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡</span>

  For custom matrix and vector types, it is recommended to implement
  5-argument <span class="sgr36">mul!</span> rather than implementing 3-argument <span class="sgr36">mul!</span> directly if
  possible.

<span class="sgr36">  mul!(C, A, B, α, β) -&gt; C</span>

  Combined inplace matrix-matrix or matrix-vector multiply-add <span class="sgr35">A B α + C β</span>.
  The result is stored in <span class="sgr36">C</span> by overwriting it. Note that <span class="sgr36">C</span> must not be aliased
  with either <span class="sgr36">A</span> or <span class="sgr36">B</span>.

<span class="sgr1">  │ Julia 1.3</span>
<span class="sgr1">  │</span>
<span class="sgr1">  │</span>  Five-argument <span class="sgr36">mul!</span> requires at least Julia 1.3.

<span class="sgr1">  Examples</span>
<span class="sgr1">  ≡≡≡≡≡≡≡≡≡≡</span>

<span class="sgr36">  julia&gt; A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; C=[1.0 2.0; 3.0 4.0];</span>
<span class="sgr36">  </span>
<span class="sgr36">  julia&gt; mul!(C, A, B, 100.0, 10.0) === C</span>
<span class="sgr36">  true</span>
<span class="sgr36">  </span>
<span class="sgr36">  julia&gt; C</span>
<span class="sgr36">  2×2 Matrix{Float64}:</span>
<span class="sgr36">   310.0  320.0</span>
<span class="sgr36">   730.0  740.0</span>

<span class="sgr36">  mul!(du, D::DerivativeOperator, u, α=true, β=false)</span>

  Efficient in-place version of <span class="sgr36">du = α * D * u + β * du</span>. Note that <span class="sgr36">du</span> must not
  be aliased with <span class="sgr36">u</span>.

  Do mul! with the off-diagonal elements of a matrix.</code></pre><p>To improve the performance, you can pre-allocate an output vector and call the non-allocating function <code>mul!</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SummationByPartsOperators</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = derivative_operator(MattssonNordström2004(),
                               derivative_order = 1, accuracy_order = 2,
                               xmin = 0.0, xmax = 1.0, N = 9)</code><code class="nohighlight hljs ansi" style="display:block;">SBP first-derivative operator of order 2 on a grid in [0.0, 1.0] using 9 nodes
and coefficients of Mattsson, Nordström (2004)
  Summation by parts operators for finite difference approximations of second
    derivatives.
  Journal of Computational Physics 199, pp. 503-540.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = grid(D)</code><code class="nohighlight hljs ansi" style="display:block;">0.0:0.125:1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = @. sin(pi * x)</code><code class="nohighlight hljs ansi" style="display:block;">9-element Vector{Float64}:
 0.0
 0.3826834323650898
 0.7071067811865475
 0.9238795325112867
 1.0
 0.9238795325112867
 0.7071067811865476
 0.3826834323650899
 1.2246467991473532e-16</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; du = similar(u); mul!(du, D, u)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; du ≈ D * u</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated mul!(du, D, u)</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>All operators provided by <a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a> implement this 3-argument version of <code>mul!</code>. Most operators also implement the 5-argument version of <code>mul!</code> that can be used to scale the output and add it to some multiple of the result vector.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SummationByPartsOperators</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = derivative_operator(MattssonNordström2004(),
                               derivative_order = 1, accuracy_order = 2,
                               xmin = 0.0, xmax = 1.0, N = 9)</code><code class="nohighlight hljs ansi" style="display:block;">SBP first-derivative operator of order 2 on a grid in [0.0, 1.0] using 9 nodes
and coefficients of Mattsson, Nordström (2004)
  Summation by parts operators for finite difference approximations of second
    derivatives.
  Journal of Computational Physics 199, pp. 503-540.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = grid(D); u = @. sin(pi * x); du = similar(u); mul!(du, D, u);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mul!(du, D, u, 2) # equivalent to du .= 2 * D * u</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; du ≈ 2 * D * u</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated mul!(du, D, u, 2)</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; du_background = rand(length(du)); du .= du_background</code><code class="nohighlight hljs ansi" style="display:block;">9-element Vector{Float64}:
 0.7338635873124961
 0.5246260390605373
 0.9988707948648565
 0.9210782217248596
 0.5797455159910299
 0.8324836335131793
 0.12684549172672277
 0.828160432122286
 0.7646761462637865</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mul!(du, D, u, 2, 3) # equivalent to du .= 2 * D * u + 3 * du</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; du ≈ 2 * D * u + 3 * du_background</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated mul!(du, D, u, 2, 3)</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><h2 id="Integration-and-the-mass/norm-matrix"><a class="docs-heading-anchor" href="#Integration-and-the-mass/norm-matrix">Integration and the mass/norm matrix</a><a id="Integration-and-the-mass/norm-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-and-the-mass/norm-matrix" title="Permalink"></a></h2><p>SBP operators come with a mass matrix yielding a quadrature rule. In <a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a>, all operators typically have diagonal mass/norm matrices. You can access them via <a href="../../api_reference/#SummationByPartsOperators.mass_matrix-Tuple{Union{DerivativeOperator, VarCoefDerivativeOperator}}"><code>mass_matrix</code></a>, e.g.,</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SummationByPartsOperators</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = derivative_operator(MattssonNordström2004(),
                               derivative_order = 1, accuracy_order = 2,
                               xmin = 0.0, xmax = 1.0, N = 9)</code><code class="nohighlight hljs ansi" style="display:block;">SBP first-derivative operator of order 2 on a grid in [0.0, 1.0] using 9 nodes
and coefficients of Mattsson, Nordström (2004)
  Summation by parts operators for finite difference approximations of second
    derivatives.
  Journal of Computational Physics 199, pp. 503-540.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mass_matrix(D)</code><code class="nohighlight hljs ansi" style="display:block;">9×9 LinearAlgebra.Diagonal{Float64, Vector{Float64}}:
 0.0625   ⋅      ⋅      ⋅      ⋅      ⋅      ⋅      ⋅      ⋅
  ⋅      0.125   ⋅      ⋅      ⋅      ⋅      ⋅      ⋅      ⋅
  ⋅       ⋅     0.125   ⋅      ⋅      ⋅      ⋅      ⋅      ⋅
  ⋅       ⋅      ⋅     0.125   ⋅      ⋅      ⋅      ⋅      ⋅
  ⋅       ⋅      ⋅      ⋅     0.125   ⋅      ⋅      ⋅      ⋅
  ⋅       ⋅      ⋅      ⋅      ⋅     0.125   ⋅      ⋅      ⋅
  ⋅       ⋅      ⋅      ⋅      ⋅      ⋅     0.125   ⋅      ⋅
  ⋅       ⋅      ⋅      ⋅      ⋅      ⋅      ⋅     0.125   ⋅
  ⋅       ⋅      ⋅      ⋅      ⋅      ⋅      ⋅      ⋅     0.0625</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = periodic_derivative_operator(derivative_order = 1,
                                        accuracy_order = 2,
                                        xmin = 0.0, xmax = 1.0,
                                        N = 8)</code><code class="nohighlight hljs ansi" style="display:block;">Periodic first-derivative operator of order 2 on a grid in [0.0, 1.0] using 8 nodes,
stencils with 1 nodes to the left, 1 nodes to the right, and coefficients of Fornberg (1998)
  Calculation of Weights in Finite Difference Formulas.
  SIAM Rev. 40.3, pp. 685-691.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mass_matrix(D)</code><code class="nohighlight hljs ansi" style="display:block;">LinearAlgebra.UniformScaling{Float64}
0.125*I</code></pre><p>If you want to use the quadrature associated with a mass matrix, you do not need to form it explicitly. Instead, it is recommended to use the function <a href="../../api_reference/#PolynomialBases.integrate-Tuple{Any, AbstractVector{T} where T, DerivativeOperator}"><code>integrate</code></a>, e.g.,</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SummationByPartsOperators</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = derivative_operator(MattssonNordström2004(),
                               derivative_order = 1, accuracy_order = 2,
                               xmin = 0.0, xmax = 1.0, N = 9)</code><code class="nohighlight hljs ansi" style="display:block;">SBP first-derivative operator of order 2 on a grid in [0.0, 1.0] using 9 nodes
and coefficients of Mattsson, Nordström (2004)
  Summation by parts operators for finite difference approximations of second
    derivatives.
  Journal of Computational Physics 199, pp. 503-540.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = mass_matrix(D)</code><code class="nohighlight hljs ansi" style="display:block;">9×9 LinearAlgebra.Diagonal{Float64, Vector{Float64}}:
 0.0625   ⋅      ⋅      ⋅      ⋅      ⋅      ⋅      ⋅      ⋅
  ⋅      0.125   ⋅      ⋅      ⋅      ⋅      ⋅      ⋅      ⋅
  ⋅       ⋅     0.125   ⋅      ⋅      ⋅      ⋅      ⋅      ⋅
  ⋅       ⋅      ⋅     0.125   ⋅      ⋅      ⋅      ⋅      ⋅
  ⋅       ⋅      ⋅      ⋅     0.125   ⋅      ⋅      ⋅      ⋅
  ⋅       ⋅      ⋅      ⋅      ⋅     0.125   ⋅      ⋅      ⋅
  ⋅       ⋅      ⋅      ⋅      ⋅      ⋅     0.125   ⋅      ⋅
  ⋅       ⋅      ⋅      ⋅      ⋅      ⋅      ⋅     0.125   ⋅
  ⋅       ⋅      ⋅      ⋅      ⋅      ⋅      ⋅      ⋅     0.0625</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = grid(D)</code><code class="nohighlight hljs ansi" style="display:block;">0.0:0.125:1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = x.^2</code><code class="nohighlight hljs ansi" style="display:block;">9-element Vector{Float64}:
 0.0
 0.015625
 0.0625
 0.140625
 0.25
 0.390625
 0.5625
 0.765625
 1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; integrate(u, D)</code><code class="nohighlight hljs ansi" style="display:block;">0.3359375</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; integrate(u, D) ≈ sum(M * u)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; integrate(u, D) ≈ integrate(x -&gt; x^2, x, D)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>For example, you can proceed as follows to compute the error of the SBP operator when computing a derivative as follows.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SummationByPartsOperators</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = derivative_operator(MattssonNordström2004(),
                               derivative_order = 1, accuracy_order = 2,
                               xmin = 0.0, xmax = 1.0, N = 9)</code><code class="nohighlight hljs ansi" style="display:block;">SBP first-derivative operator of order 2 on a grid in [0.0, 1.0] using 9 nodes
and coefficients of Mattsson, Nordström (2004)
  Summation by parts operators for finite difference approximations of second
    derivatives.
  Journal of Computational Physics 199, pp. 503-540.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = mass_matrix(D)</code><code class="nohighlight hljs ansi" style="display:block;">9×9 LinearAlgebra.Diagonal{Float64, Vector{Float64}}:
 0.0625   ⋅      ⋅      ⋅      ⋅      ⋅      ⋅      ⋅      ⋅
  ⋅      0.125   ⋅      ⋅      ⋅      ⋅      ⋅      ⋅      ⋅
  ⋅       ⋅     0.125   ⋅      ⋅      ⋅      ⋅      ⋅      ⋅
  ⋅       ⋅      ⋅     0.125   ⋅      ⋅      ⋅      ⋅      ⋅
  ⋅       ⋅      ⋅      ⋅     0.125   ⋅      ⋅      ⋅      ⋅
  ⋅       ⋅      ⋅      ⋅      ⋅     0.125   ⋅      ⋅      ⋅
  ⋅       ⋅      ⋅      ⋅      ⋅      ⋅     0.125   ⋅      ⋅
  ⋅       ⋅      ⋅      ⋅      ⋅      ⋅      ⋅     0.125   ⋅
  ⋅       ⋅      ⋅      ⋅      ⋅      ⋅      ⋅      ⋅     0.0625</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = grid(D)</code><code class="nohighlight hljs ansi" style="display:block;">0.0:0.125:1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; difference = D * x.^3 - 3 * x.^2</code><code class="nohighlight hljs ansi" style="display:block;">9-element Vector{Float64}:
  0.015625
  0.015625
  0.015625
  0.015625
  0.015625
  0.015625
  0.015625
  0.015625
 -0.359375</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; error_l2 = sqrt(integrate(abs2, difference, D))</code><code class="nohighlight hljs ansi" style="display:block;">0.09110862335695782</code></pre><h2 id="Multi-dimensional-cases-or-multiple-variables"><a class="docs-heading-anchor" href="#Multi-dimensional-cases-or-multiple-variables">Multi-dimensional cases or multiple variables</a><a id="Multi-dimensional-cases-or-multiple-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-dimensional-cases-or-multiple-variables" title="Permalink"></a></h2><p>If you want to work with multiple space dimensions, you can still use the 1D operators provided by <a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a> if you apply them in a tensor product fashion along each space dimension.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SummationByPartsOperators</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = derivative_operator(MattssonNordström2004(),
                               derivative_order = 1, accuracy_order = 4,
                               xmin = 0.0, xmax = 1.0, N = 9)</code><code class="nohighlight hljs ansi" style="display:block;">SBP first-derivative operator of order 4 on a grid in [0.0, 1.0] using 9 nodes
and coefficients of Mattsson, Nordström (2004)
  Summation by parts operators for finite difference approximations of second
    derivatives.
  Journal of Computational Physics 199, pp. 503-540.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = y = grid(D)</code><code class="nohighlight hljs ansi" style="display:block;">0.0:0.125:1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = x .* y&#39;.^2 # u(x, y) = x y^2</code><code class="nohighlight hljs ansi" style="display:block;">9×9 Matrix{Float64}:
 0.0  0.0         0.0        0.0        …  0.0        0.0        0.0
 0.0  0.00195312  0.0078125  0.0175781     0.0703125  0.0957031  0.125
 0.0  0.00390625  0.015625   0.0351562     0.140625   0.191406   0.25
 0.0  0.00585938  0.0234375  0.0527344     0.210938   0.287109   0.375
 0.0  0.0078125   0.03125    0.0703125     0.28125    0.382812   0.5
 0.0  0.00976562  0.0390625  0.0878906  …  0.351562   0.478516   0.625
 0.0  0.0117188   0.046875   0.105469      0.421875   0.574219   0.75
 0.0  0.0136719   0.0546875  0.123047      0.492188   0.669922   0.875
 0.0  0.015625    0.0625     0.140625      0.5625     0.765625   1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; let du_dx = zero(u)
           for j in axes(u, 2)
               mul!(view(du_dx, :, j), D, view(u, :, j))
           end
           # The derivative of x*y^2 with respect to x is just y^2.
           # Thus, the result is constant in each column and varies
           # in the rows.
           du_dx
       end</code><code class="nohighlight hljs ansi" style="display:block;">9×9 Matrix{Float64}:
 0.0  0.015625  0.0625  0.140625  0.25  0.390625  0.5625  0.765625  1.0
 0.0  0.015625  0.0625  0.140625  0.25  0.390625  0.5625  0.765625  1.0
 0.0  0.015625  0.0625  0.140625  0.25  0.390625  0.5625  0.765625  1.0
 0.0  0.015625  0.0625  0.140625  0.25  0.390625  0.5625  0.765625  1.0
 0.0  0.015625  0.0625  0.140625  0.25  0.390625  0.5625  0.765625  1.0
 0.0  0.015625  0.0625  0.140625  0.25  0.390625  0.5625  0.765625  1.0
 0.0  0.015625  0.0625  0.140625  0.25  0.390625  0.5625  0.765625  1.0
 0.0  0.015625  0.0625  0.140625  0.25  0.390625  0.5625  0.765625  1.0
 0.0  0.015625  0.0625  0.140625  0.25  0.390625  0.5625  0.765625  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; let du_dy = zero(u)
           for i in axes(u, 1)
               mul!(view(du_dy, i, :), D, view(u, i, :))
           end
           # The derivative of x*y^2 with respect to y is 2*x*y.
           du_dy
       end</code><code class="nohighlight hljs ansi" style="display:block;">9×9 Matrix{Float64}:
  0.0          0.0      0.0     0.0      …  0.0      0.0     0.0      0.0
  2.1684e-19   0.03125  0.0625  0.09375     0.15625  0.1875  0.21875  0.25
  4.33681e-19  0.0625   0.125   0.1875      0.3125   0.375   0.4375   0.5
  4.11997e-18  0.09375  0.1875  0.28125     0.46875  0.5625  0.65625  0.75
  8.67362e-19  0.125    0.25    0.375       0.625    0.75    0.875    1.0
 -1.6263e-17   0.15625  0.3125  0.46875  …  0.78125  0.9375  1.09375  1.25
  8.23994e-18  0.1875   0.375   0.5625      0.9375   1.125   1.3125   1.5
  1.88651e-17  0.21875  0.4375  0.65625     1.09375  1.3125  1.53125  1.75
  1.73472e-18  0.25     0.5     0.75        1.25     1.5     1.75     2.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 2 .* x .* y&#39;</code><code class="nohighlight hljs ansi" style="display:block;">9×9 Matrix{Float64}:
 0.0  0.0      0.0     0.0      0.0    0.0      0.0     0.0      0.0
 0.0  0.03125  0.0625  0.09375  0.125  0.15625  0.1875  0.21875  0.25
 0.0  0.0625   0.125   0.1875   0.25   0.3125   0.375   0.4375   0.5
 0.0  0.09375  0.1875  0.28125  0.375  0.46875  0.5625  0.65625  0.75
 0.0  0.125    0.25    0.375    0.5    0.625    0.75    0.875    1.0
 0.0  0.15625  0.3125  0.46875  0.625  0.78125  0.9375  1.09375  1.25
 0.0  0.1875   0.375   0.5625   0.75   0.9375   1.125   1.3125   1.5
 0.0  0.21875  0.4375  0.65625  0.875  1.09375  1.3125  1.53125  1.75
 0.0  0.25     0.5     0.75     1.0    1.25     1.5     1.75     2.0</code></pre><p>Here, we have used <code>view</code>s to interpret parts of the memory of the multi-dimensional arrays as one-diemnsional vectors that can be used together with the operators of <a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a>. You can use the same trick if you collect values of multiple variables in a multi-dimensional array.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../introduction/">« Introduction</a><a class="docs-footer-nextpage" href="../constant_linear_advection/">Linear advection equation with constant coefficients »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 3 April 2024 06:53">Wednesday 3 April 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
