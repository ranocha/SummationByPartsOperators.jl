<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · SummationByPartsOperators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ranocha.github.io/SummationByPartsOperators.jl/stable/introduction/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SummationByPartsOperators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#Periodic-domains"><span>Periodic domains</span></a></li><li><a class="tocitem" href="#Non-periodic-domains"><span>Non-periodic domains</span></a></li><li><a class="tocitem" href="#intro-upwind-operators"><span>Upwind operators</span></a></li><li><a class="tocitem" href="#intro-CGSEM"><span>Continuous Galerkin methods</span></a></li><li><a class="tocitem" href="#intro-DGSEM"><span>Discontinuous Galerkin methods</span></a></li><li><a class="tocitem" href="#Basic-interfaces-and-additional-features"><span>Basic interfaces and additional features</span></a></li><li><a class="tocitem" href="#Next-steps"><span>Next steps</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/constant_linear_advection/">Linear advection equation with constant coefficients</a></li><li><a class="tocitem" href="../tutorials/advection_diffusion/">Linear advection diffusion equation with periodic boundary conditions</a></li><li><a class="tocitem" href="../tutorials/variable_linear_advection/">Linear advection equation with variable coefficients</a></li><li><a class="tocitem" href="../tutorials/wave_equation/">Wave equation</a></li><li><a class="tocitem" href="../tutorials/kdv/">Korteweg-de Vries equation</a></li></ul></li><li><a class="tocitem" href="../ad/">Automatic differentiation (AD)</a></li><li><a class="tocitem" href="../applications/">Applications &amp; references</a></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../api_reference/">API reference</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ranocha/SummationByPartsOperators.jl/blob/main/docs/src/introduction.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>Summation-by-parts (SBP) operators are discrete derivative operators designed to enable (semi-) discrete stability proofs mimicking the energy method from the continuous level. To do so, SBP operators mimic integration-by-parts discretely. Here, we will briefly explain the basic concepts. If you want to learn more about this subject, the classical review articles of <sup class="footnote-reference"><a id="citeref-SvärdNordström2014" href="#footnote-SvärdNordström2014">[SvärdNordström2014]</a></sup> and <sup class="footnote-reference"><a id="citeref-FernándezHickenZingg2014" href="#footnote-FernándezHickenZingg2014">[FernándezHickenZingg2014]</a></sup> are good starting points. More recent references and applications of SBP operators from many classes implemented in <a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a> are given by <sup class="footnote-reference"><a id="citeref-RanochaMitsotakisKetcheson2021" href="#footnote-RanochaMitsotakisKetcheson2021">[RanochaMitsotakisKetcheson2021]</a></sup>.</p><p>Since SBP operators are designed to mimic integration-by-parts, they need a notion of derivatives and integrals. Here, derivatives are interpreted as linear operators <code>D</code> (derivative matrices) and integrals are interpreted as discrete inner products, represented by the associated mass/norm matrices <code>M</code>. Thus, the discrete derivative of a grid function <code>u</code> is <code>D * u</code> and the discrete inner product of two grid functions <code>u</code> and <code>v</code> is <code>dot(u, M, v)</code>, where <code>M = mass_matrix(D)</code>. Here, we have already introduced some basic interfaces provided by <a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a>:</p><ul><li>Derivative operators act as linear operators implementing <code>*</code> (and <code>mul!</code> for more efficient in-place updates avoiding allocations).</li><li>The mass matrix associated to an SBP derivative operator can be retrieved via <a href="../api_reference/#SummationByPartsOperators.mass_matrix-Tuple{Union{DerivativeOperator, VarCoefDerivativeOperator}}"><code>mass_matrix</code></a>.</li></ul><h2 id="Periodic-domains"><a class="docs-heading-anchor" href="#Periodic-domains">Periodic domains</a><a id="Periodic-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-domains" title="Permalink"></a></h2><p>Periodic (central) SBP operators mimic the properties of differential operators on periodic domains. Hence, they are</p><ul><li>skew-symmetric if they approximate odd derivatives</li><li>symmetric and semi-definite if they approximate even derivatives; second-derivative operators are negative semi-definite, fourth-derivative operators are positive semi-definite etc.</li></ul><p>Classical central finite difference operators on periodic domains are periodic SBP operators. They can be constructed via <a href="../api_reference/#SummationByPartsOperators.periodic_derivative_operator"><code>periodic_derivative_operator</code></a>. Similarly, Fourier collocation methods can be interpreted as periodic SBP operators, which can be constructed via <a href="../api_reference/#SummationByPartsOperators.fourier_derivative_operator-Tuple{Real, Real, Integer}"><code>fourier_derivative_operator</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; using SummationByPartsOperators, LinearAlgebra

julia&gt; D = periodic_derivative_operator(derivative_order=1, accuracy_order=2,
                                        xmin=0.0, xmax=2.0, N=20)
Periodic first-derivative operator of order 2 on a grid in [0.0, 2.0] using 20 nodes,
stencils with 1 nodes to the left, 1 nodes to the right, and coefficients of Fornberg (1998)
  Calculation of Weights in Finite Difference Formulas.
  SIAM Rev. 40.3, pp. 685-691.

julia&gt; M = mass_matrix(D)
UniformScaling{Float64}
0.1*I

julia&gt; M * Matrix(D) + Matrix(D)&#39; * M |&gt; norm
0.0

julia&gt; D = fourier_derivative_operator(xmin=0.0, xmax=2.0, N=20)
Periodic 1st derivative Fourier operator {T=Float64}
on a grid in [0.0, 2.0] using 20 nodes and 11 modes

julia&gt; M = mass_matrix(D)
UniformScaling{Float64}
0.1*I

julia&gt; norm(M * Matrix(D) + Matrix(D)&#39; * M) &lt; 10 * eps(eltype(D))
true</code></pre><p>As you have seen above, conversion methods to other common types such as <code>Matrix</code>, <code>sparse</code> from the standard library SparseArrays, and <code>BandedMatrix</code> from <a href="https://github.com/JuliaMatrices/BandedMatrices.jl">BandedMatrices.jl</a> are available.</p><h2 id="Non-periodic-domains"><a class="docs-heading-anchor" href="#Non-periodic-domains">Non-periodic domains</a><a id="Non-periodic-domains-1"></a><a class="docs-heading-anchor-permalink" href="#Non-periodic-domains" title="Permalink"></a></h2><p>On non-periodic domains, additional boundary terms appear. Thus, the basic symmetry properties of SBP operators are the same as the ones of periodic SBP operators modulo boundary terms. Note that the correct handling of boundary terms is the basic reason of the success of SBP operators. In particular for hyperbolic problems, other boundary treatments that might appear senseful can result in catastrophic failure.</p><h3 id="First-derivative-operators"><a class="docs-heading-anchor" href="#First-derivative-operators">First-derivative operators</a><a id="First-derivative-operators-1"></a><a class="docs-heading-anchor-permalink" href="#First-derivative-operators" title="Permalink"></a></h3><p>First-derivative SBP operators need to mimic</p><p class="math-container">\[  \int_{x_\mathrm{min}}^{x_\mathrm{max}} u(x) \bigl( \partial_x v(x) \bigr) \mathrm{d}x
+ \int_{x_\mathrm{min}}^{x_\mathrm{max}} \bigl( \partial_x u(x) \bigr) v(x) \mathrm{d}x
= u(x_\mathrm{max}) v(x_\mathrm{max}) - u(x_\mathrm{min}) v(x_\mathrm{min}).\]</p><p>Thus, a discrete evaluation at the boundary of the domain is necessary. For SBP operators with a grid including the boundary nodes, this can be achieved by simply picking the first/last nodal coefficient of a grid function <code>u</code>. If boundary nodes are not included, some interpolation is necessary in general. Nevertheless, getting a boundary value is a linear functional that is often represented in the literature using (transposed) vectors <code>tL, tR</code>. Then, an SBP operator has to satisfy <code>M * D + D&#39; * M == tR * tR&#39; - tL * tL&#39;</code>. The boundary operators are represented matrix-free via <a href="../api_reference/#SummationByPartsOperators.derivative_left-Tuple{SummationByPartsOperators.AbstractNonperiodicDerivativeOperator, Any}"><code>derivative_left</code></a> and <a href="../api_reference/#SummationByPartsOperators.derivative_right-Tuple{SummationByPartsOperators.AbstractNonperiodicDerivativeOperator, Any}"><code>derivative_right</code></a> for zeroth-order derivatives.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SummationByPartsOperators, LinearAlgebra</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = derivative_operator(MattssonNordström2004(), derivative_order=1, accuracy_order=2,
                               xmin=0//1, xmax=1//1, N=9)</code><code class="nohighlight hljs ansi" style="display:block;">SBP first-derivative operator of order 2 on a grid in [0//1, 1//1] using 9 nodes
and coefficients of Mattsson, Nordström (2004)
  Summation by parts operators for finite difference approximations of second
    derivatives.
  Journal of Computational Physics 199, pp. 503-540.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tL = zeros(eltype(D), size(D, 1)); tL[1] = 1; tL&#39;</code><code class="nohighlight hljs ansi" style="display:block;">1×9 adjoint(::Vector{Rational{Int64}}) with eltype Rational{Int64}:
 1//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tR = zeros(eltype(D), size(D, 1)); tR[end] = 1; tR&#39;</code><code class="nohighlight hljs ansi" style="display:block;">1×9 adjoint(::Vector{Rational{Int64}}) with eltype Rational{Int64}:
 0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  1//1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = mass_matrix(D)</code><code class="nohighlight hljs ansi" style="display:block;">9×9 LinearAlgebra.Diagonal{Rational{Int64}, Vector{Rational{Int64}}}:
 1//16   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅
  ⋅     1//8   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅
  ⋅      ⋅    1//8   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅
  ⋅      ⋅     ⋅    1//8   ⋅     ⋅     ⋅     ⋅     ⋅
  ⋅      ⋅     ⋅     ⋅    1//8   ⋅     ⋅     ⋅     ⋅
  ⋅      ⋅     ⋅     ⋅     ⋅    1//8   ⋅     ⋅     ⋅
  ⋅      ⋅     ⋅     ⋅     ⋅     ⋅    1//8   ⋅     ⋅
  ⋅      ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    1//8   ⋅
  ⋅      ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    1//16</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M * Matrix(D) + Matrix(D)&#39; * M == tR * tR&#39; - tL * tL&#39;</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = randn(size(grid(D))); derivative_left(D, u, Val(0)) == u[begin]</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = randn(size(grid(D))); derivative_right(D, u, Val(0)) == u[end]</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Here, we have introduced some additional features. Firstly, exact rational coefficients are provided, based on the type of <code>xmin</code> and <code>xmax</code> (if available). Secondly, a <a href="../api_reference/#SummationByPartsOperators.source_of_coefficients-Tuple{Any}"><code>source_of_coefficients</code></a> has to be provided when constructing the SBP operator. You can list them using</p><pre><code class="language-julia hljs">using InteractiveUtils, SummationByPartsOperators
subtypes(SourceOfCoefficients)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">19-element Vector{Any}:
 BeljaddLeFlochMishraParés2017
 DienerDorbandSchnetterTiglio2007
 Fornberg1998
 Holoborodko2008
 MadayTadmor1989
 Mattsson2012
 Mattsson2014
 Mattsson2017
 MattssonAlmquistCarpenter2014Extended
 MattssonAlmquistCarpenter2014Optimal
 MattssonAlmquistVanDerWeide2018Accurate
 MattssonAlmquistVanDerWeide2018Minimal
 MattssonNordström2004
 MattssonSvärdNordström2004
 MattssonSvärdShoeybi2008
 Tadmor1989
 Tadmor1993
 TadmorWaagan2012Convergent
 TadmorWaagan2012Standard</code></pre><p>Here and in the following, the order of accuracy of (finite difference) SBP operators refers to the local order of accuracy in the interior, cf. <a href="../api_reference/#SummationByPartsOperators.accuracy_order"><code>accuracy_order</code></a>.</p><p>A special case of first-derivative SBP operators are polynomial derivative operators on Lobatto-Legendre nodes, implemented in <a href="../api_reference/#SummationByPartsOperators.legendre_derivative_operator-Tuple{Real, Real, Integer}"><code>legendre_derivative_operator</code></a>.</p><h3 id="Second-derivative-operators"><a class="docs-heading-anchor" href="#Second-derivative-operators">Second-derivative operators</a><a id="Second-derivative-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Second-derivative-operators" title="Permalink"></a></h3><p>To mimic integration-by-parts of second derivatives,</p><p class="math-container">\[  \int_{x_\mathrm{min}}^{x_\mathrm{max}} u(x) \bigl( \partial_x^2 v(x) \bigr) \mathrm{d}x
= - \int_{x_\mathrm{min}}^{x_\mathrm{max}} \bigl( \partial_x u(x) \bigr) \bigl( \partial_x v(x) \bigr) \mathrm{d}x
  + u(x_\mathrm{max}) \bigl( \partial_x v(x_\mathrm{max}) \bigr)
  - \bigl( \partial_x u(x_\mathrm{min})) v(x_\mathrm{min}),\]</p><p>the evaluation of the first derivative at the boundaries is necessary. These linear functionals are available as <a href="../api_reference/#SummationByPartsOperators.derivative_left-Tuple{SummationByPartsOperators.AbstractNonperiodicDerivativeOperator, Any}"><code>derivative_left</code></a> and <a href="../api_reference/#SummationByPartsOperators.derivative_right-Tuple{SummationByPartsOperators.AbstractNonperiodicDerivativeOperator, Any}"><code>derivative_right</code></a>. In the literature, they are often called <code>dL</code> and <code>dR</code>. Then, a second-derivative SBP operator has to be of the form <code>M * D == -A + tR * dR&#39; - tL * dL&#39;</code>, where <code>A</code> is symmetric and positive semidefinite.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SummationByPartsOperators, LinearAlgebra</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = derivative_operator(MattssonNordström2004(), derivative_order=2, accuracy_order=2,
                               xmin=0//1, xmax=1//1, N=9)</code><code class="nohighlight hljs ansi" style="display:block;">SBP second-derivative operator of order 2 on a grid in [0//1, 1//1] using 9 nodes
and coefficients of Mattsson, Nordström (2004)
  Summation by parts operators for finite difference approximations of second
    derivatives.
  Journal of Computational Physics 199, pp. 503-540.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = mass_matrix(D)</code><code class="nohighlight hljs ansi" style="display:block;">9×9 LinearAlgebra.Diagonal{Rational{Int64}, Vector{Rational{Int64}}}:
 1//16   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅
  ⋅     1//8   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅
  ⋅      ⋅    1//8   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅
  ⋅      ⋅     ⋅    1//8   ⋅     ⋅     ⋅     ⋅     ⋅
  ⋅      ⋅     ⋅     ⋅    1//8   ⋅     ⋅     ⋅     ⋅
  ⋅      ⋅     ⋅     ⋅     ⋅    1//8   ⋅     ⋅     ⋅
  ⋅      ⋅     ⋅     ⋅     ⋅     ⋅    1//8   ⋅     ⋅
  ⋅      ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    1//8   ⋅
  ⋅      ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    1//16</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tL = derivative_left(D, Val(0)); tL&#39;</code><code class="nohighlight hljs ansi" style="display:block;">1×9 adjoint(::Vector{Bool}) with eltype Bool:
 1  0  0  0  0  0  0  0  0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tR = derivative_right(D, Val(0)); tR&#39;</code><code class="nohighlight hljs ansi" style="display:block;">1×9 adjoint(::Vector{Bool}) with eltype Bool:
 0  0  0  0  0  0  0  0  1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dL = derivative_left(D, Val(1)); dL&#39;</code><code class="nohighlight hljs ansi" style="display:block;">1×9 adjoint(::Vector{Rational{Int64}}) with eltype Rational{Int64}:
 -12//1  16//1  -4//1  0//1  0//1  0//1  0//1  0//1  0//1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dR = derivative_right(D, Val(1)); dR&#39;</code><code class="nohighlight hljs ansi" style="display:block;">1×9 adjoint(::Vector{Rational{Int64}}) with eltype Rational{Int64}:
 0//1  0//1  0//1  0//1  0//1  0//1  4//1  -16//1  12//1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = -M * Matrix(D) + tR * dR&#39; - tL * dL&#39;</code><code class="nohighlight hljs ansi" style="display:block;">9×9 Matrix{Rational{Int64}}:
  8//1  -8//1   0//1   0//1   0//1   0//1   0//1   0//1   0//1
 -8//1  16//1  -8//1   0//1   0//1   0//1   0//1   0//1   0//1
  0//1  -8//1  16//1  -8//1   0//1   0//1   0//1   0//1   0//1
  0//1   0//1  -8//1  16//1  -8//1   0//1   0//1   0//1   0//1
  0//1   0//1   0//1  -8//1  16//1  -8//1   0//1   0//1   0//1
  0//1   0//1   0//1   0//1  -8//1  16//1  -8//1   0//1   0//1
  0//1   0//1   0//1   0//1   0//1  -8//1  16//1  -8//1   0//1
  0//1   0//1   0//1   0//1   0//1   0//1  -8//1  16//1  -8//1
  0//1   0//1   0//1   0//1   0//1   0//1   0//1  -8//1   8//1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isposdef(A)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Usually, there is no need to form <code>dL, dR</code> explicitly. Instead, you can use the matrix-free variants <a href="../api_reference/#SummationByPartsOperators.derivative_left-Tuple{SummationByPartsOperators.AbstractNonperiodicDerivativeOperator, Any}"><code>derivative_left</code></a> and <a href="../api_reference/#SummationByPartsOperators.derivative_right-Tuple{SummationByPartsOperators.AbstractNonperiodicDerivativeOperator, Any}"><code>derivative_right</code></a>. Some procedures imposing boundary conditions weakly require adding the transposed boundary derivatives to a grid function, which can be achieved by <a href="../api_reference/#SummationByPartsOperators.mul_transpose_derivative_left!-Union{Tuple{N}, Tuple{AbstractVector{T} where T, DerivativeOperator, Val{N}}, Tuple{AbstractVector{T} where T, DerivativeOperator, Val{N}, Any}, Tuple{AbstractVector{T} where T, DerivativeOperator, Val{N}, Any, Any}} where N"><code>mul_transpose_derivative_left!</code></a> and <a href="../api_reference/#SummationByPartsOperators.mul_transpose_derivative_right!-Union{Tuple{N}, Tuple{AbstractVector{T} where T, DerivativeOperator, Val{N}}, Tuple{AbstractVector{T} where T, DerivativeOperator, Val{N}, Any}, Tuple{AbstractVector{T} where T, DerivativeOperator, Val{N}, Any, Any}} where N"><code>mul_transpose_derivative_right!</code></a>. You can find applications of these operators in the source code of <a href="../api_reference/#SummationByPartsOperators.WaveEquationNonperiodicSemidiscretization"><code>WaveEquationNonperiodicSemidiscretization</code></a>.</p><p>A special case of second-derivative SBP operators are polynomial derivative operators on Lobatto-Legendre nodes, implemented in <a href="../api_reference/#SummationByPartsOperators.legendre_second_derivative_operator-Tuple{Real, Real, Integer}"><code>legendre_second_derivative_operator</code></a>.</p><h2 id="intro-upwind-operators"><a class="docs-heading-anchor" href="#intro-upwind-operators">Upwind operators</a><a id="intro-upwind-operators-1"></a><a class="docs-heading-anchor-permalink" href="#intro-upwind-operators" title="Permalink"></a></h2><p>Upwind SBP operators were introduced by <a href="../api_reference/#SummationByPartsOperators.Mattsson2017"><code>Mattsson2017</code></a>. They combine two derivative operators <code>Dp</code> (<code>:plus</code>) and <code>Dm</code> (<code>:minus</code>) such that <code>M * Dp + Dm&#39; * M == tR * tR&#39; - tL * tL&#39;</code> and <code>M * (Dp - Dm)</code> is negative semidefinite.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SummationByPartsOperators, LinearAlgebra</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Dp = derivative_operator(Mattsson2017(:plus), derivative_order=1, accuracy_order=2,
                                xmin=0//1, xmax=1//1, N=9)</code><code class="nohighlight hljs ansi" style="display:block;">SBP first-derivative operator of order 2 on a grid in [0//1, 1//1] using 9 nodes
and coefficients of Mattsson (2017)
  Diagonal-norm upwind SBP operators.
  Journal of Computational Physics 335, pp. 283-310.
  (upwind coefficients plus)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Matrix(Dp)</code><code class="nohighlight hljs ansi" style="display:block;">9×9 Matrix{Rational{Int64}}:
 -24//1  40//1  -16//1    0//1    0//1    0//1    0//1   0//1   0//1
  -8//5  -8//1   64//5  -16//5    0//1    0//1    0//1   0//1   0//1
   0//1   0//1  -12//1   16//1   -4//1    0//1    0//1   0//1   0//1
   0//1   0//1    0//1  -12//1   16//1   -4//1    0//1   0//1   0//1
   0//1   0//1    0//1    0//1  -12//1   16//1   -4//1   0//1   0//1
   0//1   0//1    0//1    0//1    0//1  -12//1   16//1  -4//1   0//1
   0//1   0//1    0//1    0//1    0//1    0//1  -12//1  16//1  -4//1
   0//1   0//1    0//1    0//1    0//1    0//1    0//1  -8//1   8//1
   0//1   0//1    0//1    0//1    0//1    0//1    0//1  -8//1   8//1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Dm = derivative_operator(Mattsson2017(:minus), derivative_order=1, accuracy_order=2,
                                xmin=0//1, xmax=1//1, N=9)</code><code class="nohighlight hljs ansi" style="display:block;">SBP first-derivative operator of order 2 on a grid in [0//1, 1//1] using 9 nodes
and coefficients of Mattsson (2017)
  Diagonal-norm upwind SBP operators.
  Journal of Computational Physics 335, pp. 283-310.
  (upwind coefficients minus)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Matrix(Dm)</code><code class="nohighlight hljs ansi" style="display:block;">9×9 Matrix{Rational{Int64}}:
 -8//1    8//1    0//1    0//1    0//1    0//1    0//1    0//1   0//1
 -8//1    8//1    0//1    0//1    0//1    0//1    0//1    0//1   0//1
  4//1  -16//1   12//1    0//1    0//1    0//1    0//1    0//1   0//1
  0//1    4//1  -16//1   12//1    0//1    0//1    0//1    0//1   0//1
  0//1    0//1    4//1  -16//1   12//1    0//1    0//1    0//1   0//1
  0//1    0//1    0//1    4//1  -16//1   12//1    0//1    0//1   0//1
  0//1    0//1    0//1    0//1    4//1  -16//1   12//1    0//1   0//1
  0//1    0//1    0//1    0//1    0//1   16//5  -64//5    8//1   8//5
  0//1    0//1    0//1    0//1    0//1    0//1   16//1  -40//1  24//1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = mass_matrix(Dp)</code><code class="nohighlight hljs ansi" style="display:block;">9×9 LinearAlgebra.Diagonal{Rational{Int64}, Vector{Rational{Int64}}}:
 1//32   ⋅      ⋅     ⋅     ⋅     ⋅     ⋅     ⋅      ⋅
  ⋅     5//32   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅      ⋅
  ⋅      ⋅     1//8   ⋅     ⋅     ⋅     ⋅     ⋅      ⋅
  ⋅      ⋅      ⋅    1//8   ⋅     ⋅     ⋅     ⋅      ⋅
  ⋅      ⋅      ⋅     ⋅    1//8   ⋅     ⋅     ⋅      ⋅
  ⋅      ⋅      ⋅     ⋅     ⋅    1//8   ⋅     ⋅      ⋅
  ⋅      ⋅      ⋅     ⋅     ⋅     ⋅    1//8   ⋅      ⋅
  ⋅      ⋅      ⋅     ⋅     ⋅     ⋅     ⋅    5//32   ⋅
  ⋅      ⋅      ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     1//32</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M * Matrix(Dp) + Matrix(Dm)&#39; * M</code><code class="nohighlight hljs ansi" style="display:block;">9×9 Matrix{Rational{Int64}}:
 -1//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1
  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1
  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1
  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1
  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1
  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1
  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1
  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1
  0//1  0//1  0//1  0//1  0//1  0//1  0//1  0//1  1//1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; minimum(eigvals(-M * (Matrix(Dp) - Matrix(Dm)))) # &gt; 0 up to floating point tolerances</code><code class="nohighlight hljs ansi" style="display:block;">-6.892084304488098e-16</code></pre><p>You can also set up fully periodic upwind operators by setting the argument <code>left_offset</code> of <a href="../api_reference/#SummationByPartsOperators.periodic_derivative_operator"><code>periodic_derivative_operator</code></a> appropriately. For example,</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SummationByPartsOperators, LinearAlgebra</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Dp = periodic_derivative_operator(derivative_order=1, accuracy_order=2, left_offset=0,
                                         xmin=0//1, xmax=1//1, N=8)</code><code class="nohighlight hljs ansi" style="display:block;">Periodic first-derivative operator of order 2 on a grid in [0//1, 1//1] using 8 nodes,
stencils with 0 nodes to the left, 2 nodes to the right, and coefficients of Fornberg (1998)
  Calculation of Weights in Finite Difference Formulas.
  SIAM Rev. 40.3, pp. 685-691.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Matrix(Dp)</code><code class="nohighlight hljs ansi" style="display:block;">8×8 Matrix{Rational{Int64}}:
 -12//1   16//1   -4//1    0//1    0//1    0//1    0//1    0//1
   0//1  -12//1   16//1   -4//1    0//1    0//1    0//1    0//1
   0//1    0//1  -12//1   16//1   -4//1    0//1    0//1    0//1
   0//1    0//1    0//1  -12//1   16//1   -4//1    0//1    0//1
   0//1    0//1    0//1    0//1  -12//1   16//1   -4//1    0//1
   0//1    0//1    0//1    0//1    0//1  -12//1   16//1   -4//1
  -4//1    0//1    0//1    0//1    0//1    0//1  -12//1   16//1
  16//1   -4//1    0//1    0//1    0//1    0//1    0//1  -12//1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Dm = periodic_derivative_operator(derivative_order=1, accuracy_order=2, left_offset=-2,
                                         xmin=0//1, xmax=1//1, N=8)</code><code class="nohighlight hljs ansi" style="display:block;">Periodic first-derivative operator of order 2 on a grid in [0//1, 1//1] using 8 nodes,
stencils with 2 nodes to the left, 0 nodes to the right, and coefficients of Fornberg (1998)
  Calculation of Weights in Finite Difference Formulas.
  SIAM Rev. 40.3, pp. 685-691.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Matrix(Dm)</code><code class="nohighlight hljs ansi" style="display:block;">8×8 Matrix{Rational{Int64}}:
  12//1    0//1    0//1    0//1    0//1    0//1    4//1  -16//1
 -16//1   12//1    0//1    0//1    0//1    0//1    0//1    4//1
   4//1  -16//1   12//1    0//1    0//1    0//1    0//1    0//1
   0//1    4//1  -16//1   12//1    0//1    0//1    0//1    0//1
   0//1    0//1    4//1  -16//1   12//1    0//1    0//1    0//1
   0//1    0//1    0//1    4//1  -16//1   12//1    0//1    0//1
   0//1    0//1    0//1    0//1    4//1  -16//1   12//1    0//1
   0//1    0//1    0//1    0//1    0//1    4//1  -16//1   12//1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = mass_matrix(Dp)</code><code class="nohighlight hljs ansi" style="display:block;">LinearAlgebra.UniformScaling{Rational{Int64}}
1//8*I</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M * Matrix(Dp) + Matrix(Dm)&#39; * M |&gt; iszero</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; minimum(eigvals(-M * (Matrix(Dp) - Matrix(Dm)))) # &gt; 0 up to floating point tolerances</code><code class="nohighlight hljs ansi" style="display:block;">2.1439294572106007e-16</code></pre><p>Note that we used <code>N=8</code> here, i.e., one node less than for the non-periodic example. This is necessary since the additional node at the right boundary is identified with the left boundary node for periodic operators.</p><p>To create all upwind operators for a single setup, you can use <a href="../api_reference/#SummationByPartsOperators.upwind_operators-Tuple{Any, Vararg{Any, N} where N}"><code>upwind_operators</code></a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SummationByPartsOperators</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = upwind_operators(Mattsson2017, derivative_order=1, accuracy_order=2,
                            xmin=0, xmax=1//1, N=9)</code><code class="nohighlight hljs ansi" style="display:block;">Upwind SBP first-derivative operators of order 2 on a grid in [0//1, 1//1] using 9 nodes
and coefficients of Mattsson2017</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Matrix(D.plus)</code><code class="nohighlight hljs ansi" style="display:block;">9×9 Matrix{Rational{Int64}}:
 -24//1  40//1  -16//1    0//1    0//1    0//1    0//1   0//1   0//1
  -8//5  -8//1   64//5  -16//5    0//1    0//1    0//1   0//1   0//1
   0//1   0//1  -12//1   16//1   -4//1    0//1    0//1   0//1   0//1
   0//1   0//1    0//1  -12//1   16//1   -4//1    0//1   0//1   0//1
   0//1   0//1    0//1    0//1  -12//1   16//1   -4//1   0//1   0//1
   0//1   0//1    0//1    0//1    0//1  -12//1   16//1  -4//1   0//1
   0//1   0//1    0//1    0//1    0//1    0//1  -12//1  16//1  -4//1
   0//1   0//1    0//1    0//1    0//1    0//1    0//1  -8//1   8//1
   0//1   0//1    0//1    0//1    0//1    0//1    0//1  -8//1   8//1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Matrix(D.minus)</code><code class="nohighlight hljs ansi" style="display:block;">9×9 Matrix{Rational{Int64}}:
 -8//1    8//1    0//1    0//1    0//1    0//1    0//1    0//1   0//1
 -8//1    8//1    0//1    0//1    0//1    0//1    0//1    0//1   0//1
  4//1  -16//1   12//1    0//1    0//1    0//1    0//1    0//1   0//1
  0//1    4//1  -16//1   12//1    0//1    0//1    0//1    0//1   0//1
  0//1    0//1    4//1  -16//1   12//1    0//1    0//1    0//1   0//1
  0//1    0//1    0//1    4//1  -16//1   12//1    0//1    0//1   0//1
  0//1    0//1    0//1    0//1    4//1  -16//1   12//1    0//1   0//1
  0//1    0//1    0//1    0//1    0//1   16//5  -64//5    8//1   8//5
  0//1    0//1    0//1    0//1    0//1    0//1   16//1  -40//1  24//1</code></pre><p>You can also couple upwind operators continuously across elements using <a href="../api_reference/#SummationByPartsOperators.couple_continuously"><code>couple_continuously</code></a> to obtain global upwind operators, see <a href="#intro-CGSEM">below</a> and Theorem 2.4 of <sup class="footnote-reference"><a id="citeref-RanochaMitsotakisKetcheson2021" href="#footnote-RanochaMitsotakisKetcheson2021">[RanochaMitsotakisKetcheson2021]</a></sup>.</p><p>Similarly, you can couple classical and upwind operators discontinuously across elements using <a href="../api_reference/#SummationByPartsOperators.couple_discontinuously"><code>couple_discontinuously</code></a> to obtain global upwind operators, see <a href="#intro-DGSEM">below</a> and Theorem 2.2 of <sup class="footnote-reference"><a id="citeref-RanochaMitsotakisKetcheson2021" href="#footnote-RanochaMitsotakisKetcheson2021">[RanochaMitsotakisKetcheson2021]</a></sup>.</p><h2 id="intro-CGSEM"><a class="docs-heading-anchor" href="#intro-CGSEM">Continuous Galerkin methods</a><a id="intro-CGSEM-1"></a><a class="docs-heading-anchor-permalink" href="#intro-CGSEM" title="Permalink"></a></h2><p>SBP operators can be coupled to obtain (nodal) continuous Galerkin (CG) methods. If the underlying SBP operators are <a href="../api_reference/#SummationByPartsOperators.LegendreDerivativeOperator"><code>LegendreDerivativeOperator</code></a>s, these are CG spectral element methods (CGSEM). However, a continuous coupling of arbitrary SBP operators is supported.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SummationByPartsOperators, LinearAlgebra</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = couple_continuously(
               legendre_derivative_operator(xmin=-1.0, xmax=1.0, N=3),
               UniformMesh1D(xmin=0.0, xmax=1.0, Nx=3))</code><code class="nohighlight hljs ansi" style="display:block;">First derivative operator {T=Float64} on 3 Lobatto Legendre nodes in [-1.0, 1.0]
coupled continuously on UniformMesh1D{Float64} with 3 cells in (0.0, 1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Matrix(D)</code><code class="nohighlight hljs ansi" style="display:block;">7×7 Matrix{Float64}:
 -9.0  12.0  -3.0   0.0   0.0    0.0   0.0
 -3.0   0.0   3.0   0.0   0.0    0.0   0.0
  1.5  -6.0   0.0   6.0  -1.5    0.0   0.0
  0.0   0.0  -3.0   0.0   3.0    0.0   0.0
  0.0   0.0   1.5  -6.0   0.0    6.0  -1.5
  0.0   0.0   0.0   0.0  -3.0    0.0   3.0
  0.0   0.0   0.0   0.0   3.0  -12.0   9.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mass_matrix(D)</code><code class="nohighlight hljs ansi" style="display:block;">7×7 LinearAlgebra.Diagonal{Float64, Vector{Float64}}:
 0.0555556   ⋅         ⋅         ⋅         ⋅         ⋅         ⋅
  ⋅         0.222222   ⋅         ⋅         ⋅         ⋅         ⋅
  ⋅          ⋅        0.111111   ⋅         ⋅         ⋅         ⋅
  ⋅          ⋅         ⋅        0.222222   ⋅         ⋅         ⋅
  ⋅          ⋅         ⋅         ⋅        0.111111   ⋅         ⋅
  ⋅          ⋅         ⋅         ⋅         ⋅        0.222222   ⋅
  ⋅          ⋅         ⋅         ⋅         ⋅         ⋅        0.0555556</code></pre><h2 id="intro-DGSEM"><a class="docs-heading-anchor" href="#intro-DGSEM">Discontinuous Galerkin methods</a><a id="intro-DGSEM-1"></a><a class="docs-heading-anchor-permalink" href="#intro-DGSEM" title="Permalink"></a></h2><p>SBP operators can also be coupled as in discontinuous Galerkin (DG) methods. Using a central numerical flux results in central SBP operators; upwind fluxes yield upwind SBP operators. If <a href="../api_reference/#SummationByPartsOperators.LegendreDerivativeOperator"><code>LegendreDerivativeOperator</code></a>s are used, the discontinuous coupling yields DG spectral element methods (DGSEM).</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SummationByPartsOperators, LinearAlgebra</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = couple_discontinuously(
               legendre_derivative_operator(xmin=-1.0, xmax=1.0, N=3),
               UniformPeriodicMesh1D(xmin=0.0, xmax=1.0, Nx=3),
               Val(:central))</code><code class="nohighlight hljs ansi" style="display:block;">First derivative operator {T=Float64} on 3 Lobatto Legendre nodes in [-1.0, 1.0]
coupled discontinuously (upwind: Val{:central}()) on UniformPeriodicMesh1D{Float64} with 3 cells in (0.0, 1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = mass_matrix(D);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M * Matrix(D) + Matrix(D)&#39; * M |&gt; iszero</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Right now, only uniform meshes <a href="../api_reference/#SummationByPartsOperators.UniformMesh1D"><code>UniformMesh1D</code></a> and <a href="../api_reference/#SummationByPartsOperators.UniformPeriodicMesh1D"><code>UniformPeriodicMesh1D</code></a> are implemented.</p><p>You can also specify a different coupling than <code>Val(:central)</code> to obtain <a href="#intro-upwind-operators">upwind operators</a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SummationByPartsOperators, LinearAlgebra</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Dp = couple_discontinuously(
               legendre_derivative_operator(xmin=-1.0, xmax=1.0, N=3),
               UniformPeriodicMesh1D(xmin=0.0, xmax=1.0, Nx=3),
               Val(:plus))</code><code class="nohighlight hljs ansi" style="display:block;">First derivative operator {T=Float64} on 3 Lobatto Legendre nodes in [-1.0, 1.0]
coupled discontinuously (upwind: Val{:plus}()) on UniformPeriodicMesh1D{Float64} with 3 cells in (0.0, 1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Matrix(Dp)</code><code class="nohighlight hljs ansi" style="display:block;">9×9 Matrix{Float64}:
 -9.0   12.0  -3.0   0.0    0.0   0.0   0.0    0.0   0.0
 -3.0    0.0   3.0   0.0    0.0   0.0   0.0    0.0   0.0
  3.0  -12.0  -9.0  18.0    0.0   0.0   0.0    0.0   0.0
  0.0    0.0   0.0  -9.0   12.0  -3.0   0.0    0.0   0.0
  0.0    0.0   0.0  -3.0    0.0   3.0   0.0    0.0   0.0
  0.0    0.0   0.0   3.0  -12.0  -9.0  18.0    0.0   0.0
  0.0    0.0   0.0   0.0    0.0   0.0  -9.0   12.0  -3.0
  0.0    0.0   0.0   0.0    0.0   0.0  -3.0    0.0   3.0
 18.0    0.0   0.0   0.0    0.0   0.0   3.0  -12.0  -9.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Dm = couple_discontinuously(
               legendre_derivative_operator(xmin=-1.0, xmax=1.0, N=3),
               UniformPeriodicMesh1D(xmin=0.0, xmax=1.0, Nx=3),
               Val(:minus))</code><code class="nohighlight hljs ansi" style="display:block;">First derivative operator {T=Float64} on 3 Lobatto Legendre nodes in [-1.0, 1.0]
coupled discontinuously (upwind: Val{:minus}()) on UniformPeriodicMesh1D{Float64} with 3 cells in (0.0, 1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Matrix(Dm)</code><code class="nohighlight hljs ansi" style="display:block;">9×9 Matrix{Float64}:
  9.0   12.0   -3.0   0.0    0.0    0.0   0.0    0.0  -18.0
 -3.0    0.0    3.0   0.0    0.0    0.0   0.0    0.0    0.0
  3.0  -12.0    9.0   0.0    0.0    0.0   0.0    0.0    0.0
  0.0    0.0  -18.0   9.0   12.0   -3.0   0.0    0.0    0.0
  0.0    0.0    0.0  -3.0    0.0    3.0   0.0    0.0    0.0
  0.0    0.0    0.0   3.0  -12.0    9.0   0.0    0.0    0.0
  0.0    0.0    0.0   0.0    0.0  -18.0   9.0   12.0   -3.0
  0.0    0.0    0.0   0.0    0.0    0.0  -3.0    0.0    3.0
  0.0    0.0    0.0   0.0    0.0    0.0   3.0  -12.0    9.0</code></pre><h2 id="Basic-interfaces-and-additional-features"><a class="docs-heading-anchor" href="#Basic-interfaces-and-additional-features">Basic interfaces and additional features</a><a id="Basic-interfaces-and-additional-features-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-interfaces-and-additional-features" title="Permalink"></a></h2><p>To actually compute and plot the discrete grid functions, a few additional ingredients are necessary.</p><ul><li>The discrete coefficients of a function on the <a href="../api_reference/#SummationByPartsOperators.grid"><code>grid</code></a> of an SBP operator can usually be computed as <code>x = grid(D); u = u_function.(x)</code>, at least for nodal bases. In general, <a href="../api_reference/#PolynomialBases.compute_coefficients-Tuple{Any, SummationByPartsOperators.AbstractDerivativeOperator}"><code>compute_coefficients</code></a> (or the in-place version <a href="../api_reference/#PolynomialBases.compute_coefficients!-Tuple{Any, Any, SummationByPartsOperators.AbstractDerivativeOperator}"><code>compute_coefficients!</code></a>) can also be used for this task.</li><li>To get a grid and discrete values suitable for plotting, you can use <a href="../api_reference/#PolynomialBases.evaluate_coefficients-Tuple{Any, SummationByPartsOperators.AbstractDerivativeOperator}"><code>evaluate_coefficients</code></a> (or the in-place version <a href="../api_reference/#PolynomialBases.evaluate_coefficients!-Tuple{Any, Any, Any, SummationByPartsOperators.AbstractDerivativeOperator}"><code>evaluate_coefficients!</code></a>). The plot nodes returned from <a href="../api_reference/#PolynomialBases.evaluate_coefficients-Tuple{Any, SummationByPartsOperators.AbstractDerivativeOperator}"><code>evaluate_coefficients</code></a> can be different from the nodes of the <a href="../api_reference/#SummationByPartsOperators.grid"><code>grid</code></a> associated to an SBP operator.</li><li>To implement boundary procedures, the weights of the mass matrix at the boundary are often needed. These can be obtained without forming <code>M = mass_matrix(D)</code> explicitly via <a href="../api_reference/#SummationByPartsOperators.left_boundary_weight"><code>left_boundary_weight</code></a> and <a href="../api_reference/#SummationByPartsOperators.right_boundary_weight"><code>right_boundary_weight</code></a>.</li><li>Instead of forming a mass matrix explicitly, discrete integrals can be evaluated efficiently using <a href="../api_reference/#PolynomialBases.integrate-Tuple{Any, AbstractVector{T} where T, DerivativeOperator}"><code>integrate</code></a>.</li><li>Dissipation operators based on the same discrete inner product as SBP derivative operators can be obtained via <a href="../api_reference/#SummationByPartsOperators.dissipation_operator"><code>dissipation_operator</code></a>.</li></ul><h2 id="Next-steps"><a class="docs-heading-anchor" href="#Next-steps">Next steps</a><a id="Next-steps-1"></a><a class="docs-heading-anchor-permalink" href="#Next-steps" title="Permalink"></a></h2><p>If you are familiar with SBP operators in general, this introduction might already be enough for you to apply <a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a> to your problems. Otherwise, you might want to have a look at the references, the tutorials coming next, or some ready-to-use semidiscretizations of the following partial differential equations (PDEs). These are shipped with this package and you are encouraged to look at their source code to learn more about it.</p><ul><li>Linear scalar advection with variable coefficient: <a href="../api_reference/#SummationByPartsOperators.VariableLinearAdvectionPeriodicSemidiscretization"><code>VariableLinearAdvectionPeriodicSemidiscretization</code></a>, <a href="../api_reference/#SummationByPartsOperators.VariableLinearAdvectionNonperiodicSemidiscretization"><code>VariableLinearAdvectionNonperiodicSemidiscretization</code></a></li><li>Burgers&#39; equation (inviscid): <a href="../api_reference/#SummationByPartsOperators.BurgersPeriodicSemidiscretization"><code>BurgersPeriodicSemidiscretization</code></a>, <a href="../api_reference/#SummationByPartsOperators.BurgersNonperiodicSemidiscretization"><code>BurgersNonperiodicSemidiscretization</code></a></li><li>Scalar conservation law with cubic flux: <a href="../api_reference/#SummationByPartsOperators.CubicPeriodicSemidiscretization"><code>CubicPeriodicSemidiscretization</code></a>, <a href="../api_reference/#SummationByPartsOperators.CubicNonperiodicSemidiscretization"><code>CubicNonperiodicSemidiscretization</code></a></li><li>A scalar conservation law with quartic, non-convex flux: <a href="../api_reference/#SummationByPartsOperators.QuarticNonconvexPeriodicSemidiscretization"><code>QuarticNonconvexPeriodicSemidiscretization</code></a></li><li>The second-order wave equation: <a href="../api_reference/#SummationByPartsOperators.WaveEquationNonperiodicSemidiscretization"><code>WaveEquationNonperiodicSemidiscretization</code></a></li></ul><p>Some additional examples are included as <a href="https://jupyter.org">Jupyter</a> notebooks in the directory <a href="https://github.com/ranocha/SummationByPartsOperators.jl/tree/main/notebooks"><code>notebooks</code></a>. Even more examples and research articles making use of <a href="https://github.com/ranocha/SummationByPartsOperators.jl">SummationByPartsOperators.jl</a> are listed in the section <a href="../applications/#Applications">Applications</a>. If you want to know even more, you can have a look at the <a href="https://github.com/ranocha/SummationByPartsOperators.jl/tree/main/test">test</a>.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-SvärdNordström2014"><a class="tag is-link" href="#citeref-SvärdNordström2014">SvärdNordström2014</a>Svärd, Nordström (2014). Review of summation-by-parts schemes for initial–boundary-value problems. <a href="https://doi.org/10.1016/j.jcp.2014.02.031">DOI: 10.1016/j.jcp.2014.02.031</a></li><li class="footnote" id="footnote-FernándezHickenZingg2014"><a class="tag is-link" href="#citeref-FernándezHickenZingg2014">FernándezHickenZingg2014</a>Fernández, Hicken, Zingg (2014). Review of summation-by-parts operators with simultaneous approximation terms for the numerical solution of partial differential equations. <a href="https://doi.org/10.1016/j.compfluid.2014.02.016">DOI: 10.1016/j.compfluid.2014.02.016</a></li><li class="footnote" id="footnote-RanochaMitsotakisKetcheson2021"><a class="tag is-link" href="#citeref-RanochaMitsotakisKetcheson2021">RanochaMitsotakisKetcheson2021</a>Ranocha, Mitsotakis, Ketcheson (2021). A Broad Class of Conservative Numerical Methods for Dispersive Wave Equations. <a href="https://doi.org/10.4208/cicp.OA-2020-0119">DOI: 10.4208/cicp.OA-2020-0119</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../tutorials/constant_linear_advection/">Linear advection equation with constant coefficients »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Saturday 24 June 2023 12:40">Saturday 24 June 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
